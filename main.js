/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all2) => {
  for (var name310 in all2)
    __defProp(target, name310, { get: all2[name310], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/typed-function/lib/umd/typed-function.js
var require_typed_function = __commonJS({
  "node_modules/typed-function/lib/umd/typed-function.js"(exports, module2) {
    (function(global2, factory2) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2["'typed'"] = factory2());
    })(exports, function() {
      "use strict";
      function ok() {
        return true;
      }
      function notOk() {
        return false;
      }
      function undef() {
        return void 0;
      }
      const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
      function create3() {
        function isPlainObject2(x2) {
          return typeof x2 === "object" && x2 !== null && x2.constructor === Object;
        }
        const _types = [{
          name: "number",
          test: function(x2) {
            return typeof x2 === "number";
          }
        }, {
          name: "string",
          test: function(x2) {
            return typeof x2 === "string";
          }
        }, {
          name: "boolean",
          test: function(x2) {
            return typeof x2 === "boolean";
          }
        }, {
          name: "Function",
          test: function(x2) {
            return typeof x2 === "function";
          }
        }, {
          name: "Array",
          test: Array.isArray
        }, {
          name: "Date",
          test: function(x2) {
            return x2 instanceof Date;
          }
        }, {
          name: "RegExp",
          test: function(x2) {
            return x2 instanceof RegExp;
          }
        }, {
          name: "Object",
          test: isPlainObject2
        }, {
          name: "null",
          test: function(x2) {
            return x2 === null;
          }
        }, {
          name: "undefined",
          test: function(x2) {
            return x2 === void 0;
          }
        }];
        const anyType = {
          name: "any",
          test: ok,
          isAny: true
        };
        let typeMap;
        let typeList;
        let nConversions = 0;
        let typed3 = {
          createCount: 0
        };
        function findType(typeName) {
          const type = typeMap.get(typeName);
          if (type) {
            return type;
          }
          let message = 'Unknown type "' + typeName + '"';
          const name310 = typeName.toLowerCase();
          let otherName;
          for (otherName of typeList) {
            if (otherName.toLowerCase() === name310) {
              message += '. Did you mean "' + otherName + '" ?';
              break;
            }
          }
          throw new TypeError(message);
        }
        function addTypes(types) {
          let beforeSpec = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
          const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
          const newTypes = [];
          for (let i = 0; i < types.length; ++i) {
            if (!types[i] || typeof types[i].name !== "string" || typeof types[i].test !== "function") {
              throw new TypeError("Object with properties {name: string, test: function} expected");
            }
            const typeName = types[i].name;
            if (typeMap.has(typeName)) {
              throw new TypeError('Duplicate type name "' + typeName + '"');
            }
            newTypes.push(typeName);
            typeMap.set(typeName, {
              name: typeName,
              test: types[i].test,
              isAny: types[i].isAny,
              index: beforeIndex + i,
              conversionsTo: []
              // Newly added type can't have any conversions to it
            });
          }
          const affectedTypes = typeList.slice(beforeIndex);
          typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
          for (let i = beforeIndex + newTypes.length; i < typeList.length; ++i) {
            typeMap.get(typeList[i]).index = i;
          }
        }
        function clear() {
          typeMap = /* @__PURE__ */ new Map();
          typeList = [];
          nConversions = 0;
          addTypes([anyType], false);
        }
        clear();
        addTypes(_types);
        function clearConversions() {
          let typeName;
          for (typeName of typeList) {
            typeMap.get(typeName).conversionsTo = [];
          }
          nConversions = 0;
        }
        function findTypeNames(value) {
          const matches = typeList.filter((name310) => {
            const type = typeMap.get(name310);
            return !type.isAny && type.test(value);
          });
          if (matches.length) {
            return matches;
          }
          return ["any"];
        }
        function isTypedFunction(entity) {
          return entity && typeof entity === "function" && "_typedFunctionData" in entity;
        }
        function findSignature(fn, signature, options) {
          if (!isTypedFunction(fn)) {
            throw new TypeError(NOT_TYPED_FUNCTION);
          }
          const exact = options && options.exact;
          const stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
          const params = parseSignature(stringSignature);
          const canonicalSignature = stringifyParams(params);
          if (!exact || canonicalSignature in fn.signatures) {
            const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
            if (match) {
              return match;
            }
          }
          const nParams = params.length;
          let remainingSignatures;
          if (exact) {
            remainingSignatures = [];
            let name310;
            for (name310 in fn.signatures) {
              remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name310));
            }
          } else {
            remainingSignatures = fn._typedFunctionData.signatures;
          }
          for (let i = 0; i < nParams; ++i) {
            const want = params[i];
            const filteredSignatures = [];
            let possibility;
            for (possibility of remainingSignatures) {
              const have = getParamAtIndex(possibility.params, i);
              if (!have || want.restParam && !have.restParam) {
                continue;
              }
              if (!have.hasAny) {
                const haveTypes = paramTypeSet(have);
                if (want.types.some((wtype) => !haveTypes.has(wtype.name))) {
                  continue;
                }
              }
              filteredSignatures.push(possibility);
            }
            remainingSignatures = filteredSignatures;
            if (remainingSignatures.length === 0)
              break;
          }
          let candidate;
          for (candidate of remainingSignatures) {
            if (candidate.params.length <= nParams) {
              return candidate;
            }
          }
          throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
        }
        function find2(fn, signature, options) {
          return findSignature(fn, signature, options).implementation;
        }
        function convert(value, typeName) {
          const type = findType(typeName);
          if (type.test(value)) {
            return value;
          }
          const conversions = type.conversionsTo;
          if (conversions.length === 0) {
            throw new Error("There are no conversions to " + typeName + " defined.");
          }
          for (let i = 0; i < conversions.length; i++) {
            const fromType = findType(conversions[i].from);
            if (fromType.test(value)) {
              return conversions[i].convert(value);
            }
          }
          throw new Error("Cannot convert " + value + " to " + typeName);
        }
        function stringifyParams(params) {
          let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
          return params.map((p) => p.name).join(separator);
        }
        function parseParam(param) {
          const restParam = param.indexOf("...") === 0;
          const types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
          const typeDefs = types.split("|").map((s2) => findType(s2.trim()));
          let hasAny = false;
          let paramName = restParam ? "..." : "";
          const exactTypes = typeDefs.map(function(type) {
            hasAny = type.isAny || hasAny;
            paramName += type.name + "|";
            return {
              name: type.name,
              typeIndex: type.index,
              test: type.test,
              isAny: type.isAny,
              conversion: null,
              conversionIndex: -1
            };
          });
          return {
            types: exactTypes,
            name: paramName.slice(0, -1),
            // remove trailing '|' from above
            hasAny,
            hasConversion: false,
            restParam
          };
        }
        function expandParam(param) {
          const typeNames = param.types.map((t) => t.name);
          const matchingConversions = availableConversions(typeNames);
          let hasAny = param.hasAny;
          let newName = param.name;
          const convertibleTypes = matchingConversions.map(function(conversion) {
            const type = findType(conversion.from);
            hasAny = type.isAny || hasAny;
            newName += "|" + conversion.from;
            return {
              name: conversion.from,
              typeIndex: type.index,
              test: type.test,
              isAny: type.isAny,
              conversion,
              conversionIndex: conversion.index
            };
          });
          return {
            types: param.types.concat(convertibleTypes),
            name: newName,
            hasAny,
            hasConversion: convertibleTypes.length > 0,
            restParam: param.restParam
          };
        }
        function paramTypeSet(param) {
          if (!param.typeSet) {
            param.typeSet = /* @__PURE__ */ new Set();
            param.types.forEach((type) => param.typeSet.add(type.name));
          }
          return param.typeSet;
        }
        function parseSignature(rawSignature) {
          const params = [];
          if (typeof rawSignature !== "string") {
            throw new TypeError("Signatures must be strings");
          }
          const signature = rawSignature.trim();
          if (signature === "") {
            return params;
          }
          const rawParams = signature.split(",");
          for (let i = 0; i < rawParams.length; ++i) {
            const parsedParam = parseParam(rawParams[i].trim());
            if (parsedParam.restParam && i !== rawParams.length - 1) {
              throw new SyntaxError('Unexpected rest parameter "' + rawParams[i] + '": only allowed for the last parameter');
            }
            if (parsedParam.types.length === 0) {
              return null;
            }
            params.push(parsedParam);
          }
          return params;
        }
        function hasRestParam(params) {
          const param = last(params);
          return param ? param.restParam : false;
        }
        function compileTest(param) {
          if (!param || param.types.length === 0) {
            return ok;
          } else if (param.types.length === 1) {
            return findType(param.types[0].name).test;
          } else if (param.types.length === 2) {
            const test0 = findType(param.types[0].name).test;
            const test1 = findType(param.types[1].name).test;
            return function or(x2) {
              return test0(x2) || test1(x2);
            };
          } else {
            const tests = param.types.map(function(type) {
              return findType(type.name).test;
            });
            return function or(x2) {
              for (let i = 0; i < tests.length; i++) {
                if (tests[i](x2)) {
                  return true;
                }
              }
              return false;
            };
          }
        }
        function compileTests(params) {
          let tests, test0, test1;
          if (hasRestParam(params)) {
            tests = initial(params).map(compileTest);
            const varIndex = tests.length;
            const lastTest = compileTest(last(params));
            const testRestParam = function(args) {
              for (let i = varIndex; i < args.length; i++) {
                if (!lastTest(args[i])) {
                  return false;
                }
              }
              return true;
            };
            return function testArgs(args) {
              for (let i = 0; i < tests.length; i++) {
                if (!tests[i](args[i])) {
                  return false;
                }
              }
              return testRestParam(args) && args.length >= varIndex + 1;
            };
          } else {
            if (params.length === 0) {
              return function testArgs(args) {
                return args.length === 0;
              };
            } else if (params.length === 1) {
              test0 = compileTest(params[0]);
              return function testArgs(args) {
                return test0(args[0]) && args.length === 1;
              };
            } else if (params.length === 2) {
              test0 = compileTest(params[0]);
              test1 = compileTest(params[1]);
              return function testArgs(args) {
                return test0(args[0]) && test1(args[1]) && args.length === 2;
              };
            } else {
              tests = params.map(compileTest);
              return function testArgs(args) {
                for (let i = 0; i < tests.length; i++) {
                  if (!tests[i](args[i])) {
                    return false;
                  }
                }
                return args.length === tests.length;
              };
            }
          }
        }
        function getParamAtIndex(params, index) {
          return index < params.length ? params[index] : hasRestParam(params) ? last(params) : null;
        }
        function getTypeSetAtIndex(params, index) {
          const param = getParamAtIndex(params, index);
          if (!param) {
            return /* @__PURE__ */ new Set();
          }
          return paramTypeSet(param);
        }
        function isExactType(type) {
          return type.conversion === null || type.conversion === void 0;
        }
        function mergeExpectedParams(signatures, index) {
          const typeSet = /* @__PURE__ */ new Set();
          signatures.forEach((signature) => {
            const paramSet = getTypeSetAtIndex(signature.params, index);
            let name310;
            for (name310 of paramSet) {
              typeSet.add(name310);
            }
          });
          return typeSet.has("any") ? ["any"] : Array.from(typeSet);
        }
        function createError(name310, args, signatures) {
          let err, expected;
          const _name = name310 || "unnamed";
          let matchingSignatures = signatures;
          let index;
          for (index = 0; index < args.length; index++) {
            const nextMatchingDefs = [];
            matchingSignatures.forEach((signature) => {
              const param = getParamAtIndex(signature.params, index);
              const test = compileTest(param);
              if ((index < signature.params.length || hasRestParam(signature.params)) && test(args[index])) {
                nextMatchingDefs.push(signature);
              }
            });
            if (nextMatchingDefs.length === 0) {
              expected = mergeExpectedParams(matchingSignatures, index);
              if (expected.length > 0) {
                const actualTypes = findTypeNames(args[index]);
                err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index + ")");
                err.data = {
                  category: "wrongType",
                  fn: _name,
                  index,
                  actual: actualTypes,
                  expected
                };
                return err;
              }
            } else {
              matchingSignatures = nextMatchingDefs;
            }
          }
          const lengths = matchingSignatures.map(function(signature) {
            return hasRestParam(signature.params) ? Infinity : signature.params.length;
          });
          if (args.length < Math.min.apply(null, lengths)) {
            expected = mergeExpectedParams(matchingSignatures, index);
            err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
            err.data = {
              category: "tooFewArgs",
              fn: _name,
              index: args.length,
              expected
            };
            return err;
          }
          const maxLength = Math.max.apply(null, lengths);
          if (args.length > maxLength) {
            err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
            err.data = {
              category: "tooManyArgs",
              fn: _name,
              index: args.length,
              expectedLength: maxLength
            };
            return err;
          }
          const argTypes = [];
          for (let i = 0; i < args.length; ++i) {
            argTypes.push(findTypeNames(args[i]).join("|"));
          }
          err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
          err.data = {
            category: "mismatch",
            actual: argTypes
          };
          return err;
        }
        function getLowestTypeIndex(param) {
          let min4 = typeList.length + 1;
          for (let i = 0; i < param.types.length; i++) {
            if (isExactType(param.types[i])) {
              min4 = Math.min(min4, param.types[i].typeIndex);
            }
          }
          return min4;
        }
        function getLowestConversionIndex(param) {
          let min4 = nConversions + 1;
          for (let i = 0; i < param.types.length; i++) {
            if (!isExactType(param.types[i])) {
              min4 = Math.min(min4, param.types[i].conversionIndex);
            }
          }
          return min4;
        }
        function compareParams(param1, param2) {
          if (param1.hasAny) {
            if (!param2.hasAny) {
              return 1;
            }
          } else if (param2.hasAny) {
            return -1;
          }
          if (param1.restParam) {
            if (!param2.restParam) {
              return 1;
            }
          } else if (param2.restParam) {
            return -1;
          }
          if (param1.hasConversion) {
            if (!param2.hasConversion) {
              return 1;
            }
          } else if (param2.hasConversion) {
            return -1;
          }
          const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
          if (typeDiff < 0) {
            return -1;
          }
          if (typeDiff > 0) {
            return 1;
          }
          const convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
          if (convDiff < 0) {
            return -1;
          }
          if (convDiff > 0) {
            return 1;
          }
          return 0;
        }
        function compareSignatures(signature1, signature2) {
          const pars1 = signature1.params;
          const pars2 = signature2.params;
          const last1 = last(pars1);
          const last2 = last(pars2);
          const hasRest1 = hasRestParam(pars1);
          const hasRest2 = hasRestParam(pars2);
          if (hasRest1 && last1.hasAny) {
            if (!hasRest2 || !last2.hasAny) {
              return 1;
            }
          } else if (hasRest2 && last2.hasAny) {
            return -1;
          }
          let any1 = 0;
          let conv1 = 0;
          let par;
          for (par of pars1) {
            if (par.hasAny)
              ++any1;
            if (par.hasConversion)
              ++conv1;
          }
          let any2 = 0;
          let conv2 = 0;
          for (par of pars2) {
            if (par.hasAny)
              ++any2;
            if (par.hasConversion)
              ++conv2;
          }
          if (any1 !== any2) {
            return any1 - any2;
          }
          if (hasRest1 && last1.hasConversion) {
            if (!hasRest2 || !last2.hasConversion) {
              return 1;
            }
          } else if (hasRest2 && last2.hasConversion) {
            return -1;
          }
          if (conv1 !== conv2) {
            return conv1 - conv2;
          }
          if (hasRest1) {
            if (!hasRest2) {
              return 1;
            }
          } else if (hasRest2) {
            return -1;
          }
          const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
          if (lengthCriterion !== 0) {
            return lengthCriterion;
          }
          const comparisons = [];
          let tc = 0;
          for (let i = 0; i < pars1.length; ++i) {
            const thisComparison = compareParams(pars1[i], pars2[i]);
            comparisons.push(thisComparison);
            tc += thisComparison;
          }
          if (tc !== 0) {
            return tc;
          }
          let c2;
          for (c2 of comparisons) {
            if (c2 !== 0) {
              return c2;
            }
          }
          return 0;
        }
        function availableConversions(typeNames) {
          if (typeNames.length === 0) {
            return [];
          }
          const types = typeNames.map(findType);
          if (typeNames.length > 1) {
            types.sort((t13, t22) => t13.index - t22.index);
          }
          let matches = types[0].conversionsTo;
          if (typeNames.length === 1) {
            return matches;
          }
          matches = matches.concat([]);
          const knownTypes = new Set(typeNames);
          for (let i = 1; i < types.length; ++i) {
            let newMatch;
            for (newMatch of types[i].conversionsTo) {
              if (!knownTypes.has(newMatch.from)) {
                matches.push(newMatch);
                knownTypes.add(newMatch.from);
              }
            }
          }
          return matches;
        }
        function compileArgsPreprocessing(params, fn) {
          let fnConvert = fn;
          if (params.some((p) => p.hasConversion)) {
            const restParam = hasRestParam(params);
            const compiledConversions = params.map(compileArgConversion);
            fnConvert = function convertArgs() {
              const args = [];
              const last2 = restParam ? arguments.length - 1 : arguments.length;
              for (let i = 0; i < last2; i++) {
                args[i] = compiledConversions[i](arguments[i]);
              }
              if (restParam) {
                args[last2] = arguments[last2].map(compiledConversions[last2]);
              }
              return fn.apply(this, args);
            };
          }
          let fnPreprocess = fnConvert;
          if (hasRestParam(params)) {
            const offset = params.length - 1;
            fnPreprocess = function preprocessRestParams() {
              return fnConvert.apply(this, slice2(arguments, 0, offset).concat([slice2(arguments, offset)]));
            };
          }
          return fnPreprocess;
        }
        function compileArgConversion(param) {
          let test0, test1, conversion0, conversion1;
          const tests = [];
          const conversions = [];
          param.types.forEach(function(type) {
            if (type.conversion) {
              tests.push(findType(type.conversion.from).test);
              conversions.push(type.conversion.convert);
            }
          });
          switch (conversions.length) {
            case 0:
              return function convertArg(arg) {
                return arg;
              };
            case 1:
              test0 = tests[0];
              conversion0 = conversions[0];
              return function convertArg(arg) {
                if (test0(arg)) {
                  return conversion0(arg);
                }
                return arg;
              };
            case 2:
              test0 = tests[0];
              test1 = tests[1];
              conversion0 = conversions[0];
              conversion1 = conversions[1];
              return function convertArg(arg) {
                if (test0(arg)) {
                  return conversion0(arg);
                }
                if (test1(arg)) {
                  return conversion1(arg);
                }
                return arg;
              };
            default:
              return function convertArg(arg) {
                for (let i = 0; i < conversions.length; i++) {
                  if (tests[i](arg)) {
                    return conversions[i](arg);
                  }
                }
                return arg;
              };
          }
        }
        function splitParams(params) {
          function _splitParams(params2, index, paramsSoFar) {
            if (index < params2.length) {
              const param = params2[index];
              let resultingParams = [];
              if (param.restParam) {
                const exactTypes = param.types.filter(isExactType);
                if (exactTypes.length < param.types.length) {
                  resultingParams.push({
                    types: exactTypes,
                    name: "..." + exactTypes.map((t) => t.name).join("|"),
                    hasAny: exactTypes.some((t) => t.isAny),
                    hasConversion: false,
                    restParam: true
                  });
                }
                resultingParams.push(param);
              } else {
                resultingParams = param.types.map(function(type) {
                  return {
                    types: [type],
                    name: type.name,
                    hasAny: type.isAny,
                    hasConversion: type.conversion,
                    restParam: false
                  };
                });
              }
              return flatMap(resultingParams, function(nextParam) {
                return _splitParams(params2, index + 1, paramsSoFar.concat([nextParam]));
              });
            } else {
              return [paramsSoFar];
            }
          }
          return _splitParams(params, 0, []);
        }
        function conflicting(params1, params2) {
          const ii = Math.max(params1.length, params2.length);
          for (let i = 0; i < ii; i++) {
            const typeSet1 = getTypeSetAtIndex(params1, i);
            const typeSet2 = getTypeSetAtIndex(params2, i);
            let overlap = false;
            let name310;
            for (name310 of typeSet2) {
              if (typeSet1.has(name310)) {
                overlap = true;
                break;
              }
            }
            if (!overlap) {
              return false;
            }
          }
          const len1 = params1.length;
          const len2 = params2.length;
          const restParam1 = hasRestParam(params1);
          const restParam2 = hasRestParam(params2);
          return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
        }
        function clearResolutions(functionList) {
          return functionList.map((fn) => {
            if (isReferToSelf(fn)) {
              return referToSelf(fn.referToSelf.callback);
            }
            if (isReferTo(fn)) {
              return makeReferTo(fn.referTo.references, fn.referTo.callback);
            }
            return fn;
          });
        }
        function collectResolutions(references, functionList, signatureMap) {
          const resolvedReferences = [];
          let reference;
          for (reference of references) {
            let resolution = signatureMap[reference];
            if (typeof resolution !== "number") {
              throw new TypeError('No definition for referenced signature "' + reference + '"');
            }
            resolution = functionList[resolution];
            if (typeof resolution !== "function") {
              return false;
            }
            resolvedReferences.push(resolution);
          }
          return resolvedReferences;
        }
        function resolveReferences(functionList, signatureMap, self2) {
          const resolvedFunctions = clearResolutions(functionList);
          const isResolved = new Array(resolvedFunctions.length).fill(false);
          let leftUnresolved = true;
          while (leftUnresolved) {
            leftUnresolved = false;
            let nothingResolved = true;
            for (let i = 0; i < resolvedFunctions.length; ++i) {
              if (isResolved[i])
                continue;
              const fn = resolvedFunctions[i];
              if (isReferToSelf(fn)) {
                resolvedFunctions[i] = fn.referToSelf.callback(self2);
                resolvedFunctions[i].referToSelf = fn.referToSelf;
                isResolved[i] = true;
                nothingResolved = false;
              } else if (isReferTo(fn)) {
                const resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);
                if (resolvedReferences) {
                  resolvedFunctions[i] = fn.referTo.callback.apply(this, resolvedReferences);
                  resolvedFunctions[i].referTo = fn.referTo;
                  isResolved[i] = true;
                  nothingResolved = false;
                } else {
                  leftUnresolved = true;
                }
              }
            }
            if (nothingResolved && leftUnresolved) {
              throw new SyntaxError("Circular reference detected in resolving typed.referTo");
            }
          }
          return resolvedFunctions;
        }
        function validateDeprecatedThis(signaturesMap) {
          const deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
          Object.keys(signaturesMap).forEach((signature) => {
            const fn = signaturesMap[signature];
            if (deprecatedThisRegex.test(fn.toString())) {
              throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
            }
          });
        }
        function createTypedFunction(name310, rawSignaturesMap) {
          typed3.createCount++;
          if (Object.keys(rawSignaturesMap).length === 0) {
            throw new SyntaxError("No signatures provided");
          }
          if (typed3.warnAgainstDeprecatedThis) {
            validateDeprecatedThis(rawSignaturesMap);
          }
          const parsedParams = [];
          const originalFunctions = [];
          const signaturesMap = {};
          const preliminarySignatures = [];
          let signature;
          for (signature in rawSignaturesMap) {
            if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
              continue;
            }
            const params = parseSignature(signature);
            if (!params)
              continue;
            parsedParams.forEach(function(pp) {
              if (conflicting(pp, params)) {
                throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
              }
            });
            parsedParams.push(params);
            const functionIndex = originalFunctions.length;
            originalFunctions.push(rawSignaturesMap[signature]);
            const conversionParams = params.map(expandParam);
            let sp;
            for (sp of splitParams(conversionParams)) {
              const spName = stringifyParams(sp);
              preliminarySignatures.push({
                params: sp,
                name: spName,
                fn: functionIndex
              });
              if (sp.every((p) => !p.hasConversion)) {
                signaturesMap[spName] = functionIndex;
              }
            }
          }
          preliminarySignatures.sort(compareSignatures);
          const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
          let s2;
          for (s2 in signaturesMap) {
            if (Object.prototype.hasOwnProperty.call(signaturesMap, s2)) {
              signaturesMap[s2] = resolvedFunctions[signaturesMap[s2]];
            }
          }
          const signatures = [];
          const internalSignatureMap = /* @__PURE__ */ new Map();
          for (s2 of preliminarySignatures) {
            if (!internalSignatureMap.has(s2.name)) {
              s2.fn = resolvedFunctions[s2.fn];
              signatures.push(s2);
              internalSignatureMap.set(s2.name, s2);
            }
          }
          const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
          const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
          const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
          const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
          const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
          const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
          const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
          for (let i = 0; i < signatures.length; ++i) {
            signatures[i].test = compileTests(signatures[i].params);
          }
          const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
          const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
          const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
          const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
          const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
          const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
          const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
          const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
          const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
          const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
          const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
          const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
          for (let i = 0; i < signatures.length; ++i) {
            signatures[i].implementation = compileArgsPreprocessing(signatures[i].params, signatures[i].fn);
          }
          const fn0 = ok0 ? signatures[0].implementation : undef;
          const fn1 = ok1 ? signatures[1].implementation : undef;
          const fn2 = ok2 ? signatures[2].implementation : undef;
          const fn3 = ok3 ? signatures[3].implementation : undef;
          const fn4 = ok4 ? signatures[4].implementation : undef;
          const fn5 = ok5 ? signatures[5].implementation : undef;
          const len0 = ok0 ? signatures[0].params.length : -1;
          const len1 = ok1 ? signatures[1].params.length : -1;
          const len2 = ok2 ? signatures[2].params.length : -1;
          const len3 = ok3 ? signatures[3].params.length : -1;
          const len4 = ok4 ? signatures[4].params.length : -1;
          const len5 = ok5 ? signatures[5].params.length : -1;
          const iStart = allOk ? 6 : 0;
          const iEnd = signatures.length;
          const tests = signatures.map((s3) => s3.test);
          const fns = signatures.map((s3) => s3.implementation);
          const generic = function generic2() {
            for (let i = iStart; i < iEnd; i++) {
              if (tests[i](arguments)) {
                return fns[i].apply(this, arguments);
              }
            }
            return typed3.onMismatch(name310, arguments, signatures);
          };
          function theTypedFn(arg0, arg1) {
            if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
              return fn0.apply(this, arguments);
            }
            if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
              return fn1.apply(this, arguments);
            }
            if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
              return fn2.apply(this, arguments);
            }
            if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
              return fn3.apply(this, arguments);
            }
            if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
              return fn4.apply(this, arguments);
            }
            if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
              return fn5.apply(this, arguments);
            }
            return generic.apply(this, arguments);
          }
          try {
            Object.defineProperty(theTypedFn, "name", {
              value: name310
            });
          } catch (err) {
          }
          theTypedFn.signatures = signaturesMap;
          theTypedFn._typedFunctionData = {
            signatures,
            signatureMap: internalSignatureMap
          };
          return theTypedFn;
        }
        function _onMismatch(name310, args, signatures) {
          throw createError(name310, args, signatures);
        }
        function initial(arr) {
          return slice2(arr, 0, arr.length - 1);
        }
        function last(arr) {
          return arr[arr.length - 1];
        }
        function slice2(arr, start2, end) {
          return Array.prototype.slice.call(arr, start2, end);
        }
        function findInArray(arr, test) {
          for (let i = 0; i < arr.length; i++) {
            if (test(arr[i])) {
              return arr[i];
            }
          }
          return void 0;
        }
        function flatMap(arr, callback) {
          return Array.prototype.concat.apply([], arr.map(callback));
        }
        function referTo() {
          const references = initial(arguments).map((s2) => stringifyParams(parseSignature(s2)));
          const callback = last(arguments);
          if (typeof callback !== "function") {
            throw new TypeError("Callback function expected as last argument");
          }
          return makeReferTo(references, callback);
        }
        function makeReferTo(references, callback) {
          return {
            referTo: {
              references,
              callback
            }
          };
        }
        function referToSelf(callback) {
          if (typeof callback !== "function") {
            throw new TypeError("Callback function expected as first argument");
          }
          return {
            referToSelf: {
              callback
            }
          };
        }
        function isReferTo(objectOrFn) {
          return objectOrFn && typeof objectOrFn.referTo === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
        }
        function isReferToSelf(objectOrFn) {
          return objectOrFn && typeof objectOrFn.referToSelf === "object" && typeof objectOrFn.referToSelf.callback === "function";
        }
        function checkName(nameSoFar, newName) {
          if (!nameSoFar) {
            return newName;
          }
          if (newName && newName !== nameSoFar) {
            const err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
            err.data = {
              actual: newName,
              expected: nameSoFar
            };
            throw err;
          }
          return nameSoFar;
        }
        function getObjectName(obj) {
          let name310;
          for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
              name310 = checkName(name310, obj[key].name);
            }
          }
          return name310;
        }
        function mergeSignatures(dest, source) {
          let key;
          for (key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              if (key in dest) {
                if (source[key] !== dest[key]) {
                  const err = new Error('Signature "' + key + '" is defined twice');
                  err.data = {
                    signature: key,
                    sourceFunction: source[key],
                    destFunction: dest[key]
                  };
                  throw err;
                }
              }
              dest[key] = source[key];
            }
          }
        }
        const saveTyped = typed3;
        typed3 = function(maybeName) {
          const named2 = typeof maybeName === "string";
          const start2 = named2 ? 1 : 0;
          let name310 = named2 ? maybeName : "";
          const allSignatures = {};
          for (let i = start2; i < arguments.length; ++i) {
            const item = arguments[i];
            let theseSignatures = {};
            let thisName;
            if (typeof item === "function") {
              thisName = item.name;
              if (typeof item.signature === "string") {
                theseSignatures[item.signature] = item;
              } else if (isTypedFunction(item)) {
                theseSignatures = item.signatures;
              }
            } else if (isPlainObject2(item)) {
              theseSignatures = item;
              if (!named2) {
                thisName = getObjectName(item);
              }
            }
            if (Object.keys(theseSignatures).length === 0) {
              const err = new TypeError("Argument to 'typed' at index " + i + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
              err.data = {
                index: i,
                argument: item
              };
              throw err;
            }
            if (!named2) {
              name310 = checkName(name310, thisName);
            }
            mergeSignatures(allSignatures, theseSignatures);
          }
          return createTypedFunction(name310 || "", allSignatures);
        };
        typed3.create = create3;
        typed3.createCount = saveTyped.createCount;
        typed3.onMismatch = _onMismatch;
        typed3.throwMismatchError = _onMismatch;
        typed3.createError = createError;
        typed3.clear = clear;
        typed3.clearConversions = clearConversions;
        typed3.addTypes = addTypes;
        typed3._findType = findType;
        typed3.referTo = referTo;
        typed3.referToSelf = referToSelf;
        typed3.convert = convert;
        typed3.findSignature = findSignature;
        typed3.find = find2;
        typed3.isTypedFunction = isTypedFunction;
        typed3.warnAgainstDeprecatedThis = true;
        typed3.addType = function(type, beforeObjectTest) {
          let before = "any";
          if (beforeObjectTest !== false && typeMap.has("Object")) {
            before = "Object";
          }
          typed3.addTypes([type], before);
        };
        function _validateConversion(conversion) {
          if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
            throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
          }
          if (conversion.to === conversion.from) {
            throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
          }
        }
        typed3.addConversion = function(conversion) {
          let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            override: false
          };
          _validateConversion(conversion);
          const to = findType(conversion.to);
          const existing = to.conversionsTo.find((other) => other.from === conversion.from);
          if (existing) {
            if (options && options.override) {
              typed3.removeConversion({
                from: existing.from,
                to: conversion.to,
                convert: existing.convert
              });
            } else {
              throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to.name + '"');
            }
          }
          to.conversionsTo.push({
            from: conversion.from,
            convert: conversion.convert,
            index: nConversions++
          });
        };
        typed3.addConversions = function(conversions, options) {
          conversions.forEach((conversion) => typed3.addConversion(conversion, options));
        };
        typed3.removeConversion = function(conversion) {
          _validateConversion(conversion);
          const to = findType(conversion.to);
          const existingConversion = findInArray(to.conversionsTo, (c2) => c2.from === conversion.from);
          if (!existingConversion) {
            throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
          }
          if (existingConversion.convert !== conversion.convert) {
            throw new Error("Conversion to remove does not match existing conversion");
          }
          const index = to.conversionsTo.indexOf(existingConversion);
          to.conversionsTo.splice(index, 1);
        };
        typed3.resolve = function(tf, argList) {
          if (!isTypedFunction(tf)) {
            throw new TypeError(NOT_TYPED_FUNCTION);
          }
          const sigs = tf._typedFunctionData.signatures;
          for (let i = 0; i < sigs.length; ++i) {
            if (sigs[i].test(argList)) {
              return sigs[i];
            }
          }
          return null;
        };
        return typed3;
      }
      var typedFunction3 = create3();
      return typedFunction3;
    });
  }
});

// node_modules/complex.js/complex.js
var require_complex = __commonJS({
  "node_modules/complex.js/complex.js"(exports, module2) {
    (function(root2) {
      "use strict";
      var cosh4 = Math.cosh || function(x2) {
        return Math.abs(x2) < 1e-9 ? 1 - x2 : (Math.exp(x2) + Math.exp(-x2)) * 0.5;
      };
      var sinh4 = Math.sinh || function(x2) {
        return Math.abs(x2) < 1e-9 ? x2 : (Math.exp(x2) - Math.exp(-x2)) * 0.5;
      };
      var cosm1 = function(x2) {
        var b = Math.PI / 4;
        if (-b > x2 || x2 > b) {
          return Math.cos(x2) - 1;
        }
        var xx = x2 * x2;
        return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
      };
      var hypot2 = function(x2, y2) {
        var a2 = Math.abs(x2);
        var b = Math.abs(y2);
        if (a2 < 3e3 && b < 3e3) {
          return Math.sqrt(a2 * a2 + b * b);
        }
        if (a2 < b) {
          a2 = b;
          b = x2 / y2;
        } else {
          b = y2 / x2;
        }
        return a2 * Math.sqrt(1 + b * b);
      };
      var parser_exit = function() {
        throw SyntaxError("Invalid Param");
      };
      function logHypot(a2, b) {
        var _a = Math.abs(a2);
        var _b = Math.abs(b);
        if (a2 === 0) {
          return Math.log(_b);
        }
        if (b === 0) {
          return Math.log(_a);
        }
        if (_a < 3e3 && _b < 3e3) {
          return Math.log(a2 * a2 + b * b) * 0.5;
        }
        a2 = a2 / 2;
        b = b / 2;
        return 0.5 * Math.log(a2 * a2 + b * b) + Math.LN2;
      }
      var parse = function(a2, b) {
        var z = { "re": 0, "im": 0 };
        if (a2 === void 0 || a2 === null) {
          z["re"] = z["im"] = 0;
        } else if (b !== void 0) {
          z["re"] = a2;
          z["im"] = b;
        } else
          switch (typeof a2) {
            case "object":
              if ("im" in a2 && "re" in a2) {
                z["re"] = a2["re"];
                z["im"] = a2["im"];
              } else if ("abs" in a2 && "arg" in a2) {
                if (!Number.isFinite(a2["abs"]) && Number.isFinite(a2["arg"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a2["abs"] * Math.cos(a2["arg"]);
                z["im"] = a2["abs"] * Math.sin(a2["arg"]);
              } else if ("r" in a2 && "phi" in a2) {
                if (!Number.isFinite(a2["r"]) && Number.isFinite(a2["phi"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a2["r"] * Math.cos(a2["phi"]);
                z["im"] = a2["r"] * Math.sin(a2["phi"]);
              } else if (a2.length === 2) {
                z["re"] = a2[0];
                z["im"] = a2[1];
              } else {
                parser_exit();
              }
              break;
            case "string":
              z["im"] = /* void */
              z["re"] = 0;
              var tokens = a2.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
              var plus = 1;
              var minus = 0;
              if (tokens === null) {
                parser_exit();
              }
              for (var i = 0; i < tokens.length; i++) {
                var c2 = tokens[i];
                if (c2 === " " || c2 === "	" || c2 === "\n") {
                } else if (c2 === "+") {
                  plus++;
                } else if (c2 === "-") {
                  minus++;
                } else if (c2 === "i" || c2 === "I") {
                  if (plus + minus === 0) {
                    parser_exit();
                  }
                  if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
                    i++;
                  } else {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                  }
                  plus = minus = 0;
                } else {
                  if (plus + minus === 0 || isNaN(c2)) {
                    parser_exit();
                  }
                  if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + c2);
                    i++;
                  } else {
                    z["re"] += parseFloat((minus % 2 ? "-" : "") + c2);
                  }
                  plus = minus = 0;
                }
              }
              if (plus + minus > 0) {
                parser_exit();
              }
              break;
            case "number":
              z["im"] = 0;
              z["re"] = a2;
              break;
            default:
              parser_exit();
          }
        if (isNaN(z["re"]) || isNaN(z["im"])) {
        }
        return z;
      };
      function Complex3(a2, b) {
        if (!(this instanceof Complex3)) {
          return new Complex3(a2, b);
        }
        var z = parse(a2, b);
        this["re"] = z["re"];
        this["im"] = z["im"];
      }
      Complex3.prototype = {
        "re": 0,
        "im": 0,
        /**
         * Calculates the sign of a complex number, which is a normalized complex
         *
         * @returns {Complex}
         */
        "sign": function() {
          var abs3 = this["abs"]();
          return new Complex3(
            this["re"] / abs3,
            this["im"] / abs3
          );
        },
        /**
         * Adds two complex numbers
         *
         * @returns {Complex}
         */
        "add": function(a2, b) {
          var z = new Complex3(a2, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] + z["re"],
            this["im"] + z["im"]
          );
        },
        /**
         * Subtracts two complex numbers
         *
         * @returns {Complex}
         */
        "sub": function(a2, b) {
          var z = new Complex3(a2, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] - z["re"],
            this["im"] - z["im"]
          );
        },
        /**
         * Multiplies two complex numbers
         *
         * @returns {Complex}
         */
        "mul": function(a2, b) {
          var z = new Complex3(a2, b);
          if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          if (z["im"] === 0 && this["im"] === 0) {
            return new Complex3(this["re"] * z["re"], 0);
          }
          return new Complex3(
            this["re"] * z["re"] - this["im"] * z["im"],
            this["re"] * z["im"] + this["im"] * z["re"]
          );
        },
        /**
         * Divides two complex numbers
         *
         * @returns {Complex}
         */
        "div": function(a2, b) {
          var z = new Complex3(a2, b);
          if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isZero"]() || z["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          a2 = this["re"];
          b = this["im"];
          var c2 = z["re"];
          var d = z["im"];
          var t, x2;
          if (0 === d) {
            return new Complex3(a2 / c2, b / c2);
          }
          if (Math.abs(c2) < Math.abs(d)) {
            x2 = c2 / d;
            t = c2 * x2 + d;
            return new Complex3(
              (a2 * x2 + b) / t,
              (b * x2 - a2) / t
            );
          } else {
            x2 = d / c2;
            t = d * x2 + c2;
            return new Complex3(
              (a2 + b * x2) / t,
              (b - a2 * x2) / t
            );
          }
        },
        /**
         * Calculate the power of two complex numbers
         *
         * @returns {Complex}
         */
        "pow": function(a2, b) {
          var z = new Complex3(a2, b);
          a2 = this["re"];
          b = this["im"];
          if (z["isZero"]()) {
            return Complex3["ONE"];
          }
          if (z["im"] === 0) {
            if (b === 0 && a2 > 0) {
              return new Complex3(Math.pow(a2, z["re"]), 0);
            } else if (a2 === 0) {
              switch ((z["re"] % 4 + 4) % 4) {
                case 0:
                  return new Complex3(Math.pow(b, z["re"]), 0);
                case 1:
                  return new Complex3(0, Math.pow(b, z["re"]));
                case 2:
                  return new Complex3(-Math.pow(b, z["re"]), 0);
                case 3:
                  return new Complex3(0, -Math.pow(b, z["re"]));
              }
            }
          }
          if (a2 === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
            return Complex3["ZERO"];
          }
          var arg = Math.atan2(b, a2);
          var loh = logHypot(a2, b);
          a2 = Math.exp(z["re"] * loh - z["im"] * arg);
          b = z["im"] * loh + z["re"] * arg;
          return new Complex3(
            a2 * Math.cos(b),
            a2 * Math.sin(b)
          );
        },
        /**
         * Calculate the complex square root
         *
         * @returns {Complex}
         */
        "sqrt": function() {
          var a2 = this["re"];
          var b = this["im"];
          var r = this["abs"]();
          var re2, im;
          if (a2 >= 0) {
            if (b === 0) {
              return new Complex3(Math.sqrt(a2), 0);
            }
            re2 = 0.5 * Math.sqrt(2 * (r + a2));
          } else {
            re2 = Math.abs(b) / Math.sqrt(2 * (r - a2));
          }
          if (a2 <= 0) {
            im = 0.5 * Math.sqrt(2 * (r - a2));
          } else {
            im = Math.abs(b) / Math.sqrt(2 * (r + a2));
          }
          return new Complex3(re2, b < 0 ? -im : im);
        },
        /**
         * Calculate the complex exponent
         *
         * @returns {Complex}
         */
        "exp": function() {
          var tmp = Math.exp(this["re"]);
          if (this["im"] === 0) {
          }
          return new Complex3(
            tmp * Math.cos(this["im"]),
            tmp * Math.sin(this["im"])
          );
        },
        /**
         * Calculate the complex exponent and subtracts one.
         *
         * This may be more accurate than `Complex(x).exp().sub(1)` if
         * `x` is small.
         *
         * @returns {Complex}
         */
        "expm1": function() {
          var a2 = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.expm1(a2) * Math.cos(b) + cosm1(b),
            Math.exp(a2) * Math.sin(b)
          );
        },
        /**
         * Calculate the natural log
         *
         * @returns {Complex}
         */
        "log": function() {
          var a2 = this["re"];
          var b = this["im"];
          if (b === 0 && a2 > 0) {
          }
          return new Complex3(
            logHypot(a2, b),
            Math.atan2(b, a2)
          );
        },
        /**
         * Calculate the magnitude of the complex number
         *
         * @returns {number}
         */
        "abs": function() {
          return hypot2(this["re"], this["im"]);
        },
        /**
         * Calculate the angle of the complex number
         *
         * @returns {number}
         */
        "arg": function() {
          return Math.atan2(this["im"], this["re"]);
        },
        /**
         * Calculate the sine of the complex number
         *
         * @returns {Complex}
         */
        "sin": function() {
          var a2 = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.sin(a2) * cosh4(b),
            Math.cos(a2) * sinh4(b)
          );
        },
        /**
         * Calculate the cosine
         *
         * @returns {Complex}
         */
        "cos": function() {
          var a2 = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.cos(a2) * cosh4(b),
            -Math.sin(a2) * sinh4(b)
          );
        },
        /**
         * Calculate the tangent
         *
         * @returns {Complex}
         */
        "tan": function() {
          var a2 = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a2) + cosh4(b);
          return new Complex3(
            Math.sin(a2) / d,
            sinh4(b) / d
          );
        },
        /**
         * Calculate the cotangent
         *
         * @returns {Complex}
         */
        "cot": function() {
          var a2 = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a2) - cosh4(b);
          return new Complex3(
            -Math.sin(a2) / d,
            sinh4(b) / d
          );
        },
        /**
         * Calculate the secant
         *
         * @returns {Complex}
         */
        "sec": function() {
          var a2 = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh4(2 * b) + 0.5 * Math.cos(2 * a2);
          return new Complex3(
            Math.cos(a2) * cosh4(b) / d,
            Math.sin(a2) * sinh4(b) / d
          );
        },
        /**
         * Calculate the cosecans
         *
         * @returns {Complex}
         */
        "csc": function() {
          var a2 = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh4(2 * b) - 0.5 * Math.cos(2 * a2);
          return new Complex3(
            Math.sin(a2) * cosh4(b) / d,
            -Math.cos(a2) * sinh4(b) / d
          );
        },
        /**
         * Calculate the complex arcus sinus
         *
         * @returns {Complex}
         */
        "asin": function() {
          var a2 = this["re"];
          var b = this["im"];
          var t13 = new Complex3(
            b * b - a2 * a2 + 1,
            -2 * a2 * b
          )["sqrt"]();
          var t22 = new Complex3(
            t13["re"] - b,
            t13["im"] + a2
          )["log"]();
          return new Complex3(t22["im"], -t22["re"]);
        },
        /**
         * Calculate the complex arcus cosinus
         *
         * @returns {Complex}
         */
        "acos": function() {
          var a2 = this["re"];
          var b = this["im"];
          var t13 = new Complex3(
            b * b - a2 * a2 + 1,
            -2 * a2 * b
          )["sqrt"]();
          var t22 = new Complex3(
            t13["re"] - b,
            t13["im"] + a2
          )["log"]();
          return new Complex3(Math.PI / 2 - t22["im"], t22["re"]);
        },
        /**
         * Calculate the complex arcus tangent
         *
         * @returns {Complex}
         */
        "atan": function() {
          var a2 = this["re"];
          var b = this["im"];
          if (a2 === 0) {
            if (b === 1) {
              return new Complex3(0, Infinity);
            }
            if (b === -1) {
              return new Complex3(0, -Infinity);
            }
          }
          var d = a2 * a2 + (1 - b) * (1 - b);
          var t13 = new Complex3(
            (1 - b * b - a2 * a2) / d,
            -2 * a2 / d
          ).log();
          return new Complex3(-0.5 * t13["im"], 0.5 * t13["re"]);
        },
        /**
         * Calculate the complex arcus cotangent
         *
         * @returns {Complex}
         */
        "acot": function() {
          var a2 = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex3(Math.atan2(1, a2), 0);
          }
          var d = a2 * a2 + b * b;
          return d !== 0 ? new Complex3(
            a2 / d,
            -b / d
          ).atan() : new Complex3(
            a2 !== 0 ? a2 / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atan();
        },
        /**
         * Calculate the complex arcus secant
         *
         * @returns {Complex}
         */
        "asec": function() {
          var a2 = this["re"];
          var b = this["im"];
          if (a2 === 0 && b === 0) {
            return new Complex3(0, Infinity);
          }
          var d = a2 * a2 + b * b;
          return d !== 0 ? new Complex3(
            a2 / d,
            -b / d
          ).acos() : new Complex3(
            a2 !== 0 ? a2 / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acos();
        },
        /**
         * Calculate the complex arcus cosecans
         *
         * @returns {Complex}
         */
        "acsc": function() {
          var a2 = this["re"];
          var b = this["im"];
          if (a2 === 0 && b === 0) {
            return new Complex3(Math.PI / 2, Infinity);
          }
          var d = a2 * a2 + b * b;
          return d !== 0 ? new Complex3(
            a2 / d,
            -b / d
          ).asin() : new Complex3(
            a2 !== 0 ? a2 / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asin();
        },
        /**
         * Calculate the complex sinh
         *
         * @returns {Complex}
         */
        "sinh": function() {
          var a2 = this["re"];
          var b = this["im"];
          return new Complex3(
            sinh4(a2) * Math.cos(b),
            cosh4(a2) * Math.sin(b)
          );
        },
        /**
         * Calculate the complex cosh
         *
         * @returns {Complex}
         */
        "cosh": function() {
          var a2 = this["re"];
          var b = this["im"];
          return new Complex3(
            cosh4(a2) * Math.cos(b),
            sinh4(a2) * Math.sin(b)
          );
        },
        /**
         * Calculate the complex tanh
         *
         * @returns {Complex}
         */
        "tanh": function() {
          var a2 = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh4(a2) + Math.cos(b);
          return new Complex3(
            sinh4(a2) / d,
            Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        "coth": function() {
          var a2 = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh4(a2) - Math.cos(b);
          return new Complex3(
            sinh4(a2) / d,
            -Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        "csch": function() {
          var a2 = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) - cosh4(2 * a2);
          return new Complex3(
            -2 * sinh4(a2) * Math.cos(b) / d,
            2 * cosh4(a2) * Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex sech
         *
         * @returns {Complex}
         */
        "sech": function() {
          var a2 = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) + cosh4(2 * a2);
          return new Complex3(
            2 * cosh4(a2) * Math.cos(b) / d,
            -2 * sinh4(a2) * Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex asinh
         *
         * @returns {Complex}
         */
        "asinh": function() {
          var tmp = this["im"];
          this["im"] = -this["re"];
          this["re"] = tmp;
          var res = this["asin"]();
          this["re"] = -this["im"];
          this["im"] = tmp;
          tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
          return res;
        },
        /**
         * Calculate the complex acosh
         *
         * @returns {Complex}
         */
        "acosh": function() {
          var res = this["acos"]();
          if (res["im"] <= 0) {
            var tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
          } else {
            var tmp = res["im"];
            res["im"] = -res["re"];
            res["re"] = tmp;
          }
          return res;
        },
        /**
         * Calculate the complex atanh
         *
         * @returns {Complex}
         */
        "atanh": function() {
          var a2 = this["re"];
          var b = this["im"];
          var noIM = a2 > 1 && b === 0;
          var oneMinus = 1 - a2;
          var onePlus = 1 + a2;
          var d = oneMinus * oneMinus + b * b;
          var x2 = d !== 0 ? new Complex3(
            (onePlus * oneMinus - b * b) / d,
            (b * oneMinus + onePlus * b) / d
          ) : new Complex3(
            a2 !== -1 ? a2 / 0 : 0,
            b !== 0 ? b / 0 : 0
          );
          var temp = x2["re"];
          x2["re"] = logHypot(x2["re"], x2["im"]) / 2;
          x2["im"] = Math.atan2(x2["im"], temp) / 2;
          if (noIM) {
            x2["im"] = -x2["im"];
          }
          return x2;
        },
        /**
         * Calculate the complex acoth
         *
         * @returns {Complex}
         */
        "acoth": function() {
          var a2 = this["re"];
          var b = this["im"];
          if (a2 === 0 && b === 0) {
            return new Complex3(0, Math.PI / 2);
          }
          var d = a2 * a2 + b * b;
          return d !== 0 ? new Complex3(
            a2 / d,
            -b / d
          ).atanh() : new Complex3(
            a2 !== 0 ? a2 / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atanh();
        },
        /**
         * Calculate the complex acsch
         *
         * @returns {Complex}
         */
        "acsch": function() {
          var a2 = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex3(
              a2 !== 0 ? Math.log(a2 + Math.sqrt(a2 * a2 + 1)) : Infinity,
              0
            );
          }
          var d = a2 * a2 + b * b;
          return d !== 0 ? new Complex3(
            a2 / d,
            -b / d
          ).asinh() : new Complex3(
            a2 !== 0 ? a2 / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asinh();
        },
        /**
         * Calculate the complex asech
         *
         * @returns {Complex}
         */
        "asech": function() {
          var a2 = this["re"];
          var b = this["im"];
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          var d = a2 * a2 + b * b;
          return d !== 0 ? new Complex3(
            a2 / d,
            -b / d
          ).acosh() : new Complex3(
            a2 !== 0 ? a2 / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acosh();
        },
        /**
         * Calculate the complex inverse 1/z
         *
         * @returns {Complex}
         */
        "inverse": function() {
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          var a2 = this["re"];
          var b = this["im"];
          var d = a2 * a2 + b * b;
          return new Complex3(a2 / d, -b / d);
        },
        /**
         * Returns the complex conjugate
         *
         * @returns {Complex}
         */
        "conjugate": function() {
          return new Complex3(this["re"], -this["im"]);
        },
        /**
         * Gets the negated complex number
         *
         * @returns {Complex}
         */
        "neg": function() {
          return new Complex3(-this["re"], -this["im"]);
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.ceil(this["re"] * places) / places,
            Math.ceil(this["im"] * places) / places
          );
        },
        /**
         * Floors the actual complex number
         *
         * @returns {Complex}
         */
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.floor(this["re"] * places) / places,
            Math.floor(this["im"] * places) / places
          );
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        "round": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.round(this["re"] * places) / places,
            Math.round(this["im"] * places) / places
          );
        },
        /**
         * Compares two complex numbers
         *
         * **Note:** new Complex(Infinity).equals(Infinity) === false
         *
         * @returns {boolean}
         */
        "equals": function(a2, b) {
          var z = new Complex3(a2, b);
          return Math.abs(z["re"] - this["re"]) <= Complex3["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex3["EPSILON"];
        },
        /**
         * Clones the actual object
         *
         * @returns {Complex}
         */
        "clone": function() {
          return new Complex3(this["re"], this["im"]);
        },
        /**
         * Gets a string of the actual complex number
         *
         * @returns {string}
         */
        "toString": function() {
          var a2 = this["re"];
          var b = this["im"];
          var ret = "";
          if (this["isNaN"]()) {
            return "NaN";
          }
          if (this["isInfinite"]()) {
            return "Infinity";
          }
          if (Math.abs(a2) < Complex3["EPSILON"]) {
            a2 = 0;
          }
          if (Math.abs(b) < Complex3["EPSILON"]) {
            b = 0;
          }
          if (b === 0) {
            return ret + a2;
          }
          if (a2 !== 0) {
            ret += a2;
            ret += " ";
            if (b < 0) {
              b = -b;
              ret += "-";
            } else {
              ret += "+";
            }
            ret += " ";
          } else if (b < 0) {
            b = -b;
            ret += "-";
          }
          if (1 !== b) {
            ret += b;
          }
          return ret + "i";
        },
        /**
         * Returns the actual number as a vector
         *
         * @returns {Array}
         */
        "toVector": function() {
          return [this["re"], this["im"]];
        },
        /**
         * Returns the actual real value of the current object
         *
         * @returns {number|null}
         */
        "valueOf": function() {
          if (this["im"] === 0) {
            return this["re"];
          }
          return null;
        },
        /**
         * Determines whether a complex number is not on the Riemann sphere.
         *
         * @returns {boolean}
         */
        "isNaN": function() {
          return isNaN(this["re"]) || isNaN(this["im"]);
        },
        /**
         * Determines whether or not a complex number is at the zero pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isZero": function() {
          return this["im"] === 0 && this["re"] === 0;
        },
        /**
         * Determines whether a complex number is not at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isFinite": function() {
          return isFinite(this["re"]) && isFinite(this["im"]);
        },
        /**
         * Determines whether or not a complex number is at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isInfinite": function() {
          return !(this["isNaN"]() || this["isFinite"]());
        }
      };
      Complex3["ZERO"] = new Complex3(0, 0);
      Complex3["ONE"] = new Complex3(1, 0);
      Complex3["I"] = new Complex3(0, 1);
      Complex3["PI"] = new Complex3(Math.PI, 0);
      Complex3["E"] = new Complex3(Math.E, 0);
      Complex3["INFINITY"] = new Complex3(Infinity, Infinity);
      Complex3["NAN"] = new Complex3(NaN, NaN);
      Complex3["EPSILON"] = 1e-15;
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Complex3;
        });
      } else if (typeof exports === "object") {
        Object.defineProperty(Complex3, "__esModule", { "value": true });
        Complex3["default"] = Complex3;
        Complex3["Complex"] = Complex3;
        module2["exports"] = Complex3;
      } else {
        root2["Complex"] = Complex3;
      }
    })(exports);
  }
});

// node_modules/fraction.js/fraction.js
var require_fraction = __commonJS({
  "node_modules/fraction.js/fraction.js"(exports, module2) {
    (function(root2) {
      "use strict";
      var MAX_CYCLE_LEN = 2e3;
      var P3 = {
        "s": 1,
        "n": 0,
        "d": 1
      };
      function assign2(n, s2) {
        if (isNaN(n = parseInt(n, 10))) {
          throw InvalidParameter();
        }
        return n * s2;
      }
      function newFraction(n, d) {
        if (d === 0) {
          throw DivisionByZero();
        }
        var f = Object.create(Fraction3.prototype);
        f["s"] = n < 0 ? -1 : 1;
        n = n < 0 ? -n : n;
        var a2 = gcd(n, d);
        f["n"] = n / a2;
        f["d"] = d / a2;
        return f;
      }
      function factorize(num) {
        var factors = {};
        var n = num;
        var i = 2;
        var s2 = 4;
        while (s2 <= n) {
          while (n % i === 0) {
            n /= i;
            factors[i] = (factors[i] || 0) + 1;
          }
          s2 += 1 + 2 * i++;
        }
        if (n !== num) {
          if (n > 1)
            factors[n] = (factors[n] || 0) + 1;
        } else {
          factors[num] = (factors[num] || 0) + 1;
        }
        return factors;
      }
      var parse = function(p1, p2) {
        var n = 0, d = 1, s2 = 1;
        var v = 0, w = 0, x2 = 0, y2 = 1, z = 1;
        var A2 = 0, B2 = 1;
        var C2 = 1, D2 = 1;
        var N = 1e7;
        var M;
        if (p1 === void 0 || p1 === null) {
        } else if (p2 !== void 0) {
          n = p1;
          d = p2;
          s2 = n * d;
          if (n % 1 !== 0 || d % 1 !== 0) {
            throw NonIntegerParameter();
          }
        } else
          switch (typeof p1) {
            case "object": {
              if ("d" in p1 && "n" in p1) {
                n = p1["n"];
                d = p1["d"];
                if ("s" in p1)
                  n *= p1["s"];
              } else if (0 in p1) {
                n = p1[0];
                if (1 in p1)
                  d = p1[1];
              } else {
                throw InvalidParameter();
              }
              s2 = n * d;
              break;
            }
            case "number": {
              if (p1 < 0) {
                s2 = p1;
                p1 = -p1;
              }
              if (p1 % 1 === 0) {
                n = p1;
              } else if (p1 > 0) {
                if (p1 >= 1) {
                  z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                  p1 /= z;
                }
                while (B2 <= N && D2 <= N) {
                  M = (A2 + C2) / (B2 + D2);
                  if (p1 === M) {
                    if (B2 + D2 <= N) {
                      n = A2 + C2;
                      d = B2 + D2;
                    } else if (D2 > B2) {
                      n = C2;
                      d = D2;
                    } else {
                      n = A2;
                      d = B2;
                    }
                    break;
                  } else {
                    if (p1 > M) {
                      A2 += C2;
                      B2 += D2;
                    } else {
                      C2 += A2;
                      D2 += B2;
                    }
                    if (B2 > N) {
                      n = C2;
                      d = D2;
                    } else {
                      n = A2;
                      d = B2;
                    }
                  }
                }
                n *= z;
              } else if (isNaN(p1) || isNaN(p2)) {
                d = n = NaN;
              }
              break;
            }
            case "string": {
              B2 = p1.match(/\d+|./g);
              if (B2 === null)
                throw InvalidParameter();
              if (B2[A2] === "-") {
                s2 = -1;
                A2++;
              } else if (B2[A2] === "+") {
                A2++;
              }
              if (B2.length === A2 + 1) {
                w = assign2(B2[A2++], s2);
              } else if (B2[A2 + 1] === "." || B2[A2] === ".") {
                if (B2[A2] !== ".") {
                  v = assign2(B2[A2++], s2);
                }
                A2++;
                if (A2 + 1 === B2.length || B2[A2 + 1] === "(" && B2[A2 + 3] === ")" || B2[A2 + 1] === "'" && B2[A2 + 3] === "'") {
                  w = assign2(B2[A2], s2);
                  y2 = Math.pow(10, B2[A2].length);
                  A2++;
                }
                if (B2[A2] === "(" && B2[A2 + 2] === ")" || B2[A2] === "'" && B2[A2 + 2] === "'") {
                  x2 = assign2(B2[A2 + 1], s2);
                  z = Math.pow(10, B2[A2 + 1].length) - 1;
                  A2 += 3;
                }
              } else if (B2[A2 + 1] === "/" || B2[A2 + 1] === ":") {
                w = assign2(B2[A2], s2);
                y2 = assign2(B2[A2 + 2], 1);
                A2 += 3;
              } else if (B2[A2 + 3] === "/" && B2[A2 + 1] === " ") {
                v = assign2(B2[A2], s2);
                w = assign2(B2[A2 + 2], s2);
                y2 = assign2(B2[A2 + 4], 1);
                A2 += 5;
              }
              if (B2.length <= A2) {
                d = y2 * z;
                s2 = /* void */
                n = x2 + d * v + z * w;
                break;
              }
            }
            default:
              throw InvalidParameter();
          }
        if (d === 0) {
          throw DivisionByZero();
        }
        P3["s"] = s2 < 0 ? -1 : 1;
        P3["n"] = Math.abs(n);
        P3["d"] = Math.abs(d);
      };
      function modpow(b, e3, m) {
        var r = 1;
        for (; e3 > 0; b = b * b % m, e3 >>= 1) {
          if (e3 & 1) {
            r = r * b % m;
          }
        }
        return r;
      }
      function cycleLen(n, d) {
        for (; d % 2 === 0; d /= 2) {
        }
        for (; d % 5 === 0; d /= 5) {
        }
        if (d === 1)
          return 0;
        var rem = 10 % d;
        var t = 1;
        for (; rem !== 1; t++) {
          rem = rem * 10 % d;
          if (t > MAX_CYCLE_LEN)
            return 0;
        }
        return t;
      }
      function cycleStart(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for (var t = 0; t < 300; t++) {
          if (rem1 === rem2)
            return t;
          rem1 = rem1 * 10 % d;
          rem2 = rem2 * 10 % d;
        }
        return 0;
      }
      function gcd(a2, b) {
        if (!a2)
          return b;
        if (!b)
          return a2;
        while (1) {
          a2 %= b;
          if (!a2)
            return b;
          b %= a2;
          if (!b)
            return a2;
        }
      }
      ;
      function Fraction3(a2, b) {
        parse(a2, b);
        if (this instanceof Fraction3) {
          a2 = gcd(P3["d"], P3["n"]);
          this["s"] = P3["s"];
          this["n"] = P3["n"] / a2;
          this["d"] = P3["d"] / a2;
        } else {
          return newFraction(P3["s"] * P3["n"], P3["d"]);
        }
      }
      var DivisionByZero = function() {
        return new Error("Division by Zero");
      };
      var InvalidParameter = function() {
        return new Error("Invalid argument");
      };
      var NonIntegerParameter = function() {
        return new Error("Parameters must be integer");
      };
      Fraction3.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        /**
         * Calculates the absolute value
         *
         * Ex: new Fraction(-4).abs() => 4
         **/
        "abs": function() {
          return newFraction(this["n"], this["d"]);
        },
        /**
         * Inverts the sign of the current fraction
         *
         * Ex: new Fraction(-4).neg() => 4
         **/
        "neg": function() {
          return newFraction(-this["s"] * this["n"], this["d"]);
        },
        /**
         * Adds two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
         **/
        "add": function(a2, b) {
          parse(a2, b);
          return newFraction(
            this["s"] * this["n"] * P3["d"] + P3["s"] * this["d"] * P3["n"],
            this["d"] * P3["d"]
          );
        },
        /**
         * Subtracts two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
         **/
        "sub": function(a2, b) {
          parse(a2, b);
          return newFraction(
            this["s"] * this["n"] * P3["d"] - P3["s"] * this["d"] * P3["n"],
            this["d"] * P3["d"]
          );
        },
        /**
         * Multiplies two rational numbers
         *
         * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
         **/
        "mul": function(a2, b) {
          parse(a2, b);
          return newFraction(
            this["s"] * P3["s"] * this["n"] * P3["n"],
            this["d"] * P3["d"]
          );
        },
        /**
         * Divides two rational numbers
         *
         * Ex: new Fraction("-17.(345)").inverse().div(3)
         **/
        "div": function(a2, b) {
          parse(a2, b);
          return newFraction(
            this["s"] * P3["s"] * this["n"] * P3["d"],
            this["d"] * P3["n"]
          );
        },
        /**
         * Clones the actual object
         *
         * Ex: new Fraction("-17.(345)").clone()
         **/
        "clone": function() {
          return newFraction(this["s"] * this["n"], this["d"]);
        },
        /**
         * Calculates the modulo of two rational numbers - a more precise fmod
         *
         * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
         **/
        "mod": function(a2, b) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          if (a2 === void 0) {
            return newFraction(this["s"] * this["n"] % this["d"], 1);
          }
          parse(a2, b);
          if (0 === P3["n"] && 0 === this["d"]) {
            throw DivisionByZero();
          }
          return newFraction(
            this["s"] * (P3["d"] * this["n"]) % (P3["n"] * this["d"]),
            P3["d"] * this["d"]
          );
        },
        /**
         * Calculates the fractional gcd of two rational numbers
         *
         * Ex: new Fraction(5,8).gcd(3,7) => 1/56
         */
        "gcd": function(a2, b) {
          parse(a2, b);
          return newFraction(gcd(P3["n"], this["n"]) * gcd(P3["d"], this["d"]), P3["d"] * this["d"]);
        },
        /**
         * Calculates the fractional lcm of two rational numbers
         *
         * Ex: new Fraction(5,8).lcm(3,7) => 15
         */
        "lcm": function(a2, b) {
          parse(a2, b);
          if (P3["n"] === 0 && this["n"] === 0) {
            return newFraction(0, 1);
          }
          return newFraction(P3["n"] * this["n"], gcd(P3["n"], this["n"]) * gcd(P3["d"], this["d"]));
        },
        /**
         * Calculates the ceil of a rational number
         *
         * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
         **/
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Calculates the floor of a rational number
         *
         * Ex: new Fraction('4.(3)').floor() => (4 / 1)
         **/
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Rounds a rational numbers
         *
         * Ex: new Fraction('4.(3)').round() => (4 / 1)
         **/
        "round": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Gets the inverse of the fraction, means numerator and denominator are exchanged
         *
         * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
         **/
        "inverse": function() {
          return newFraction(this["s"] * this["d"], this["n"]);
        },
        /**
         * Calculates the fraction to some rational exponent, if possible
         *
         * Ex: new Fraction(-1,2).pow(-3) => -8
         */
        "pow": function(a2, b) {
          parse(a2, b);
          if (P3["d"] === 1) {
            if (P3["s"] < 0) {
              return newFraction(Math.pow(this["s"] * this["d"], P3["n"]), Math.pow(this["n"], P3["n"]));
            } else {
              return newFraction(Math.pow(this["s"] * this["n"], P3["n"]), Math.pow(this["d"], P3["n"]));
            }
          }
          if (this["s"] < 0)
            return null;
          var N = factorize(this["n"]);
          var D2 = factorize(this["d"]);
          var n = 1;
          var d = 1;
          for (var k2 in N) {
            if (k2 === "1")
              continue;
            if (k2 === "0") {
              n = 0;
              break;
            }
            N[k2] *= P3["n"];
            if (N[k2] % P3["d"] === 0) {
              N[k2] /= P3["d"];
            } else
              return null;
            n *= Math.pow(k2, N[k2]);
          }
          for (var k2 in D2) {
            if (k2 === "1")
              continue;
            D2[k2] *= P3["n"];
            if (D2[k2] % P3["d"] === 0) {
              D2[k2] /= P3["d"];
            } else
              return null;
            d *= Math.pow(k2, D2[k2]);
          }
          if (P3["s"] < 0) {
            return newFraction(d, n);
          }
          return newFraction(n, d);
        },
        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "equals": function(a2, b) {
          parse(a2, b);
          return this["s"] * this["n"] * P3["d"] === P3["s"] * P3["n"] * this["d"];
        },
        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "compare": function(a2, b) {
          parse(a2, b);
          var t = this["s"] * this["n"] * P3["d"] - P3["s"] * P3["n"] * this["d"];
          return (0 < t) - (t < 0);
        },
        "simplify": function(eps) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return this;
          }
          eps = eps || 1e-3;
          var thisABS = this["abs"]();
          var cont = thisABS["toContinued"]();
          for (var i = 1; i < cont.length; i++) {
            var s2 = newFraction(cont[i - 1], 1);
            for (var k2 = i - 2; k2 >= 0; k2--) {
              s2 = s2["inverse"]()["add"](cont[k2]);
            }
            if (Math.abs(s2["sub"](thisABS).valueOf()) < eps) {
              return s2["mul"](this["s"]);
            }
          }
          return this;
        },
        /**
         * Check if two rational numbers are divisible
         *
         * Ex: new Fraction(19.6).divisible(1.5);
         */
        "divisible": function(a2, b) {
          parse(a2, b);
          return !(!(P3["n"] * this["d"]) || this["n"] * P3["d"] % (P3["n"] * this["d"]));
        },
        /**
         * Returns a decimal representation of the fraction
         *
         * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
         **/
        "valueOf": function() {
          return this["s"] * this["n"] / this["d"];
        },
        /**
         * Returns a string-fraction representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
         **/
        "toFraction": function(excludeWhole) {
          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += "-";
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              str += " ";
              n %= d;
            }
            str += n;
            str += "/";
            str += d;
          }
          return str;
        },
        /**
         * Returns a latex representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
         **/
        "toLatex": function(excludeWhole) {
          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += "-";
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              n %= d;
            }
            str += "\\frac{";
            str += n;
            str += "}{";
            str += d;
            str += "}";
          }
          return str;
        },
        /**
         * Returns an array of continued fraction elements
         *
         * Ex: new Fraction("7/8").toContinued() => [0,1,7]
         */
        "toContinued": function() {
          var t;
          var a2 = this["n"];
          var b = this["d"];
          var res = [];
          if (isNaN(a2) || isNaN(b)) {
            return res;
          }
          do {
            res.push(Math.floor(a2 / b));
            t = a2 % b;
            a2 = b;
            b = t;
          } while (a2 !== 1);
          return res;
        },
        /**
         * Creates a string representation of a fraction with all digits
         *
         * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
         **/
        "toString": function(dec) {
          var N = this["n"];
          var D2 = this["d"];
          if (isNaN(N) || isNaN(D2)) {
            return "NaN";
          }
          dec = dec || 15;
          var cycLen = cycleLen(N, D2);
          var cycOff = cycleStart(N, D2, cycLen);
          var str = this["s"] < 0 ? "-" : "";
          str += N / D2 | 0;
          N %= D2;
          N *= 10;
          if (N)
            str += ".";
          if (cycLen) {
            for (var i = cycOff; i--; ) {
              str += N / D2 | 0;
              N %= D2;
              N *= 10;
            }
            str += "(";
            for (var i = cycLen; i--; ) {
              str += N / D2 | 0;
              N %= D2;
              N *= 10;
            }
            str += ")";
          } else {
            for (var i = dec; N && i--; ) {
              str += N / D2 | 0;
              N %= D2;
              N *= 10;
            }
          }
          return str;
        }
      };
      if (typeof exports === "object") {
        Object.defineProperty(Fraction3, "__esModule", { "value": true });
        Fraction3["default"] = Fraction3;
        Fraction3["Fraction"] = Fraction3;
        module2["exports"] = Fraction3;
      } else {
        root2["Fraction"] = Fraction3;
      }
    })(exports);
  }
});

// node_modules/javascript-natural-sort/naturalSort.js
var require_naturalSort = __commonJS({
  "node_modules/javascript-natural-sort/naturalSort.js"(exports, module2) {
    module2.exports = function naturalSort2(a2, b) {
      "use strict";
      var re2 = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i = function(s2) {
        return naturalSort2.insensitive && ("" + s2).toLowerCase() || "" + s2;
      }, x2 = i(a2).replace(sre, "") || "", y2 = i(b).replace(sre, "") || "", xN = x2.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y2.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x2.match(hre), 16) || xN.length !== 1 && x2.match(dre) && Date.parse(x2), yD = parseInt(y2.match(hre), 16) || xD && y2.match(dre) && Date.parse(y2) || null, oFxNcL, oFyNcL;
      if (yD) {
        if (xD < yD) {
          return -1;
        } else if (xD > yD) {
          return 1;
        }
      }
      for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
        oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
        oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
        if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
          return isNaN(oFxNcL) ? 1 : -1;
        } else if (typeof oFxNcL !== typeof oFyNcL) {
          oFxNcL += "";
          oFyNcL += "";
        }
        if (oFxNcL < oFyNcL) {
          return -1;
        }
        if (oFxNcL > oFyNcL) {
          return 1;
        }
      }
      return 0;
    };
  }
});

// node_modules/escape-latex/dist/index.js
var require_dist = __commonJS({
  "node_modules/escape-latex/dist/index.js"(exports, module2) {
    "use strict";
    var _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var defaultEscapes = {
      "{": "\\{",
      "}": "\\}",
      "\\": "\\textbackslash{}",
      "#": "\\#",
      $: "\\$",
      "%": "\\%",
      "&": "\\&",
      "^": "\\textasciicircum{}",
      _: "\\_",
      "~": "\\textasciitilde{}"
    };
    var formatEscapes = {
      "\u2013": "\\--",
      "\u2014": "\\---",
      " ": "~",
      "	": "\\qquad{}",
      "\r\n": "\\newline{}",
      "\n": "\\newline{}"
    };
    var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
      return _extends2({}, defaultEscapes2, formatEscapes2);
    };
    module2.exports = function(str) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
      var runningStr = String(str);
      var result = "";
      var escapes = escapeMapFn(_extends2({}, defaultEscapes), preserveFormatting ? _extends2({}, formatEscapes) : {});
      var escapeKeys = Object.keys(escapes);
      var _loop = function _loop2() {
        var specialCharFound = false;
        escapeKeys.forEach(function(key, index) {
          if (specialCharFound) {
            return;
          }
          if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
            result += escapes[escapeKeys[index]];
            runningStr = runningStr.slice(key.length, runningStr.length);
            specialCharFound = true;
          }
        });
        if (!specialCharFound) {
          result += runningStr.slice(0, 1);
          runningStr = runningStr.slice(1, runningStr.length);
        }
      };
      while (runningStr) {
        _loop();
      }
      return result;
    };
  }
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports, module2) {
    (function(global2, module3, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy3(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy3(state, xg);
          prng.state = function() {
            return copy3(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 64; k2++) {
          me.x ^= strseed.charCodeAt(k2) | 0;
          me.next();
        }
      }
      function copy3(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top2 = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top2 + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy3(state, xg);
          prng.state = function() {
            return copy3(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 64; k2++) {
          me.x ^= strseed.charCodeAt(k2) | 0;
          if (k2 == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy3(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top2 = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top2 + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy3(state, xg);
          prng.state = function() {
            return copy3(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i = me.i, t, v, w;
          t = X[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init2(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8)
            X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j)
            ;
          if (j == 8)
            w = X[7] = -1;
          else
            w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init2(me, seed);
      }
      function copy3(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top2 = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top2 + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy3(state, xg);
          prng.state = function() {
            return copy3(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init2(me2, seed2) {
          var t, v, i, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2)
              v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i = 0 == t ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i;
        }
        init2(me, seed);
      }
      function copy3(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top2 = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top2 + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy3(state, xg);
          prng.state = function() {
            return copy3(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports,
      // window object or global
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c2 = me.c, d = me.d, a2 = me.a;
          b = b << 25 ^ b >>> 7 ^ c2;
          c2 = c2 - d | 0;
          d = d << 24 ^ d >>> 8 ^ a2;
          a2 = a2 - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c2;
          me.c = c2 = c2 - d | 0;
          me.d = d << 16 ^ c2 >>> 16 ^ a2;
          return me.a = a2 - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 20; k2++) {
          me.b ^= strseed.charCodeAt(k2) | 0;
          me.next();
        }
      }
      function copy3(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top2 = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top2 + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy3(state, xg);
          prng.state = function() {
            return copy3(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports, module2) {
    (function(global2, pool, math) {
      var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten2(
          options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x2 = 0;
          while (n < significance) {
            n = (n + x2) * width;
            d *= width;
            x2 = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x2 >>>= 1;
          }
          return (n + x2) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy3(state, arc4);
            }
            prng2.state = function() {
              return copy3(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s2 = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s2[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s2[i] = s2[j = mask & j + key[i % keylen] + (t = s2[i])];
          s2[j] = t;
        }
        (me.g = function(count) {
          var t4, r = 0, i2 = me.i, j2 = me.j, s3 = me.S;
          while (count--) {
            t4 = s3[i2 = mask & i2 + 1];
            r = r * width + s3[mask & (s3[i2] = s3[j2 = mask & j2 + t4]) + (s3[j2] = t4)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy3(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten2(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten2(obj[prop], depth - 1));
            } catch (e3) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e3) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
        }
      }
      function tostring(a2) {
        return String.fromCharCode.apply(0, a2);
      }
      mixkey(math.random(), pool);
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = seedrandom2;
        try {
          nodecrypto = require("crypto");
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : exports,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports, module2) {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module2.exports = sr;
  }
});

// node_modules/tiny-emitter/index.js
var require_tiny_emitter = __commonJS({
  "node_modules/tiny-emitter/index.js"(exports, module2) {
    function E2() {
    }
    E2.prototype = {
      on: function(name310, callback, ctx) {
        var e3 = this.e || (this.e = {});
        (e3[name310] || (e3[name310] = [])).push({
          fn: callback,
          ctx
        });
        return this;
      },
      once: function(name310, callback, ctx) {
        var self2 = this;
        function listener() {
          self2.off(name310, listener);
          callback.apply(ctx, arguments);
        }
        ;
        listener._ = callback;
        return this.on(name310, listener, ctx);
      },
      emit: function(name310) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name310] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function(name310, callback) {
        var e3 = this.e || (this.e = {});
        var evts = e3[name310];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback)
              liveEvents.push(evts[i]);
          }
        }
        liveEvents.length ? e3[name310] = liveEvents : delete e3[name310];
        return this;
      }
    };
    module2.exports = E2;
    module2.exports.TinyEmitter = E2;
  }
});

// node_modules/function-plot/dist/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/function-plot/dist/polyfills.js"() {
    if (typeof window !== "undefined")
      (function(doc, proto) {
        try {
          doc.querySelector(":scope body");
        } catch (err) {
          ["querySelector", "querySelectorAll"].forEach(function(method) {
            const native = proto[method];
            proto[method] = function(selectors) {
              if (/(^|,)\s*:scope/.test(selectors)) {
                const id2 = this.id;
                this.id = "ID_" + Date.now();
                selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id);
                const result = doc[method](selectors);
                this.id = id2;
                return result;
              } else {
                return native.call(this, selectors);
              }
            };
          });
        }
      })(window.document, Element.prototype);
  }
});

// node_modules/d3-shape/src/constant.js
function constant_default(x2) {
  return function constant() {
    return x2;
  };
}
var init_constant = __esm({
  "node_modules/d3-shape/src/constant.js"() {
  }
});

// node_modules/d3-shape/src/math.js
function acos2(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi2 : Math.acos(x2);
}
function asin2(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}
var abs2, atan22, cos2, max2, min2, sin2, sqrt2, epsilon, pi2, halfPi, tau2;
var init_math = __esm({
  "node_modules/d3-shape/src/math.js"() {
    abs2 = Math.abs;
    atan22 = Math.atan2;
    cos2 = Math.cos;
    max2 = Math.max;
    min2 = Math.min;
    sin2 = Math.sin;
    sqrt2 = Math.sqrt;
    epsilon = 1e-12;
    pi2 = Math.PI;
    halfPi = pi2 / 2;
    tau2 = 2 * pi2;
  }
});

// node_modules/d3-path/src/path.js
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits2) {
  let d = Math.floor(digits2);
  if (!(d >= 0))
    throw new Error(`invalid digits: ${digits2}`);
  if (d > 15)
    return append;
  const k2 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
function path() {
  return new Path();
}
var pi3, tau3, epsilon2, tauEpsilon, Path;
var init_path = __esm({
  "node_modules/d3-path/src/path.js"() {
    pi3 = Math.PI;
    tau3 = 2 * pi3;
    epsilon2 = 1e-6;
    tauEpsilon = tau3 - epsilon2;
    Path = class {
      constructor(digits2) {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null;
        this._ = "";
        this._append = digits2 == null ? append : appendRound(digits2);
      }
      moveTo(x2, y2) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x2, y2) {
        this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
      }
      quadraticCurveTo(x1, y1, x2, y2) {
        this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
      }
      bezierCurveTo(x1, y1, x2, y2, x3, y3) {
        this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
      }
      arcTo(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        if (r < 0)
          throw new Error(`negative radius: ${r}`);
        let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
        if (this._x1 === null) {
          this._append`M${this._x1 = x1},${this._y1 = y1}`;
        } else if (!(l01_2 > epsilon2))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
          this._append`L${this._x1 = x1},${this._y1 = y1}`;
        } else {
          let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon2) {
            this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
          }
          this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
        }
      }
      arc(x2, y2, r, a0, a1, ccw) {
        x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
        if (r < 0)
          throw new Error(`negative radius: ${r}`);
        let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (this._x1 === null) {
          this._append`M${x0},${y0}`;
        } else if (Math.abs(this._x1 - x0) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) {
          this._append`L${x0},${y0}`;
        }
        if (!r)
          return;
        if (da < 0)
          da = da % tau3 + tau3;
        if (da > tauEpsilon) {
          this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
        } else if (da > epsilon2) {
          this._append`A${r},${r},0,${+(da >= pi3)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
        }
      }
      rect(x2, y2, w, h) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
      }
      toString() {
        return this._;
      }
    };
    path.prototype = Path.prototype;
  }
});

// node_modules/d3-path/src/index.js
var init_src = __esm({
  "node_modules/d3-path/src/index.js"() {
    init_path();
  }
});

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits2 = 3;
  shape.digits = function(_) {
    if (!arguments.length)
      return digits2;
    if (_ == null) {
      digits2 = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_}`);
      digits2 = d;
    }
    return shape;
  };
  return () => new Path(digits2);
}
var init_path2 = __esm({
  "node_modules/d3-shape/src/path.js"() {
    init_src();
  }
});

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon)
    return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt2(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt2(max2(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs2(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer = path2();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon))
      context.moveTo(0, 0);
    else if (da > tau2 - epsilon) {
      context.moveTo(r1 * cos2(a0), r1 * sin2(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos2(a1), r0 * sin2(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt2(r0 * r0 + r1 * r1)), rc = min2(abs2(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;
      if (rp > epsilon) {
        var p0 = asin2(rp / r0 * sin2(ap)), p1 = asin2(rp / r1 * sin2(ap));
        if ((da0 -= p0 * 2) > epsilon)
          p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos2(a01), y01 = r1 * sin2(a01), x10 = r0 * cos2(a10), y10 = r0 * sin2(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos2(a11), y11 = r1 * sin2(a11), x00 = r0 * cos2(a00), y00 = r0 * sin2(a00), oc;
        if (da < pi2) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin2(acos2((ax * bx + ay * by) / (sqrt2(ax * ax + ay * ay) * sqrt2(bx * bx + by * by))) / 2), lc = sqrt2(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min2(rc, (r0 - lc) / (kc - 1));
            rc1 = min2(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t03 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc1 < rc)
          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r1, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
          context.arc(t13.cx, t13.cy, rc1, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon) || !(da0 > epsilon))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t13 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc0 < rc)
          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r0, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), cw);
          context.arc(t13.cx, t13.cy, rc0, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi2 / 2;
    return [cos2(a2) * r, sin2(a2) * r];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}
var init_arc = __esm({
  "node_modules/d3-shape/src/arc.js"() {
    init_constant();
    init_math();
    init_path2();
  }
});

// node_modules/d3-shape/src/array.js
function array_default(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
var slice;
var init_array = __esm({
  "node_modules/d3-shape/src/array.js"() {
    slice = Array.prototype.slice;
  }
});

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
function linear_default(context) {
  return new Linear(context);
}
var init_linear = __esm({
  "node_modules/d3-shape/src/curve/linear.js"() {
    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x2, y2);
            break;
        }
      }
    };
  }
});

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
var init_point = __esm({
  "node_modules/d3-shape/src/point.js"() {
  }
});

// node_modules/d3-shape/src/line.js
function line_default(x2, y2) {
  var defined = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line);
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default(y2);
  function line(data) {
    var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default(+_), line) : x2;
  };
  line.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default(+_), line) : y2;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}
var init_line = __esm({
  "node_modules/d3-shape/src/line.js"() {
    init_array();
    init_constant();
    init_linear();
    init_path2();
    init_point();
  }
});

// node_modules/d3-shape/src/area.js
function area_default(x0, y0, y1) {
  var x1 = null, defined = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default(0) : constant_default(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default(+y1);
  function area(data) {
    var i, j, k2, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default(+_), x1 = null, area) : x0;
  };
  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default(+_), area) : x0;
  };
  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area) : x1;
  };
  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default(+_), y1 = null, area) : y0;
  };
  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default(+_), area) : y0;
  };
  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default(!!_), area) : defined;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}
var init_area = __esm({
  "node_modules/d3-shape/src/area.js"() {
    init_array();
    init_constant();
    init_linear();
    init_line();
    init_path2();
    init_point();
  }
});

// node_modules/d3-shape/src/descending.js
function descending_default(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
var init_descending = __esm({
  "node_modules/d3-shape/src/descending.js"() {
  }
});

// node_modules/d3-shape/src/identity.js
function identity_default(d) {
  return d;
}
var init_identity = __esm({
  "node_modules/d3-shape/src/identity.js"() {
  }
});

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value = identity_default, sortValues = descending_default, sort = null, startAngle = constant_default(0), endAngle = constant_default(tau2), padAngle = constant_default(0);
  function pie(data) {
    var i, n = (data = array_default(data)).length, j, k2, sum3 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau2, Math.max(-tau2, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum3 += v;
      }
    }
    if (sortValues != null)
      index.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
    else if (sort != null)
      index.sort(function(i2, j2) {
        return sort(data[i2], data[j2]);
      });
    for (i = 0, k2 = sum3 ? (da - n * pa) / sum3 : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default(+_), pie) : value;
  };
  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };
  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };
  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : startAngle;
  };
  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : endAngle;
  };
  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : padAngle;
  };
  return pie;
}
var init_pie = __esm({
  "node_modules/d3-shape/src/pie.js"() {
    init_array();
    init_constant();
    init_descending();
    init_identity();
    init_math();
  }
});

// node_modules/d3-shape/src/curve/radial.js
function Radial(curve) {
  this._curve = curve;
}
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}
var curveRadialLinear;
var init_radial = __esm({
  "node_modules/d3-shape/src/curve/radial.js"() {
    init_linear();
    curveRadialLinear = curveRadial(linear_default);
    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a2, r) {
        this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
      }
    };
  }
});

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c2 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_) {
    return arguments.length ? c2(curveRadial(_)) : c2()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}
var init_lineRadial = __esm({
  "node_modules/d3-shape/src/lineRadial.js"() {
    init_radial();
    init_line();
  }
});

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a2 = area_default().curve(curveRadialLinear), c2 = a2.curve, x0 = a2.lineX0, x1 = a2.lineX1, y0 = a2.lineY0, y1 = a2.lineY1;
  a2.angle = a2.x, delete a2.x;
  a2.startAngle = a2.x0, delete a2.x0;
  a2.endAngle = a2.x1, delete a2.x1;
  a2.radius = a2.y, delete a2.y;
  a2.innerRadius = a2.y0, delete a2.y0;
  a2.outerRadius = a2.y1, delete a2.y1;
  a2.lineStartAngle = function() {
    return lineRadial(x0());
  }, delete a2.lineX0;
  a2.lineEndAngle = function() {
    return lineRadial(x1());
  }, delete a2.lineX1;
  a2.lineInnerRadius = function() {
    return lineRadial(y0());
  }, delete a2.lineY0;
  a2.lineOuterRadius = function() {
    return lineRadial(y1());
  }, delete a2.lineY1;
  a2.curve = function(_) {
    return arguments.length ? c2(curveRadial(_)) : c2()._curve;
  };
  return a2;
}
var init_areaRadial = __esm({
  "node_modules/d3-shape/src/areaRadial.js"() {
    init_radial();
    init_area();
    init_lineRadial();
  }
});

// node_modules/d3-shape/src/pointRadial.js
function pointRadial_default(x2, y2) {
  return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
}
var init_pointRadial = __esm({
  "node_modules/d3-shape/src/pointRadial.js"() {
  }
});

// node_modules/d3-shape/src/curve/bump.js
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}
function bumpRadial(context) {
  return new BumpRadial(context);
}
var Bump, BumpRadial;
var init_bump = __esm({
  "node_modules/d3-shape/src/curve/bump.js"() {
    init_pointRadial();
    Bump = class {
      constructor(context, x2) {
        this._context = context;
        this._x = x2;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line)
              this._context.lineTo(x2, y2);
            else
              this._context.moveTo(x2, y2);
            break;
          }
          case 1:
            this._point = 2;
          default: {
            if (this._x)
              this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
            else
              this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
            break;
          }
        }
        this._x0 = x2, this._y0 = y2;
      }
    };
    BumpRadial = class {
      constructor(context) {
        this._context = context;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
      }
      point(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point === 0) {
          this._point = 1;
        } else {
          const p0 = pointRadial_default(this._x0, this._y0);
          const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y2) / 2);
          const p2 = pointRadial_default(x2, this._y0);
          const p3 = pointRadial_default(x2, y2);
          this._context.moveTo(...p0);
          this._context.bezierCurveTo(...p1, ...p2, ...p3);
        }
        this._x0 = x2, this._y0 = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/link.js
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  let source = linkSource, target = linkTarget, x2 = x, y2 = y, context = null, output = null, path2 = withPath(link2);
  function link2() {
    let buffer;
    const argv = slice.call(arguments);
    const s2 = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null)
      output = curve(buffer = path2());
    output.lineStart();
    argv[0] = s2, output.point(+x2.apply(this, argv), +y2.apply(this, argv));
    argv[0] = t, output.point(+x2.apply(this, argv), +y2.apply(this, argv));
    output.lineEnd();
    if (buffer)
      return output = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default(+_), link2) : x2;
  };
  link2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default(+_), link2) : y2;
  };
  link2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link2) : context;
  };
  return link2;
}
function linkHorizontal() {
  return link(bumpX);
}
function linkVertical() {
  return link(bumpY);
}
function linkRadial() {
  const l = link(bumpRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}
var init_link = __esm({
  "node_modules/d3-shape/src/link.js"() {
    init_array();
    init_constant();
    init_bump();
    init_path2();
    init_point();
  }
});

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3, asterisk_default;
var init_asterisk = __esm({
  "node_modules/d3-shape/src/symbol/asterisk.js"() {
    init_math();
    sqrt3 = sqrt2(3);
    asterisk_default = {
      draw(context, size) {
        const r = sqrt2(size + min2(size / 28, 0.75)) * 0.59436;
        const t = r / 2;
        const u = t * sqrt3;
        context.moveTo(0, r);
        context.lineTo(0, -r);
        context.moveTo(-u, -t);
        context.lineTo(u, t);
        context.moveTo(-u, t);
        context.lineTo(u, -t);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/circle.js
var circle_default;
var init_circle = __esm({
  "node_modules/d3-shape/src/symbol/circle.js"() {
    init_math();
    circle_default = {
      draw(context, size) {
        const r = sqrt2(size / pi2);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau2);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/cross.js
var cross_default;
var init_cross = __esm({
  "node_modules/d3-shape/src/symbol/cross.js"() {
    init_math();
    cross_default = {
      draw(context, size) {
        const r = sqrt2(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/diamond.js
var tan30, tan30_2, diamond_default;
var init_diamond = __esm({
  "node_modules/d3-shape/src/symbol/diamond.js"() {
    init_math();
    tan30 = sqrt2(1 / 3);
    tan30_2 = tan30 * 2;
    diamond_default = {
      draw(context, size) {
        const y2 = sqrt2(size / tan30_2);
        const x2 = y2 * tan30;
        context.moveTo(0, -y2);
        context.lineTo(x2, 0);
        context.lineTo(0, y2);
        context.lineTo(-x2, 0);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default;
var init_diamond2 = __esm({
  "node_modules/d3-shape/src/symbol/diamond2.js"() {
    init_math();
    diamond2_default = {
      draw(context, size) {
        const r = sqrt2(size) * 0.62625;
        context.moveTo(0, -r);
        context.lineTo(r, 0);
        context.lineTo(0, r);
        context.lineTo(-r, 0);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/plus.js
var plus_default;
var init_plus = __esm({
  "node_modules/d3-shape/src/symbol/plus.js"() {
    init_math();
    plus_default = {
      draw(context, size) {
        const r = sqrt2(size - min2(size / 7, 2)) * 0.87559;
        context.moveTo(-r, 0);
        context.lineTo(r, 0);
        context.moveTo(0, r);
        context.lineTo(0, -r);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/square.js
var square_default;
var init_square = __esm({
  "node_modules/d3-shape/src/symbol/square.js"() {
    init_math();
    square_default = {
      draw(context, size) {
        const w = sqrt2(size);
        const x2 = -w / 2;
        context.rect(x2, x2, w, w);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/square2.js
var square2_default;
var init_square2 = __esm({
  "node_modules/d3-shape/src/symbol/square2.js"() {
    init_math();
    square2_default = {
      draw(context, size) {
        const r = sqrt2(size) * 0.4431;
        context.moveTo(r, r);
        context.lineTo(r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, r);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/star.js
var ka, kr, kx, ky, star_default;
var init_star = __esm({
  "node_modules/d3-shape/src/symbol/star.js"() {
    init_math();
    ka = 0.8908130915292852;
    kr = sin2(pi2 / 10) / sin2(7 * pi2 / 10);
    kx = sin2(tau2 / 10) * kr;
    ky = -cos2(tau2 / 10) * kr;
    star_default = {
      draw(context, size) {
        const r = sqrt2(size * ka);
        const x2 = kx * r;
        const y2 = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x2, y2);
        for (let i = 1; i < 5; ++i) {
          const a2 = tau2 * i / 5;
          const c2 = cos2(a2);
          const s2 = sin2(a2);
          context.lineTo(s2 * r, -c2 * r);
          context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
        }
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32, triangle_default;
var init_triangle = __esm({
  "node_modules/d3-shape/src/symbol/triangle.js"() {
    init_math();
    sqrt32 = sqrt2(3);
    triangle_default = {
      draw(context, size) {
        const y2 = -sqrt2(size / (sqrt32 * 3));
        context.moveTo(0, y2 * 2);
        context.lineTo(-sqrt32 * y2, -y2);
        context.lineTo(sqrt32 * y2, -y2);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33, triangle2_default;
var init_triangle2 = __esm({
  "node_modules/d3-shape/src/symbol/triangle2.js"() {
    init_math();
    sqrt33 = sqrt2(3);
    triangle2_default = {
      draw(context, size) {
        const s2 = sqrt2(size) * 0.6824;
        const t = s2 / 2;
        const u = s2 * sqrt33 / 2;
        context.moveTo(0, -s2);
        context.lineTo(u, t);
        context.lineTo(-u, t);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/wye.js
var c, s, k, a, wye_default;
var init_wye = __esm({
  "node_modules/d3-shape/src/symbol/wye.js"() {
    init_math();
    c = -0.5;
    s = sqrt2(3) / 2;
    k = 1 / sqrt2(12);
    a = (k / 2 + 1) * 3;
    wye_default = {
      draw(context, size) {
        const r = sqrt2(size / a);
        const x0 = r / 2, y0 = r * k;
        const x1 = x0, y1 = r * k + r;
        const x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/times.js
var times_default;
var init_times = __esm({
  "node_modules/d3-shape/src/symbol/times.js"() {
    init_math();
    times_default = {
      draw(context, size) {
        const r = sqrt2(size - min2(size / 6, 1.7)) * 0.6189;
        context.moveTo(-r, -r);
        context.lineTo(r, r);
        context.moveTo(-r, r);
        context.lineTo(r, -r);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol.js
function Symbol2(type, size) {
  let context = null, path2 = withPath(symbol);
  type = typeof type === "function" ? type : constant_default(type || circle_default);
  size = typeof size === "function" ? size : constant_default(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context)
      context = buffer = path2();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant_default(_), symbol) : type;
  };
  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default(+_), symbol) : size;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}
var symbolsFill, symbolsStroke;
var init_symbol = __esm({
  "node_modules/d3-shape/src/symbol.js"() {
    init_constant();
    init_path2();
    init_asterisk();
    init_circle();
    init_cross();
    init_diamond();
    init_diamond2();
    init_plus();
    init_square();
    init_square2();
    init_star();
    init_triangle();
    init_triangle2();
    init_wye();
    init_times();
    symbolsFill = [
      circle_default,
      cross_default,
      diamond_default,
      square_default,
      star_default,
      triangle_default,
      wye_default
    ];
    symbolsStroke = [
      circle_default,
      plus_default,
      times_default,
      triangle2_default,
      asterisk_default,
      square2_default,
      diamond2_default
    ];
  }
});

// node_modules/d3-shape/src/noop.js
function noop_default() {
}
var init_noop = __esm({
  "node_modules/d3-shape/src/noop.js"() {
  }
});

// node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
function basis_default(context) {
  return new Basis(context);
}
var init_basis = __esm({
  "node_modules/d3-shape/src/curve/basis.js"() {
    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
function basisClosed_default(context) {
  return new BasisClosed(context);
}
var init_basisClosed = __esm({
  "node_modules/d3-shape/src/curve/basisClosed.js"() {
    init_noop();
    init_basis();
    BasisClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x2, this._y2 = y2;
            break;
          case 1:
            this._point = 2;
            this._x3 = x2, this._y3 = y2;
            break;
          case 2:
            this._point = 3;
            this._x4 = x2, this._y4 = y2;
            this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
            break;
          default:
            point(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
function basisOpen_default(context) {
  return new BasisOpen(context);
}
var init_basisOpen = __esm({
  "node_modules/d3-shape/src/curve/basisOpen.js"() {
    init_basis();
    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
            this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
            break;
          case 3:
            this._point = 4;
          default:
            point(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
var bundle_default;
var init_bundle = __esm({
  "node_modules/d3-shape/src/curve/bundle.js"() {
    init_basis();
    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x2 = this._x, y2 = this._y, j = x2.length - 1;
        if (j > 0) {
          var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x2, y2) {
        this._x.push(+x2);
        this._y.push(+y2);
      }
    };
    bundle_default = function custom(beta) {
      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }
      bundle.beta = function(beta2) {
        return custom(+beta2);
      };
      return bundle;
    }(0.85);
  }
});

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinal_default;
var init_cardinal = __esm({
  "node_modules/d3-shape/src/curve/cardinal.js"() {
    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            point2(this, this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            this._x1 = x2, this._y1 = y2;
            break;
          case 2:
            this._point = 3;
          default:
            point2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    cardinal_default = function custom2(tension) {
      function cardinal(context) {
        return new Cardinal(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom2(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinalClosed_default;
var init_cardinalClosed = __esm({
  "node_modules/d3-shape/src/curve/cardinalClosed.js"() {
    init_noop();
    init_cardinal();
    CardinalClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x2, this._y3 = y2;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x2, this._y4 = y2);
            break;
          case 2:
            this._point = 3;
            this._x5 = x2, this._y5 = y2;
            break;
          default:
            point2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    cardinalClosed_default = function custom3(tension) {
      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom3(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinalOpen_default;
var init_cardinalOpen = __esm({
  "node_modules/d3-shape/src/curve/cardinalOpen.js"() {
    init_cardinal();
    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    cardinalOpen_default = function custom4(tension) {
      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom4(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRom_default;
var init_catmullRom = __esm({
  "node_modules/d3-shape/src/curve/catmullRom.js"() {
    init_math();
    init_cardinal();
    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            this.point(this._x2, this._y2);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point3(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    catmullRom_default = function custom5(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom5(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRomClosed_default;
var init_catmullRomClosed = __esm({
  "node_modules/d3-shape/src/curve/catmullRomClosed.js"() {
    init_cardinalClosed();
    init_noop();
    init_catmullRom();
    CatmullRomClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x2, this._y3 = y2;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x2, this._y4 = y2);
            break;
          case 2:
            this._point = 3;
            this._x5 = x2, this._y5 = y2;
            break;
          default:
            point3(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    catmullRomClosed_default = function custom6(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom6(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRomOpen_default;
var init_catmullRomOpen = __esm({
  "node_modules/d3-shape/src/curve/catmullRomOpen.js"() {
    init_cardinalOpen();
    init_catmullRom();
    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point3(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    catmullRomOpen_default = function custom7(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom7(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
function linearClosed_default(context) {
  return new LinearClosed(context);
}
var init_linearClosed = __esm({
  "node_modules/d3-shape/src/curve/linearClosed.js"() {
    init_noop();
    LinearClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point)
          this._context.closePath();
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point)
          this._context.lineTo(x2, y2);
        else
          this._point = 1, this._context.moveTo(x2, y2);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/monotone.js
function sign3(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign3(s0) + sign3(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t03, t13) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t03, x1 - dx, y1 - dx * t13, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
function ReflectContext(context) {
  this._context = context;
}
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
var init_monotone = __esm({
  "node_modules/d3-shape/src/curve/monotone.js"() {
    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point4(this, this._t0, slope2(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        var t13 = NaN;
        x2 = +x2, y2 = +y2;
        if (x2 === this._x1 && y2 === this._y1)
          return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point4(this, slope2(this, t13 = slope3(this, x2, y2)), t13);
            break;
          default:
            point4(this, this._t0, t13 = slope3(this, x2, y2));
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
        this._t0 = t13;
      }
    };
    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
      MonotoneX.prototype.point.call(this, y2, x2);
    };
    ReflectContext.prototype = {
      moveTo: function(x2, y2) {
        this._context.moveTo(y2, x2);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x2, y2) {
        this._context.lineTo(y2, x2);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
        this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function natural_default(context) {
  return new Natural(context);
}
var init_natural = __esm({
  "node_modules/d3-shape/src/curve/natural.js"() {
    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x2 = this._x, y2 = this._y, n = x2.length;
        if (n) {
          this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
          if (n === 2) {
            this._context.lineTo(x2[1], y2[1]);
          } else {
            var px = controlPoints(x2), py = controlPoints(y2);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n === 1)
          this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x2, y2) {
        this._x.push(+x2);
        this._y.push(+y2);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
var init_step = __esm({
  "node_modules/d3-shape/src/curve/step.js"() {
    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2)
          this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        if (this._line >= 0)
          this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y2);
              this._context.lineTo(x2, y2);
            } else {
              var x1 = this._x * (1 - this._t) + x2 * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y2);
            }
            break;
          }
        }
        this._x = x2, this._y = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n = series.length) > 1))
    return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
var init_none = __esm({
  "node_modules/d3-shape/src/offset/none.js"() {
  }
});

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}
var init_none2 = __esm({
  "node_modules/d3-shape/src/order/none.js"() {
  }
});

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack_default() {
  var keys = constant_default([]), order = none_default2, offset = none_default, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array_default(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default(Array.from(_)), stack) : keys;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
  };
  return stack;
}
var init_stack = __esm({
  "node_modules/d3-shape/src/stack.js"() {
    init_array();
    init_constant();
    init_none();
    init_none2();
  }
});

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
  if (!((n = series.length) > 0))
    return;
  for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
    for (y2 = i = 0; i < n; ++i)
      y2 += series[i][j][1] || 0;
    if (y2)
      for (i = 0; i < n; ++i)
        series[i][j][1] /= y2;
  }
  none_default(series, order);
}
var init_expand = __esm({
  "node_modules/d3-shape/src/offset/expand.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order) {
  if (!((n = series.length) > 0))
    return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}
var init_diverging = __esm({
  "node_modules/d3-shape/src/offset/diverging.js"() {
  }
});

// node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order) {
  if (!((n = series.length) > 0))
    return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y2 = 0; i < n; ++i)
      y2 += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y2 / 2;
  }
  none_default(series, order);
}
var init_silhouette = __esm({
  "node_modules/d3-shape/src/offset/silhouette.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0))
    return;
  for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    if (s1)
      y2 -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y2;
  none_default(series, order);
}
var init_wiggle = __esm({
  "node_modules/d3-shape/src/offset/wiggle.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/order/appearance.js
function appearance_default(series) {
  var peaks = series.map(peak);
  return none_default2(series).sort(function(a2, b) {
    return peaks[a2] - peaks[b];
  });
}
function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n)
    if ((vi = +series[i][1]) > vj)
      vj = vi, j = i;
  return j;
}
var init_appearance = __esm({
  "node_modules/d3-shape/src/order/appearance.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/order/ascending.js
function ascending_default(series) {
  var sums = series.map(sum2);
  return none_default2(series).sort(function(a2, b) {
    return sums[a2] - sums[b];
  });
}
function sum2(series) {
  var s2 = 0, i = -1, n = series.length, v;
  while (++i < n)
    if (v = +series[i][1])
      s2 += v;
  return s2;
}
var init_ascending = __esm({
  "node_modules/d3-shape/src/order/ascending.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/order/descending.js
function descending_default2(series) {
  return ascending_default(series).reverse();
}
var init_descending2 = __esm({
  "node_modules/d3-shape/src/order/descending.js"() {
    init_ascending();
  }
});

// node_modules/d3-shape/src/order/insideOut.js
function insideOut_default(series) {
  var n = series.length, i, j, sums = series.map(sum2), order = appearance_default(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top2 < bottom2) {
      top2 += sums[j];
      tops.push(j);
    } else {
      bottom2 += sums[j];
      bottoms.push(j);
    }
  }
  return bottoms.reverse().concat(tops);
}
var init_insideOut = __esm({
  "node_modules/d3-shape/src/order/insideOut.js"() {
    init_appearance();
    init_ascending();
  }
});

// node_modules/d3-shape/src/order/reverse.js
function reverse_default(series) {
  return none_default2(series).reverse();
}
var init_reverse = __esm({
  "node_modules/d3-shape/src/order/reverse.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/index.js
var src_exports = {};
__export(src_exports, {
  arc: () => arc_default,
  area: () => area_default,
  areaRadial: () => areaRadial_default,
  curveBasis: () => basis_default,
  curveBasisClosed: () => basisClosed_default,
  curveBasisOpen: () => basisOpen_default,
  curveBumpX: () => bumpX,
  curveBumpY: () => bumpY,
  curveBundle: () => bundle_default,
  curveCardinal: () => cardinal_default,
  curveCardinalClosed: () => cardinalClosed_default,
  curveCardinalOpen: () => cardinalOpen_default,
  curveCatmullRom: () => catmullRom_default,
  curveCatmullRomClosed: () => catmullRomClosed_default,
  curveCatmullRomOpen: () => catmullRomOpen_default,
  curveLinear: () => linear_default,
  curveLinearClosed: () => linearClosed_default,
  curveMonotoneX: () => monotoneX,
  curveMonotoneY: () => monotoneY,
  curveNatural: () => natural_default,
  curveStep: () => step_default,
  curveStepAfter: () => stepAfter,
  curveStepBefore: () => stepBefore,
  line: () => line_default,
  lineRadial: () => lineRadial_default,
  link: () => link,
  linkHorizontal: () => linkHorizontal,
  linkRadial: () => linkRadial,
  linkVertical: () => linkVertical,
  pie: () => pie_default,
  pointRadial: () => pointRadial_default,
  radialArea: () => areaRadial_default,
  radialLine: () => lineRadial_default,
  stack: () => stack_default,
  stackOffsetDiverging: () => diverging_default,
  stackOffsetExpand: () => expand_default,
  stackOffsetNone: () => none_default,
  stackOffsetSilhouette: () => silhouette_default,
  stackOffsetWiggle: () => wiggle_default,
  stackOrderAppearance: () => appearance_default,
  stackOrderAscending: () => ascending_default,
  stackOrderDescending: () => descending_default2,
  stackOrderInsideOut: () => insideOut_default,
  stackOrderNone: () => none_default2,
  stackOrderReverse: () => reverse_default,
  symbol: () => Symbol2,
  symbolAsterisk: () => asterisk_default,
  symbolCircle: () => circle_default,
  symbolCross: () => cross_default,
  symbolDiamond: () => diamond_default,
  symbolDiamond2: () => diamond2_default,
  symbolPlus: () => plus_default,
  symbolSquare: () => square_default,
  symbolSquare2: () => square2_default,
  symbolStar: () => star_default,
  symbolTimes: () => times_default,
  symbolTriangle: () => triangle_default,
  symbolTriangle2: () => triangle2_default,
  symbolWye: () => wye_default,
  symbolX: () => times_default,
  symbols: () => symbolsFill,
  symbolsFill: () => symbolsFill,
  symbolsStroke: () => symbolsStroke
});
var init_src2 = __esm({
  "node_modules/d3-shape/src/index.js"() {
    init_arc();
    init_area();
    init_line();
    init_pie();
    init_areaRadial();
    init_lineRadial();
    init_pointRadial();
    init_link();
    init_symbol();
    init_asterisk();
    init_circle();
    init_cross();
    init_diamond();
    init_diamond2();
    init_plus();
    init_square();
    init_square2();
    init_star();
    init_triangle();
    init_triangle2();
    init_wye();
    init_times();
    init_basisClosed();
    init_basisOpen();
    init_basis();
    init_bump();
    init_bundle();
    init_cardinalClosed();
    init_cardinalOpen();
    init_cardinal();
    init_catmullRomClosed();
    init_catmullRomOpen();
    init_catmullRom();
    init_linearClosed();
    init_linear();
    init_monotone();
    init_natural();
    init_step();
    init_stack();
    init_expand();
    init_diverging();
    init_none();
    init_silhouette();
    init_wiggle();
    init_appearance();
    init_ascending();
    init_descending2();
    init_insideOut();
    init_none2();
    init_reverse();
  }
});

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
var init_formatDecimal = __esm({
  "node_modules/d3-format/src/formatDecimal.js"() {
  }
});

// node_modules/d3-format/src/exponent.js
function exponent_default(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
var init_exponent = __esm({
  "node_modules/d3-format/src/exponent.js"() {
    init_formatDecimal();
  }
});

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
var init_formatGroup = __esm({
  "node_modules/d3-format/src/formatGroup.js"() {
  }
});

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var init_formatNumerals = __esm({
  "node_modules/d3-format/src/formatNumerals.js"() {
  }
});

// node_modules/d3-format/src/formatSpecifier.js
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
var re;
var init_formatSpecifier = __esm({
  "node_modules/d3-format/src/formatSpecifier.js"() {
    re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    formatSpecifier.prototype = FormatSpecifier.prototype;
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
  }
});

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var init_formatTrim = __esm({
  "node_modules/d3-format/src/formatTrim.js"() {
  }
});

// node_modules/d3-format/src/formatPrefixAuto.js
function formatPrefixAuto_default(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}
var prefixExponent;
var init_formatPrefixAuto = __esm({
  "node_modules/d3-format/src/formatPrefixAuto.js"() {
    init_formatDecimal();
  }
});

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var init_formatRounded = __esm({
  "node_modules/d3-format/src/formatRounded.js"() {
    init_formatDecimal();
  }
});

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default;
var init_formatTypes = __esm({
  "node_modules/d3-format/src/formatTypes.js"() {
    init_formatDecimal();
    init_formatPrefixAuto();
    init_formatRounded();
    formatTypes_default = {
      "%": (x2, p) => (x2 * 100).toFixed(p),
      "b": (x2) => Math.round(x2).toString(2),
      "c": (x2) => x2 + "",
      "d": formatDecimal_default,
      "e": (x2, p) => x2.toExponential(p),
      "f": (x2, p) => x2.toFixed(p),
      "g": (x2, p) => x2.toPrecision(p),
      "o": (x2) => Math.round(x2).toString(8),
      "p": (x2, p) => formatRounded_default(x2 * 100, p),
      "r": formatRounded_default,
      "s": formatPrefixAuto_default,
      "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
      "x": (x2) => Math.round(x2).toString(16)
    };
  }
});

// node_modules/d3-format/src/identity.js
function identity_default2(x2) {
  return x2;
}
var init_identity2 = __esm({
  "node_modules/d3-format/src/identity.js"() {
  }
});

// node_modules/d3-format/src/locale.js
function locale_default(locale3) {
  var group = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map2.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map2.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign4 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes_default[type])
      precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero3 || fill === "0" && align === "=")
      zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format6(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign4 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign4 === "(" ? sign4 : minus : sign4 === "-" || sign4 === "(" ? "" : sign4) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign4 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero3)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format6.toString = function() {
      return specifier + "";
    };
    return format6;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value2) {
      return f(k2 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var map2, prefixes;
var init_locale = __esm({
  "node_modules/d3-format/src/locale.js"() {
    init_exponent();
    init_formatGroup();
    init_formatNumerals();
    init_formatSpecifier();
    init_formatTrim();
    init_formatTypes();
    init_formatPrefixAuto();
    init_identity2();
    map2 = Array.prototype.map;
    prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  }
});

// node_modules/d3-format/src/defaultLocale.js
function defaultLocale(definition) {
  locale = locale_default(definition);
  format5 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
var locale, format5, formatPrefix;
var init_defaultLocale = __esm({
  "node_modules/d3-format/src/defaultLocale.js"() {
    init_locale();
    defaultLocale({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
  }
});

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}
var init_precisionFixed = __esm({
  "node_modules/d3-format/src/precisionFixed.js"() {
    init_exponent();
  }
});

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}
var init_precisionPrefix = __esm({
  "node_modules/d3-format/src/precisionPrefix.js"() {
    init_exponent();
  }
});

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}
var init_precisionRound = __esm({
  "node_modules/d3-format/src/precisionRound.js"() {
    init_exponent();
  }
});

// node_modules/d3-format/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  FormatSpecifier: () => FormatSpecifier,
  format: () => format5,
  formatDefaultLocale: () => defaultLocale,
  formatLocale: () => locale_default,
  formatPrefix: () => formatPrefix,
  formatSpecifier: () => formatSpecifier,
  precisionFixed: () => precisionFixed_default,
  precisionPrefix: () => precisionPrefix_default,
  precisionRound: () => precisionRound_default
});
var init_src3 = __esm({
  "node_modules/d3-format/src/index.js"() {
    init_defaultLocale();
    init_locale();
    init_formatSpecifier();
    init_precisionFixed();
    init_precisionPrefix();
    init_precisionRound();
  }
});

// node_modules/d3-array/src/ascending.js
function ascending(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
var init_ascending2 = __esm({
  "node_modules/d3-array/src/ascending.js"() {
  }
});

// node_modules/d3-array/src/descending.js
function descending(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
var init_descending3 = __esm({
  "node_modules/d3-array/src/descending.js"() {
  }
});

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x2) => ascending(f(d), x2);
    delta = (d, x2) => f(d) - x2;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a2, x2, lo = 0, hi = a2.length) {
    const i = left2(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}
var init_bisector = __esm({
  "node_modules/d3-array/src/bisector.js"() {
    init_ascending2();
    init_descending3();
  }
});

// node_modules/d3-array/src/number.js
function number(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values2, valueof) {
  if (valueof === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index, values2)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}
var init_number = __esm({
  "node_modules/d3-array/src/number.js"() {
  }
});

// node_modules/d3-array/src/bisect.js
var ascendingBisect, bisectRight, bisectLeft, bisectCenter, bisect_default;
var init_bisect = __esm({
  "node_modules/d3-array/src/bisect.js"() {
    init_ascending2();
    init_bisector();
    init_number();
    ascendingBisect = bisector(ascending);
    bisectRight = ascendingBisect.right;
    bisectLeft = ascendingBisect.left;
    bisectCenter = bisector(number).center;
    bisect_default = bisectRight;
  }
});

// node_modules/internmap/src/index.js
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
var InternMap;
var init_src4 = __esm({
  "node_modules/internmap/src/index.js"() {
    InternMap = class extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
        if (entries != null)
          for (const [key2, value] of entries)
            this.set(key2, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    };
  }
});

// node_modules/d3-array/src/sort.js
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a2, b) => {
    const x2 = compare(a2, b);
    if (x2 || x2 === 0)
      return x2;
    return (compare(b, b) === 0) - (compare(a2, a2) === 0);
  };
}
function ascendingDefined(a2, b) {
  return (a2 == null || !(a2 >= a2)) - (b == null || !(b >= b)) || (a2 < b ? -1 : a2 > b ? 1 : 0);
}
var init_sort = __esm({
  "node_modules/d3-array/src/sort.js"() {
    init_ascending2();
  }
});

// node_modules/d3-array/src/ticks.js
function tickSpec(start2, stop, count) {
  const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2)
    return tickSpec(start2, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  if (!(count > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  return tickSpec(start2, stop, count)[2];
}
function tickStep(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
var e10, e5, e2;
var init_ticks = __esm({
  "node_modules/d3-array/src/ticks.js"() {
    e10 = Math.sqrt(50);
    e5 = Math.sqrt(10);
    e2 = Math.sqrt(2);
  }
});

// node_modules/d3-array/src/max.js
function max3(values2, valueof) {
  let max4;
  if (valueof === void 0) {
    for (const value of values2) {
      if (value != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index, values2)) != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value;
      }
    }
  }
  return max4;
}
var init_max = __esm({
  "node_modules/d3-array/src/max.js"() {
  }
});

// node_modules/d3-array/src/min.js
function min3(values2, valueof) {
  let min4;
  if (valueof === void 0) {
    for (const value of values2) {
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  }
  return min4;
}
var init_min = __esm({
  "node_modules/d3-array/src/min.js"() {
  }
});

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left2 = 0, right2 = Infinity, compare) {
  k2 = Math.floor(k2);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k2 && k2 <= right2))
    return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m = k2 - left2 + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k2 - m * s2 / n + sd));
      const newRight = Math.min(right2, Math.floor(k2 + (n - m) * s2 / n + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i = left2;
    let j = right2;
    swap(array2, left2, k2);
    if (compare(array2[right2], t) > 0)
      swap(array2, left2, right2);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0)
        ++i;
      while (compare(array2[j], t) > 0)
        --j;
    }
    if (compare(array2[left2], t) === 0)
      swap(array2, left2, j);
    else
      ++j, swap(array2, j, right2);
    if (j <= k2)
      left2 = j + 1;
    if (k2 <= j)
      right2 = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}
var init_quickselect = __esm({
  "node_modules/d3-array/src/quickselect.js"() {
    init_sort();
  }
});

// node_modules/d3-array/src/quantile.js
function quantile(values2, p, valueof) {
  values2 = Float64Array.from(numbers(values2, valueof));
  if (!(n = values2.length) || isNaN(p = +p))
    return;
  if (p <= 0 || n < 2)
    return min3(values2);
  if (p >= 1)
    return max3(values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max3(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min3(values2.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values2, p, valueof = number) {
  if (!(n = values2.length) || isNaN(p = +p))
    return;
  if (p <= 0 || n < 2)
    return +valueof(values2[0], 0, values2);
  if (p >= 1)
    return +valueof(values2[n - 1], n - 1, values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i - i0);
}
var init_quantile = __esm({
  "node_modules/d3-array/src/quantile.js"() {
    init_max();
    init_min();
    init_quickselect();
    init_number();
  }
});

// node_modules/d3-array/src/range.js
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start2 + i * step;
  }
  return range2;
}
var init_range = __esm({
  "node_modules/d3-array/src/range.js"() {
  }
});

// node_modules/d3-array/src/index.js
var init_src5 = __esm({
  "node_modules/d3-array/src/index.js"() {
    init_bisect();
    init_ascending2();
    init_bisector();
    init_quantile();
    init_range();
    init_ticks();
    init_src4();
  }
});

// node_modules/d3-scale/src/init.js
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}
var init_init = __esm({
  "node_modules/d3-scale/src/init.js"() {
  }
});

// node_modules/d3-scale/src/ordinal.js
function ordinal() {
  var index = new InternMap(), domain = [], range2 = [], unknown = implicit;
  function scale(d) {
    let i = index.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range2[i % range2.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index = new InternMap();
    for (const value of _) {
      if (index.has(value))
        continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
var implicit;
var init_ordinal = __esm({
  "node_modules/d3-scale/src/ordinal.js"() {
    init_src5();
    init_init();
    implicit = Symbol("implicit");
  }
});

// node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse = r1 < r0, start2 = reverse ? r1 : r0, stop = reverse ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round2)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round2)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values2 = range(n).map(function(i) {
      return start2 + step * i;
    });
    return ordinalRange(reverse ? values2.reverse() : values2);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round2 = !!_, rescale()) : round2;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy3 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy3());
  };
  return scale;
}
function point5() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
var init_band = __esm({
  "node_modules/d3-scale/src/band.js"() {
    init_src5();
    init_init();
    init_ordinal();
  }
});

// node_modules/d3-color/src/define.js
function define_default(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype;
  prototype.constructor = constructor;
}
function extend2(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
var init_define = __esm({
  "node_modules/d3-color/src/define.js"() {
  }
});

// node_modules/d3-color/src/color.js
function Color() {
}
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format6) {
  var m, l;
  format6 = (format6 + "").trim().toLowerCase();
  return (m = reHex.exec(format6)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format6)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format6)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format6)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format6)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format6)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format6)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format6) ? rgbn(named[format6]) : format6 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0)
    h = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s2 = NaN;
  else if (s2 <= 0)
    h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max4 = Math.max(r, g, b), h = NaN, s2 = max4 - min4, l = (max4 + min4) / 2;
  if (s2) {
    if (r === max4)
      h = (g - b) / s2 + (g < b) * 6;
    else if (g === max4)
      h = (b - r) / s2 + 2;
    else
      h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
var darker, brighter, reI, reN, reP, reHex, reRgbInteger, reRgbPercent, reRgbaInteger, reRgbaPercent, reHslPercent, reHslaPercent, named;
var init_color = __esm({
  "node_modules/d3-color/src/color.js"() {
    init_define();
    darker = 0.7;
    brighter = 1 / darker;
    reI = "\\s*([+-]?\\d+)\\s*";
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
    reHex = /^#([0-9a-f]{3,8})$/;
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define_default(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    define_default(Rgb, rgb, extend2(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    define_default(Hsl, hsl, extend2(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a2 = clampa(this.opacity);
        return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
      }
    }));
  }
});

// node_modules/d3-color/src/math.js
var radians, degrees;
var init_math2 = __esm({
  "node_modules/d3-color/src/math.js"() {
    radians = Math.PI / 180;
    degrees = 180 / Math.PI;
  }
});

// node_modules/d3-color/src/lab.js
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b)
    x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab(l, a2, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
}
function Lab(l, a2, b, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function lch(l, c2, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
}
function hcl(h, c2, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c2, l, opacity) {
  this.h = +h;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
var K, Xn, Yn, Zn, t0, t1, t2, t3;
var init_lab = __esm({
  "node_modules/d3-color/src/lab.js"() {
    init_define();
    init_color();
    init_math2();
    K = 18;
    Xn = 0.96422;
    Yn = 1;
    Zn = 0.82521;
    t0 = 4 / 29;
    t1 = 6 / 29;
    t2 = 3 * t1 * t1;
    t3 = t1 * t1 * t1;
    define_default(Lab, lab, extend2(Color, {
      brighter(k2) {
        return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
      },
      darker(k2) {
        return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
      },
      rgb() {
        var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
        x2 = Xn * lab2xyz(x2);
        y2 = Yn * lab2xyz(y2);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
          lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
          this.opacity
        );
      }
    }));
    define_default(Hcl, hcl, extend2(Color, {
      brighter(k2) {
        return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
      },
      darker(k2) {
        return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));
  }
});

// node_modules/d3-color/src/cubehelix.js
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
var A, B, C, D, E, ED, EB, BC_DA;
var init_cubehelix = __esm({
  "node_modules/d3-color/src/cubehelix.js"() {
    init_define();
    init_color();
    init_math2();
    A = -0.14861;
    B = 1.78277;
    C = -0.29227;
    D = -0.90649;
    E = 1.97294;
    ED = E * D;
    EB = E * B;
    BC_DA = B * C - D * A;
    define_default(Cubehelix, cubehelix, extend2(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh4 = Math.cos(h), sinh4 = Math.sin(h);
        return new Rgb(
          255 * (l + a2 * (A * cosh4 + B * sinh4)),
          255 * (l + a2 * (C * cosh4 + D * sinh4)),
          255 * (l + a2 * (E * cosh4)),
          this.opacity
        );
      }
    }));
  }
});

// node_modules/d3-color/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  color: () => color,
  cubehelix: () => cubehelix,
  gray: () => gray,
  hcl: () => hcl,
  hsl: () => hsl,
  lab: () => lab,
  lch: () => lch,
  rgb: () => rgb
});
var init_src6 = __esm({
  "node_modules/d3-color/src/index.js"() {
    init_color();
    init_lab();
    init_cubehelix();
  }
});

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values2) {
  var n = values2.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
var init_basis2 = __esm({
  "node_modules/d3-interpolate/src/basis.js"() {
  }
});

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values2) {
  var n = values2.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
var init_basisClosed2 = __esm({
  "node_modules/d3-interpolate/src/basisClosed.js"() {
    init_basis2();
  }
});

// node_modules/d3-interpolate/src/constant.js
var constant_default2;
var init_constant2 = __esm({
  "node_modules/d3-interpolate/src/constant.js"() {
    constant_default2 = (x2) => () => x2;
  }
});

// node_modules/d3-interpolate/src/color.js
function linear(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
    return Math.pow(a2 + t * b, y2);
  };
}
function hue(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default2(isNaN(a2) ? b : a2);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y2) : constant_default2(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d) : constant_default2(isNaN(a2) ? b : a2);
}
var init_color2 = __esm({
  "node_modules/d3-interpolate/src/color.js"() {
    init_constant2();
  }
});

// node_modules/d3-interpolate/src/rgb.js
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgb_default, rgbBasis, rgbBasisClosed;
var init_rgb = __esm({
  "node_modules/d3-interpolate/src/rgb.js"() {
    init_src6();
    init_basis2();
    init_basisClosed2();
    init_color2();
    rgb_default = function rgbGamma(y2) {
      var color2 = gamma(y2);
      function rgb2(start2, end) {
        var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
        return function(t) {
          start2.r = r(t);
          start2.g = g(t);
          start2.b = b(t);
          start2.opacity = opacity(t);
          return start2 + "";
        };
      }
      rgb2.gamma = rgbGamma;
      return rgb2;
    }(1);
    rgbBasis = rgbSpline(basis_default2);
    rgbBasisClosed = rgbSpline(basisClosed_default2);
  }
});

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b) {
  if (!b)
    b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a2[i] * (1 - t) + b[i] * t;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
var init_numberArray = __esm({
  "node_modules/d3-interpolate/src/numberArray.js"() {
  }
});

// node_modules/d3-interpolate/src/array.js
function array_default2(a2, b) {
  return (isNumberArray(b) ? numberArray_default : genericArray)(a2, b);
}
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = value_default(a2[i], b[i]);
  for (; i < nb; ++i)
    c2[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x2[i](t);
    return c2;
  };
}
var init_array2 = __esm({
  "node_modules/d3-interpolate/src/array.js"() {
    init_value();
    init_numberArray();
  }
});

// node_modules/d3-interpolate/src/date.js
function date_default(a2, b) {
  var d = /* @__PURE__ */ new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}
var init_date = __esm({
  "node_modules/d3-interpolate/src/date.js"() {
  }
});

// node_modules/d3-interpolate/src/number.js
function number_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return a2 * (1 - t) + b * t;
  };
}
var init_number2 = __esm({
  "node_modules/d3-interpolate/src/number.js"() {
  }
});

// node_modules/d3-interpolate/src/object.js
function object_default(a2, b) {
  var i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = value_default(a2[k2], b[k2]);
    } else {
      c2[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i)
      c2[k2] = i[k2](t);
    return c2;
  };
}
var init_object = __esm({
  "node_modules/d3-interpolate/src/object.js"() {
    init_value();
  }
});

// node_modules/d3-interpolate/src/string.js
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}
var reA, reB;
var init_string = __esm({
  "node_modules/d3-interpolate/src/string.js"() {
    init_number2();
    reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
    reB = new RegExp(reA.source, "g");
  }
});

// node_modules/d3-interpolate/src/value.js
function value_default(a2, b) {
  var t = typeof b, c2;
  return b == null || t === "boolean" ? constant_default2(b) : (t === "number" ? number_default : t === "string" ? (c2 = color(b)) ? (b = c2, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a2, b);
}
var init_value = __esm({
  "node_modules/d3-interpolate/src/value.js"() {
    init_src6();
    init_rgb();
    init_array2();
    init_date();
    init_number2();
    init_object();
    init_string();
    init_constant2();
    init_numberArray();
  }
});

// node_modules/d3-interpolate/src/discrete.js
function discrete_default(range2) {
  var n = range2.length;
  return function(t) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var init_discrete = __esm({
  "node_modules/d3-interpolate/src/discrete.js"() {
  }
});

// node_modules/d3-interpolate/src/hue.js
function hue_default(a2, b) {
  var i = hue(+a2, +b);
  return function(t) {
    var x2 = i(t);
    return x2 - 360 * Math.floor(x2 / 360);
  };
}
var init_hue = __esm({
  "node_modules/d3-interpolate/src/hue.js"() {
    init_color2();
  }
});

// node_modules/d3-interpolate/src/round.js
function round_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}
var init_round = __esm({
  "node_modules/d3-interpolate/src/round.js"() {
  }
});

// node_modules/d3-interpolate/src/transform/decompose.js
function decompose_default(a2, b, c2, d, e3, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b * b))
    a2 /= scaleX, b /= scaleX;
  if (skewX = a2 * c2 + b * d)
    c2 -= a2 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b * c2)
    a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f,
    rotate: Math.atan2(b, a2) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}
var degrees2, identity;
var init_decompose = __esm({
  "node_modules/d3-interpolate/src/transform/decompose.js"() {
    degrees2 = 180 / Math.PI;
    identity = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
  }
});

// node_modules/d3-interpolate/src/transform/parse.js
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}
var svgNode;
var init_parse = __esm({
  "node_modules/d3-interpolate/src/transform/parse.js"() {
    init_decompose();
  }
});

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b, s2, q) {
    if (a2 !== b) {
      if (a2 - b > 180)
        b += 360;
      else if (b - a2 > 180)
        a2 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a2, b, s2, q) {
    if (a2 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b) {
    var s2 = [], q = [];
    a2 = parse(a2), b = parse(b);
    translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
    rotate(a2.rotate, b.rotate, s2, q);
    skewX(a2.skewX, b.skewX, s2, q);
    scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
    a2 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss, interpolateTransformSvg;
var init_transform = __esm({
  "node_modules/d3-interpolate/src/transform/index.js"() {
    init_number2();
    init_parse();
    interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
  }
});

// node_modules/d3-interpolate/src/zoom.js
function cosh3(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh3(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh3(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
var epsilon22, zoom_default;
var init_zoom = __esm({
  "node_modules/d3-interpolate/src/zoom.js"() {
    epsilon22 = 1e-12;
    zoom_default = function zoomRho(rho, rho2, rho4) {
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < epsilon22) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        } else {
          var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s2 = t * S, coshr0 = cosh3(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh3(rho * s2 + r0) - sinh3(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh3(rho * s2 + r0)
            ];
          };
        }
        i.duration = S * 1e3 * rho / Math.SQRT2;
        return i;
      }
      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };
      return zoom;
    }(Math.SQRT2, 2, 4);
  }
});

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.s = s2(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hsl_default, hslLong;
var init_hsl = __esm({
  "node_modules/d3-interpolate/src/hsl.js"() {
    init_src6();
    init_color2();
    hsl_default = hsl2(hue);
    hslLong = hsl2(nogamma);
  }
});

// node_modules/d3-interpolate/src/lab.js
function lab2(start2, end) {
  var l = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a2 = nogamma(start2.a, end.a), b = nogamma(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
  return function(t) {
    start2.l = l(t);
    start2.a = a2(t);
    start2.b = b(t);
    start2.opacity = opacity(t);
    return start2 + "";
  };
}
var init_lab2 = __esm({
  "node_modules/d3-interpolate/src/lab.js"() {
    init_src6();
    init_color2();
  }
});

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c2 = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.c = c2(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hcl_default, hclLong;
var init_hcl = __esm({
  "node_modules/d3-interpolate/src/hcl.js"() {
    init_src6();
    init_color2();
    hcl_default = hcl2(hue);
    hclLong = hcl2(nogamma);
  }
});

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix3(start2, end) {
      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s2(t);
        start2.l = l(Math.pow(t, y2));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default, cubehelixLong;
var init_cubehelix2 = __esm({
  "node_modules/d3-interpolate/src/cubehelix.js"() {
    init_src6();
    init_color2();
    cubehelix_default = cubehelix2(hue);
    cubehelixLong = cubehelix2(nogamma);
  }
});

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values2) {
  if (values2 === void 0)
    values2 = interpolate, interpolate = value_default;
  var i = 0, n = values2.length - 1, v = values2[0], I = new Array(n < 0 ? 0 : n);
  while (i < n)
    I[i] = interpolate(v, v = values2[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}
var init_piecewise = __esm({
  "node_modules/d3-interpolate/src/piecewise.js"() {
    init_value();
  }
});

// node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}
var init_quantize = __esm({
  "node_modules/d3-interpolate/src/quantize.js"() {
  }
});

// node_modules/d3-interpolate/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  interpolate: () => value_default,
  interpolateArray: () => array_default2,
  interpolateBasis: () => basis_default2,
  interpolateBasisClosed: () => basisClosed_default2,
  interpolateCubehelix: () => cubehelix_default,
  interpolateCubehelixLong: () => cubehelixLong,
  interpolateDate: () => date_default,
  interpolateDiscrete: () => discrete_default,
  interpolateHcl: () => hcl_default,
  interpolateHclLong: () => hclLong,
  interpolateHsl: () => hsl_default,
  interpolateHslLong: () => hslLong,
  interpolateHue: () => hue_default,
  interpolateLab: () => lab2,
  interpolateNumber: () => number_default,
  interpolateNumberArray: () => numberArray_default,
  interpolateObject: () => object_default,
  interpolateRgb: () => rgb_default,
  interpolateRgbBasis: () => rgbBasis,
  interpolateRgbBasisClosed: () => rgbBasisClosed,
  interpolateRound: () => round_default,
  interpolateString: () => string_default,
  interpolateTransformCss: () => interpolateTransformCss,
  interpolateTransformSvg: () => interpolateTransformSvg,
  interpolateZoom: () => zoom_default,
  piecewise: () => piecewise,
  quantize: () => quantize_default
});
var init_src7 = __esm({
  "node_modules/d3-interpolate/src/index.js"() {
    init_value();
    init_array2();
    init_basis2();
    init_basisClosed2();
    init_date();
    init_discrete();
    init_hue();
    init_number2();
    init_numberArray();
    init_object();
    init_round();
    init_string();
    init_transform();
    init_zoom();
    init_rgb();
    init_hsl();
    init_lab2();
    init_hcl();
    init_cubehelix2();
    init_piecewise();
    init_quantize();
  }
});

// node_modules/d3-scale/src/constant.js
function constants(x2) {
  return function() {
    return x2;
  };
}
var init_constant3 = __esm({
  "node_modules/d3-scale/src/constant.js"() {
  }
});

// node_modules/d3-scale/src/number.js
function number2(x2) {
  return +x2;
}
var init_number3 = __esm({
  "node_modules/d3-scale/src/number.js"() {
  }
});

// node_modules/d3-scale/src/continuous.js
function identity2(x2) {
  return x2;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  var t;
  if (a2 > b)
    t = a2, a2 = b, b = t;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap(domain, range2, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range2, interpolate) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisect_default(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate = value_default, transform2, untransform, unknown, clamp2 = identity2, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp2 !== identity2)
      clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform2), range2, interpolate)))(transform2(clamp2(x2)));
  }
  scale.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise2(range2, domain.map(transform2), number_default)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity2, rescale()) : clamp2 !== identity2;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform2 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity2, identity2);
}
var unit;
var init_continuous = __esm({
  "node_modules/d3-scale/src/continuous.js"() {
    init_src5();
    init_src7();
    init_constant3();
    init_number3();
    unit = [0, 1];
  }
});

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count, specifier) {
  var step = tickStep(start2, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format5(specifier);
}
var init_tickFormat = __esm({
  "node_modules/d3-scale/src/tickFormat.js"() {
    init_src5();
    init_src3();
  }
});

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null)
      count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
var init_linear2 = __esm({
  "node_modules/d3-scale/src/linear.js"() {
    init_src5();
    init_continuous();
    init_init();
    init_tickFormat();
  }
});

// node_modules/d3-scale/src/identity.js
function identity3(domain) {
  var unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), scale) : domain.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return identity3(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number2) : [0, 1];
  return linearish(scale);
}
var init_identity3 = __esm({
  "node_modules/d3-scale/src/identity.js"() {
    init_linear2();
    init_number3();
  }
});

// node_modules/d3-scale/src/nice.js
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval2.floor(x0);
  domain[i1] = interval2.ceil(x1);
  return domain;
}
var init_nice = __esm({
  "node_modules/d3-scale/src/nice.js"() {
  }
});

// node_modules/d3-scale/src/log.js
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
}
function reflect(f) {
  return (x2, k2) => -f(-x2, k2);
}
function loggish(transform2) {
  const scale = transform2(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = (count) => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;
    if (r)
      [u, v] = [v, u];
    let i = logs(u);
    let j = logs(v);
    let k2;
    let t;
    const n = count == null ? 10 : +count;
    let z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0)
        for (; i <= j; ++i) {
          for (k2 = 1; k2 < base; ++k2) {
            t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      else
        for (; i <= j; ++i) {
          for (k2 = base - 1; k2 >= 1; --k2) {
            t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      if (z.length * 2 < n)
        z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = (count, specifier) => {
    if (count == null)
      count = 10;
    if (specifier == null)
      specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format5(specifier);
    }
    if (count === Infinity)
      return specifier;
    const k2 = Math.max(1, base * count / scale.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5)
        i *= base;
      return i <= k2 ? specifier(d) : "";
    };
  };
  scale.nice = () => {
    return domain(nice(domain(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale;
}
function log3() {
  const scale = loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log3()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}
var init_log = __esm({
  "node_modules/d3-scale/src/log.js"() {
    init_src5();
    init_src3();
    init_nice();
    init_continuous();
    init_init();
  }
});

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform2) {
  var c2 = 1, scale = transform2(transformSymlog(c2), transformSymexp(c2));
  scale.constant = function(_) {
    return arguments.length ? transform2(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer());
  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}
var init_symlog = __esm({
  "node_modules/d3-scale/src/symlog.js"() {
    init_linear2();
    init_continuous();
    init_init();
  }
});

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent) : Math.pow(x2, exponent);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform2) {
  var scale = transform2(identity2, identity2), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform2(identity2, identity2) : exponent === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent), transformPow(1 / exponent));
  }
  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale);
}
function pow2() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy(scale, pow2()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt4() {
  return pow2.apply(null, arguments).exponent(0.5);
}
var init_pow = __esm({
  "node_modules/d3-scale/src/pow.js"() {
    init_linear2();
    init_continuous();
    init_init();
  }
});

// node_modules/d3-scale/src/radial.js
function square(x2) {
  return Math.sign(x2) * x2 * x2;
}
function unsquare(x2) {
  return Math.sign(x2) * Math.sqrt(Math.abs(x2));
}
function radial() {
  var squared = continuous(), range2 = [0, 1], round2 = false, unknown;
  function scale(x2) {
    var y2 = unsquare(squared(x2));
    return isNaN(y2) ? unknown : round2 ? Math.round(y2) : y2;
  }
  scale.invert = function(y2) {
    return squared.invert(square(y2));
  };
  scale.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale) : squared.domain();
  };
  scale.range = function(_) {
    return arguments.length ? (squared.range((range2 = Array.from(_, number2)).map(square)), scale) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return scale.range(_).round(true);
  };
  scale.round = function(_) {
    return arguments.length ? (round2 = !!_, scale) : round2;
  };
  scale.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return radial(squared.domain(), range2).round(round2).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
var init_radial2 = __esm({
  "node_modules/d3-scale/src/radial.js"() {
    init_continuous();
    init_init();
    init_linear2();
    init_number3();
  }
});

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range2 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range2.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = quantileSorted(domain, i / n);
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : range2[bisect_default(thresholds, x2)];
  }
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending);
    return rescale();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile2().domain(domain).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
var init_quantile2 = __esm({
  "node_modules/d3-scale/src/quantile.js"() {
    init_src5();
    init_init();
  }
});

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x0 = 0, x1 = 1, n = 1, domain = [0.5], range2 = [0, 1], unknown;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range2[bisect_default(domain, x2, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n)
      domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale.range = function(_) {
    return arguments.length ? (n = (range2 = Array.from(_)).length - 1, rescale()) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x0, x1]).range(range2).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}
var init_quantize2 = __esm({
  "node_modules/d3-scale/src/quantize.js"() {
    init_src5();
    init_linear2();
    init_init();
  }
});

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range2 = [0, 1], unknown, n = 1;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range2[bisect_default(domain, x2, 0, n)] : unknown;
  }
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), n = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
var init_threshold = __esm({
  "node_modules/d3-scale/src/threshold.js"() {
    init_src5();
    init_init();
  }
});

// node_modules/d3-time/src/interval.js
function timeInterval(floori, offseti, count, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start2, stop, step) => {
    const range2 = [];
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0))
      return range2;
    let previous;
    do
      range2.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count) {
    interval2.count = (start2, end) => {
      t02.setTime(+start2), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count(t02, t12));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? (d) => field(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
    };
  }
  return interval2;
}
var t02, t12;
var init_interval = __esm({
  "node_modules/d3-time/src/interval.js"() {
    t02 = /* @__PURE__ */ new Date();
    t12 = /* @__PURE__ */ new Date();
  }
});

// node_modules/d3-time/src/millisecond.js
var millisecond, milliseconds;
var init_millisecond = __esm({
  "node_modules/d3-time/src/millisecond.js"() {
    init_interval();
    millisecond = timeInterval(() => {
    }, (date2, step) => {
      date2.setTime(+date2 + step);
    }, (start2, end) => {
      return end - start2;
    });
    millisecond.every = (k2) => {
      k2 = Math.floor(k2);
      if (!isFinite(k2) || !(k2 > 0))
        return null;
      if (!(k2 > 1))
        return millisecond;
      return timeInterval((date2) => {
        date2.setTime(Math.floor(date2 / k2) * k2);
      }, (date2, step) => {
        date2.setTime(+date2 + step * k2);
      }, (start2, end) => {
        return (end - start2) / k2;
      });
    };
    milliseconds = millisecond.range;
  }
});

// node_modules/d3-time/src/duration.js
var durationSecond, durationMinute, durationHour, durationDay, durationWeek, durationMonth, durationYear;
var init_duration = __esm({
  "node_modules/d3-time/src/duration.js"() {
    durationSecond = 1e3;
    durationMinute = durationSecond * 60;
    durationHour = durationMinute * 60;
    durationDay = durationHour * 24;
    durationWeek = durationDay * 7;
    durationMonth = durationDay * 30;
    durationYear = durationDay * 365;
  }
});

// node_modules/d3-time/src/second.js
var second, seconds;
var init_second = __esm({
  "node_modules/d3-time/src/second.js"() {
    init_interval();
    init_duration();
    second = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds());
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationSecond);
    }, (start2, end) => {
      return (end - start2) / durationSecond;
    }, (date2) => {
      return date2.getUTCSeconds();
    });
    seconds = second.range;
  }
});

// node_modules/d3-time/src/minute.js
var timeMinute, timeMinutes, utcMinute, utcMinutes;
var init_minute = __esm({
  "node_modules/d3-time/src/minute.js"() {
    init_interval();
    init_duration();
    timeMinute = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationMinute);
    }, (start2, end) => {
      return (end - start2) / durationMinute;
    }, (date2) => {
      return date2.getMinutes();
    });
    timeMinutes = timeMinute.range;
    utcMinute = timeInterval((date2) => {
      date2.setUTCSeconds(0, 0);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationMinute);
    }, (start2, end) => {
      return (end - start2) / durationMinute;
    }, (date2) => {
      return date2.getUTCMinutes();
    });
    utcMinutes = utcMinute.range;
  }
});

// node_modules/d3-time/src/hour.js
var timeHour, timeHours, utcHour, utcHours;
var init_hour = __esm({
  "node_modules/d3-time/src/hour.js"() {
    init_interval();
    init_duration();
    timeHour = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationHour);
    }, (start2, end) => {
      return (end - start2) / durationHour;
    }, (date2) => {
      return date2.getHours();
    });
    timeHours = timeHour.range;
    utcHour = timeInterval((date2) => {
      date2.setUTCMinutes(0, 0, 0);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationHour);
    }, (start2, end) => {
      return (end - start2) / durationHour;
    }, (date2) => {
      return date2.getUTCHours();
    });
    utcHours = utcHour.range;
  }
});

// node_modules/d3-time/src/day.js
var timeDay, timeDays, utcDay, utcDays, unixDay, unixDays;
var init_day = __esm({
  "node_modules/d3-time/src/day.js"() {
    init_interval();
    init_duration();
    timeDay = timeInterval(
      (date2) => date2.setHours(0, 0, 0, 0),
      (date2, step) => date2.setDate(date2.getDate() + step),
      (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
      (date2) => date2.getDate() - 1
    );
    timeDays = timeDay.range;
    utcDay = timeInterval((date2) => {
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, (start2, end) => {
      return (end - start2) / durationDay;
    }, (date2) => {
      return date2.getUTCDate() - 1;
    });
    utcDays = utcDay.range;
    unixDay = timeInterval((date2) => {
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, (start2, end) => {
      return (end - start2) / durationDay;
    }, (date2) => {
      return Math.floor(date2 / durationDay);
    });
    unixDays = unixDay.range;
  }
});

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start2, end) => {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start2, end) => {
    return (end - start2) / durationWeek;
  });
}
var timeSunday, timeMonday, timeTuesday, timeWednesday, timeThursday, timeFriday, timeSaturday, timeSundays, timeMondays, timeTuesdays, timeWednesdays, timeThursdays, timeFridays, timeSaturdays, utcSunday, utcMonday, utcTuesday, utcWednesday, utcThursday, utcFriday, utcSaturday, utcSundays, utcMondays, utcTuesdays, utcWednesdays, utcThursdays, utcFridays, utcSaturdays;
var init_week = __esm({
  "node_modules/d3-time/src/week.js"() {
    init_interval();
    init_duration();
    timeSunday = timeWeekday(0);
    timeMonday = timeWeekday(1);
    timeTuesday = timeWeekday(2);
    timeWednesday = timeWeekday(3);
    timeThursday = timeWeekday(4);
    timeFriday = timeWeekday(5);
    timeSaturday = timeWeekday(6);
    timeSundays = timeSunday.range;
    timeMondays = timeMonday.range;
    timeTuesdays = timeTuesday.range;
    timeWednesdays = timeWednesday.range;
    timeThursdays = timeThursday.range;
    timeFridays = timeFriday.range;
    timeSaturdays = timeSaturday.range;
    utcSunday = utcWeekday(0);
    utcMonday = utcWeekday(1);
    utcTuesday = utcWeekday(2);
    utcWednesday = utcWeekday(3);
    utcThursday = utcWeekday(4);
    utcFriday = utcWeekday(5);
    utcSaturday = utcWeekday(6);
    utcSundays = utcSunday.range;
    utcMondays = utcMonday.range;
    utcTuesdays = utcTuesday.range;
    utcWednesdays = utcWednesday.range;
    utcThursdays = utcThursday.range;
    utcFridays = utcFriday.range;
    utcSaturdays = utcSaturday.range;
  }
});

// node_modules/d3-time/src/month.js
var timeMonth, timeMonths, utcMonth, utcMonths;
var init_month = __esm({
  "node_modules/d3-time/src/month.js"() {
    init_interval();
    timeMonth = timeInterval((date2) => {
      date2.setDate(1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setMonth(date2.getMonth() + step);
    }, (start2, end) => {
      return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
    }, (date2) => {
      return date2.getMonth();
    });
    timeMonths = timeMonth.range;
    utcMonth = timeInterval((date2) => {
      date2.setUTCDate(1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCMonth(date2.getUTCMonth() + step);
    }, (start2, end) => {
      return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
    }, (date2) => {
      return date2.getUTCMonth();
    });
    utcMonths = utcMonth.range;
  }
});

// node_modules/d3-time/src/year.js
var timeYear, timeYears, utcYear, utcYears;
var init_year = __esm({
  "node_modules/d3-time/src/year.js"() {
    init_interval();
    timeYear = timeInterval((date2) => {
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step);
    }, (start2, end) => {
      return end.getFullYear() - start2.getFullYear();
    }, (date2) => {
      return date2.getFullYear();
    });
    timeYear.every = (k2) => {
      return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
        date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
        date2.setMonth(0, 1);
        date2.setHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setFullYear(date2.getFullYear() + step * k2);
      });
    };
    timeYears = timeYear.range;
    utcYear = timeInterval((date2) => {
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step);
    }, (start2, end) => {
      return end.getUTCFullYear() - start2.getUTCFullYear();
    }, (date2) => {
      return date2.getUTCFullYear();
    });
    utcYear.every = (k2) => {
      return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
        date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
        date2.setUTCMonth(0, 1);
        date2.setUTCHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
      });
    };
    utcYears = utcYear.range;
  }
});

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count) {
    const reverse = stop < start2;
    if (reverse)
      [start2, stop] = [stop, start2];
    const interval2 = count && typeof count.range === "function" ? count : tickInterval(start2, stop, count);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count) {
    const target = Math.abs(stop - start2) / count;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year.every(tickStep(start2 / durationYear, stop / durationYear, count));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start2, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var utcTicks, utcTickInterval, timeTicks, timeTickInterval;
var init_ticks2 = __esm({
  "node_modules/d3-time/src/ticks.js"() {
    init_src5();
    init_duration();
    init_millisecond();
    init_second();
    init_minute();
    init_hour();
    init_day();
    init_week();
    init_month();
    init_year();
    [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
    [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
  }
});

// node_modules/d3-time/src/index.js
var init_src8 = __esm({
  "node_modules/d3-time/src/index.js"() {
    init_second();
    init_minute();
    init_hour();
    init_day();
    init_week();
    init_month();
    init_year();
    init_ticks2();
  }
});

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c2, pad2, format6;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad2 = c2 === "e" ? " " : "0";
          if (format6 = formats2[c2])
            c2 = format6(date2, pad2);
          string.push(c2);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c2, parse;
    while (i < n) {
      if (j >= m)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse || (j = parse(d, string, j)) < 0)
          return -1;
      } else if (c2 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
function pad(value, fill, width) {
  var sign4 = value < 0 ? "-" : "", string = (sign4 ? -value : value) + "", length = string.length;
  return sign4 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name310, i) => [name310.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
var pads, numberRe, percentRe, requoteRe;
var init_locale2 = __esm({
  "node_modules/d3-time-format/src/locale.js"() {
    init_src8();
    pads = { "-": "", "_": " ", "0": "0" };
    numberRe = /^\s*\d+/;
    percentRe = /^%/;
    requoteRe = /[\\^$*+?|[\]().{}]/g;
  }
});

// node_modules/d3-time-format/src/defaultLocale.js
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}
var locale2, timeFormat, timeParse, utcFormat, utcParse;
var init_defaultLocale2 = __esm({
  "node_modules/d3-time-format/src/defaultLocale.js"() {
    init_locale2();
    defaultLocale2({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
  }
});

// node_modules/d3-time-format/src/index.js
var init_src9 = __esm({
  "node_modules/d3-time-format/src/index.js"() {
    init_defaultLocale2();
  }
});

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number3(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format6) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format6(".%L"), formatSecond = format6(":%S"), formatMinute = format6("%I:%M"), formatHour = format6("%I %p"), formatDay = format6("%a %d"), formatWeek = format6("%b %d"), formatMonth = format6("%B"), formatYear2 = format6("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert(y2));
  };
  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number3)) : domain().map(date);
  };
  scale.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat2 : format6(specifier);
  };
  scale.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format6));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var init_time = __esm({
  "node_modules/d3-scale/src/time.js"() {
    init_src8();
    init_src9();
    init_continuous();
    init_init();
    init_nice();
  }
});

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
var init_utcTime = __esm({
  "node_modules/d3-scale/src/utcTime.js"() {
    init_src8();
    init_src9();
    init_time();
    init_init();
  }
});

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x0 = 0, x1 = 1, t03, t13, k10, transform2, interpolator = identity2, clamp2 = false, unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform2(x2) - t03) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t03 = transform2(x0 = +x0), t13 = transform2(x1 = +x1), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale) : [x0, x1];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale) : clamp2;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range2(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range2(value_default);
  scale.rangeRound = range2(round_default);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform2 = t, t03 = t(x0), t13 = t(x1), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);
    return scale;
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer2()(identity2));
  scale.copy = function() {
    return copy2(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = loggish(transformer2()).domain([1, 10]);
  scale.copy = function() {
    return copy2(scale, sequentialLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = symlogish(transformer2());
  scale.copy = function() {
    return copy2(scale, sequentialSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = powish(transformer2());
  scale.copy = function() {
    return copy2(scale, sequentialPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
var init_sequential = __esm({
  "node_modules/d3-scale/src/sequential.js"() {
    init_src7();
    init_continuous();
    init_init();
    init_linear2();
    init_log();
    init_symlog();
    init_pow();
  }
});

// node_modules/d3-scale/src/sequentialQuantile.js
function sequentialQuantile() {
  var domain = [], interpolator = identity2;
  function scale(x2) {
    if (x2 != null && !isNaN(x2 = +x2))
      return interpolator((bisect_default(domain, x2, 1) - 1) / (domain.length - 1));
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending);
    return scale;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  scale.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };
  scale.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));
  };
  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale, arguments);
}
var init_sequentialQuantile = __esm({
  "node_modules/d3-scale/src/sequentialQuantile.js"() {
    init_src5();
    init_continuous();
    init_init();
  }
});

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x0 = 0, x1 = 0.5, x2 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity2, transform2, clamp2 = false, unknown;
  function scale(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform2(x3)) - t13) * (s2 * x3 < s2 * t13 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t03 = transform2(x0 = +x0), t13 = transform2(x1 = +x1), t22 = transform2(x2 = +x2), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale) : [x0, x1, x2];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale) : clamp2;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range2(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range2(value_default);
  scale.rangeRound = range2(round_default);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform2 = t, t03 = t(x0), t13 = t(x1), t22 = t(x2), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = linearish(transformer3()(identity2));
  scale.copy = function() {
    return copy2(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer3()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy2(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
var init_diverging2 = __esm({
  "node_modules/d3-scale/src/diverging.js"() {
    init_src7();
    init_continuous();
    init_init();
    init_linear2();
    init_log();
    init_sequential();
    init_symlog();
    init_pow();
  }
});

// node_modules/d3-scale/src/index.js
var src_exports5 = {};
__export(src_exports5, {
  scaleBand: () => band,
  scaleDiverging: () => diverging,
  scaleDivergingLog: () => divergingLog,
  scaleDivergingPow: () => divergingPow,
  scaleDivergingSqrt: () => divergingSqrt,
  scaleDivergingSymlog: () => divergingSymlog,
  scaleIdentity: () => identity3,
  scaleImplicit: () => implicit,
  scaleLinear: () => linear2,
  scaleLog: () => log3,
  scaleOrdinal: () => ordinal,
  scalePoint: () => point5,
  scalePow: () => pow2,
  scaleQuantile: () => quantile2,
  scaleQuantize: () => quantize,
  scaleRadial: () => radial,
  scaleSequential: () => sequential,
  scaleSequentialLog: () => sequentialLog,
  scaleSequentialPow: () => sequentialPow,
  scaleSequentialQuantile: () => sequentialQuantile,
  scaleSequentialSqrt: () => sequentialSqrt,
  scaleSequentialSymlog: () => sequentialSymlog,
  scaleSqrt: () => sqrt4,
  scaleSymlog: () => symlog,
  scaleThreshold: () => threshold,
  scaleTime: () => time,
  scaleUtc: () => utcTime,
  tickFormat: () => tickFormat
});
var init_src10 = __esm({
  "node_modules/d3-scale/src/index.js"() {
    init_band();
    init_identity3();
    init_linear2();
    init_log();
    init_symlog();
    init_ordinal();
    init_pow();
    init_radial2();
    init_quantile2();
    init_quantize2();
    init_threshold();
    init_time();
    init_utcTime();
    init_sequential();
    init_sequentialQuantile();
    init_diverging2();
    init_tickFormat();
  }
});

// node_modules/d3-axis/src/identity.js
function identity_default3(x2) {
  return x2;
}
var init_identity4 = __esm({
  "node_modules/d3-axis/src/identity.js"() {
  }
});

// node_modules/d3-axis/src/axis.js
function translateX(x2) {
  return "translate(" + x2 + ",0)";
}
function translateY(y2) {
  return "translate(0," + y2 + ")";
}
function number4(scale) {
  return (d) => +scale(d);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format6 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default3 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position = (scale.bandwidth ? center : number4)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k2 * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k2 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon3).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform2(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon3).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position(d) + offset);
    });
    line.attr(x2 + "2", k2 * tickSizeInner);
    text.attr(x2, k2 * spacing).text(format6);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale = _, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
var top, right, bottom, left, epsilon3;
var init_axis = __esm({
  "node_modules/d3-axis/src/axis.js"() {
    init_identity4();
    top = 1;
    right = 2;
    bottom = 3;
    left = 4;
    epsilon3 = 1e-6;
  }
});

// node_modules/d3-axis/src/index.js
var src_exports6 = {};
__export(src_exports6, {
  axisBottom: () => axisBottom,
  axisLeft: () => axisLeft,
  axisRight: () => axisRight,
  axisTop: () => axisTop
});
var init_src11 = __esm({
  "node_modules/d3-axis/src/index.js"() {
    init_axis();
  }
});

// node_modules/d3-dispatch/src/dispatch.js
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name310 = "", i = t.indexOf(".");
    if (i >= 0)
      name310 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name310 };
  });
}
function get(type, name310) {
  for (var i = 0, n = type.length, c2; i < n; ++i) {
    if ((c2 = type[i]).name === name310) {
      return c2.value;
    }
  }
}
function set(type, name310, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name310) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name: name310, value: callback });
  return type;
}
var noop, dispatch_default;
var init_dispatch = __esm({
  "node_modules/d3-dispatch/src/dispatch.js"() {
    noop = { value: () => {
    } };
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
        if (arguments.length < 2) {
          while (++i < n)
            if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
              return t;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type)
            _[t] = set(_[t], typename.name, callback);
          else if (callback == null)
            for (t in _)
              _[t] = set(_[t], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy3 = {}, _ = this._;
        for (var t in _)
          copy3[t] = _[t].slice();
        return new Dispatch(copy3);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i = 0, n, t; i < n; ++i)
            args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i)
          t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
          t[i].value.apply(that, args);
      }
    };
    dispatch_default = dispatch;
  }
});

// node_modules/d3-dispatch/src/index.js
var init_src12 = __esm({
  "node_modules/d3-dispatch/src/index.js"() {
    init_dispatch();
  }
});

// node_modules/d3-selection/src/namespaces.js
var xhtml, namespaces_default;
var init_namespaces = __esm({
  "node_modules/d3-selection/src/namespaces.js"() {
    xhtml = "http://www.w3.org/1999/xhtml";
    namespaces_default = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
  }
});

// node_modules/d3-selection/src/namespace.js
function namespace_default(name310) {
  var prefix = name310 += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name310.slice(0, i)) !== "xmlns")
    name310 = name310.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name310 } : name310;
}
var init_namespace = __esm({
  "node_modules/d3-selection/src/namespace.js"() {
    init_namespaces();
  }
});

// node_modules/d3-selection/src/creator.js
function creatorInherit(name310) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name310) : document2.createElementNS(uri, name310);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name310) {
  var fullname = namespace_default(name310);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
var init_creator = __esm({
  "node_modules/d3-selection/src/creator.js"() {
    init_namespace();
    init_namespaces();
  }
});

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}
var init_selector = __esm({
  "node_modules/d3-selection/src/selector.js"() {
  }
});

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
var init_select = __esm({
  "node_modules/d3-selection/src/selection/select.js"() {
    init_selection();
    init_selector();
  }
});

// node_modules/d3-selection/src/array.js
function array(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
var init_array3 = __esm({
  "node_modules/d3-selection/src/array.js"() {
  }
});

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}
var init_selectorAll = __esm({
  "node_modules/d3-selection/src/selectorAll.js"() {
  }
});

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}
var init_selectAll = __esm({
  "node_modules/d3-selection/src/selection/selectAll.js"() {
    init_selection();
    init_array3();
    init_selectorAll();
  }
});

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}
var init_matcher = __esm({
  "node_modules/d3-selection/src/matcher.js"() {
  }
});

// node_modules/d3-selection/src/selection/selectChild.js
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var find;
var init_selectChild = __esm({
  "node_modules/d3-selection/src/selection/selectChild.js"() {
    init_matcher();
    find = Array.prototype.find;
  }
});

// node_modules/d3-selection/src/selection/selectChildren.js
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter2.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
var filter2;
var init_selectChildren = __esm({
  "node_modules/d3-selection/src/selection/selectChildren.js"() {
    init_matcher();
    filter2 = Array.prototype.filter;
  }
});

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
var init_filter = __esm({
  "node_modules/d3-selection/src/selection/filter.js"() {
    init_selection();
    init_matcher();
  }
});

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}
var init_sparse = __esm({
  "node_modules/d3-selection/src/selection/sparse.js"() {
  }
});

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
var init_enter = __esm({
  "node_modules/d3-selection/src/selection/enter.js"() {
    init_sparse();
    init_selection();
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function(selector) {
        return this._parent.querySelector(selector);
      },
      querySelectorAll: function(selector) {
        return this._parent.querySelectorAll(selector);
      }
    };
  }
});

// node_modules/d3-selection/src/constant.js
function constant_default3(x2) {
  return function() {
    return x2;
  };
}
var init_constant4 = __esm({
  "node_modules/d3-selection/src/constant.js"() {
  }
});

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant_default3(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
var init_data = __esm({
  "node_modules/d3-selection/src/selection/data.js"() {
    init_selection();
    init_enter();
    init_constant4();
  }
});

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}
var init_exit = __esm({
  "node_modules/d3-selection/src/selection/exit.js"() {
    init_sparse();
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
var init_join = __esm({
  "node_modules/d3-selection/src/selection/join.js"() {
  }
});

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}
var init_merge = __esm({
  "node_modules/d3-selection/src/selection/merge.js"() {
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
var init_order = __esm({
  "node_modules/d3-selection/src/selection/order.js"() {
  }
});

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a2, b) {
    return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
var init_sort2 = __esm({
  "node_modules/d3-selection/src/selection/sort.js"() {
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
var init_call = __esm({
  "node_modules/d3-selection/src/selection/call.js"() {
  }
});

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}
var init_nodes = __esm({
  "node_modules/d3-selection/src/selection/nodes.js"() {
  }
});

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}
var init_node = __esm({
  "node_modules/d3-selection/src/selection/node.js"() {
  }
});

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}
var init_size = __esm({
  "node_modules/d3-selection/src/selection/size.js"() {
  }
});

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}
var init_empty = __esm({
  "node_modules/d3-selection/src/selection/empty.js"() {
  }
});

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
var init_each = __esm({
  "node_modules/d3-selection/src/selection/each.js"() {
  }
});

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name310) {
  return function() {
    this.removeAttribute(name310);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name310, value) {
  return function() {
    this.setAttribute(name310, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name310, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name310);
    else
      this.setAttribute(name310, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name310, value) {
  var fullname = namespace_default(name310);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}
var init_attr = __esm({
  "node_modules/d3-selection/src/selection/attr.js"() {
    init_namespace();
  }
});

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
var init_window = __esm({
  "node_modules/d3-selection/src/window.js"() {
  }
});

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name310) {
  return function() {
    this.style.removeProperty(name310);
  };
}
function styleConstant(name310, value, priority) {
  return function() {
    this.style.setProperty(name310, value, priority);
  };
}
function styleFunction(name310, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name310);
    else
      this.style.setProperty(name310, v, priority);
  };
}
function style_default(name310, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name310, value, priority == null ? "" : priority)) : styleValue(this.node(), name310);
}
function styleValue(node, name310) {
  return node.style.getPropertyValue(name310) || window_default(node).getComputedStyle(node, null).getPropertyValue(name310);
}
var init_style = __esm({
  "node_modules/d3-selection/src/selection/style.js"() {
    init_window();
  }
});

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name310) {
  return function() {
    delete this[name310];
  };
}
function propertyConstant(name310, value) {
  return function() {
    this[name310] = value;
  };
}
function propertyFunction(name310, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name310];
    else
      this[name310] = v;
  };
}
function property_default(name310, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name310, value)) : this.node()[name310];
}
var init_property = __esm({
  "node_modules/d3-selection/src/selection/property.js"() {
  }
});

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name310, value) {
  var names = classArray(name310 + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
var init_classed = __esm({
  "node_modules/d3-selection/src/selection/classed.js"() {
    ClassList.prototype = {
      add: function(name310) {
        var i = this._names.indexOf(name310);
        if (i < 0) {
          this._names.push(name310);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name310) {
        var i = this._names.indexOf(name310);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name310) {
        return this._names.indexOf(name310) >= 0;
      }
    };
  }
});

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}
var init_text = __esm({
  "node_modules/d3-selection/src/selection/text.js"() {
  }
});

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
var init_html = __esm({
  "node_modules/d3-selection/src/selection/html.js"() {
  }
});

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}
var init_raise = __esm({
  "node_modules/d3-selection/src/selection/raise.js"() {
  }
});

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}
var init_lower = __esm({
  "node_modules/d3-selection/src/selection/lower.js"() {
  }
});

// node_modules/d3-selection/src/selection/append.js
function append_default(name310) {
  var create3 = typeof name310 === "function" ? name310 : creator_default(name310);
  return this.select(function() {
    return this.appendChild(create3.apply(this, arguments));
  });
}
var init_append = __esm({
  "node_modules/d3-selection/src/selection/append.js"() {
    init_creator();
  }
});

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name310, before) {
  var create3 = typeof name310 === "function" ? name310 : creator_default(name310), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create3.apply(this, arguments), select.apply(this, arguments) || null);
  });
}
var init_insert = __esm({
  "node_modules/d3-selection/src/selection/insert.js"() {
    init_creator();
    init_selector();
  }
});

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}
var init_remove = __esm({
  "node_modules/d3-selection/src/selection/remove.js"() {
  }
});

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone4 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone4, this.nextSibling) : clone4;
}
function selection_cloneDeep() {
  var clone4 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone4, this.nextSibling) : clone4;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
var init_clone = __esm({
  "node_modules/d3-selection/src/selection/clone.js"() {
  }
});

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
var init_datum = __esm({
  "node_modules/d3-selection/src/selection/datum.js"() {
  }
});

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name310 = "", i = t.indexOf(".");
    if (i >= 0)
      name310 = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name310 };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}
var init_on = __esm({
  "node_modules/d3-selection/src/selection/on.js"() {
  }
});

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default2(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
var init_dispatch2 = __esm({
  "node_modules/d3-selection/src/selection/dispatch.js"() {
    init_window();
  }
});

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}
var init_iterator = __esm({
  "node_modules/d3-selection/src/selection/iterator.js"() {
  }
});

// node_modules/d3-selection/src/selection/index.js
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
var root, selection_default;
var init_selection = __esm({
  "node_modules/d3-selection/src/selection/index.js"() {
    init_select();
    init_selectAll();
    init_selectChild();
    init_selectChildren();
    init_filter();
    init_data();
    init_enter();
    init_exit();
    init_join();
    init_merge();
    init_order();
    init_sort2();
    init_call();
    init_nodes();
    init_node();
    init_size();
    init_empty();
    init_each();
    init_attr();
    init_style();
    init_property();
    init_classed();
    init_text();
    init_html();
    init_raise();
    init_lower();
    init_append();
    init_insert();
    init_remove();
    init_clone();
    init_datum();
    init_on();
    init_dispatch2();
    init_iterator();
    root = [null];
    Selection.prototype = selection.prototype = {
      constructor: Selection,
      select: select_default,
      selectAll: selectAll_default,
      selectChild: selectChild_default,
      selectChildren: selectChildren_default,
      filter: filter_default,
      data: data_default,
      enter: enter_default,
      exit: exit_default,
      join: join_default,
      merge: merge_default,
      selection: selection_selection,
      order: order_default,
      sort: sort_default,
      call: call_default,
      nodes: nodes_default,
      node: node_default,
      size: size_default,
      empty: empty_default,
      each: each_default,
      attr: attr_default,
      style: style_default,
      property: property_default,
      classed: classed_default,
      text: text_default,
      html: html_default,
      raise: raise_default,
      lower: lower_default,
      append: append_default,
      insert: insert_default,
      remove: remove_default,
      clone: clone_default,
      datum: datum_default,
      on: on_default,
      dispatch: dispatch_default2,
      [Symbol.iterator]: iterator_default
    };
    selection_default = selection;
  }
});

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}
var init_select2 = __esm({
  "node_modules/d3-selection/src/select.js"() {
    init_selection();
  }
});

// node_modules/d3-selection/src/create.js
function create_default(name310) {
  return select_default2(creator_default(name310).call(document.documentElement));
}
var init_create = __esm({
  "node_modules/d3-selection/src/create.js"() {
    init_creator();
    init_select2();
  }
});

// node_modules/d3-selection/src/local.js
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
var nextId;
var init_local = __esm({
  "node_modules/d3-selection/src/local.js"() {
    nextId = 0;
    Local.prototype = local.prototype = {
      constructor: Local,
      get: function(node) {
        var id2 = this._;
        while (!(id2 in node))
          if (!(node = node.parentNode))
            return;
        return node[id2];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };
  }
});

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}
var init_sourceEvent = __esm({
  "node_modules/d3-selection/src/sourceEvent.js"() {
  }
});

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point6 = svg.createSVGPoint();
      point6.x = event.clientX, point6.y = event.clientY;
      point6 = point6.matrixTransform(node.getScreenCTM().inverse());
      return [point6.x, point6.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
var init_pointer = __esm({
  "node_modules/d3-selection/src/pointer.js"() {
    init_sourceEvent();
  }
});

// node_modules/d3-selection/src/pointers.js
function pointers_default(events, node) {
  if (events.target) {
    events = sourceEvent_default(events);
    if (node === void 0)
      node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, (event) => pointer_default(event, node));
}
var init_pointers = __esm({
  "node_modules/d3-selection/src/pointers.js"() {
    init_pointer();
    init_sourceEvent();
  }
});

// node_modules/d3-selection/src/selectAll.js
function selectAll_default2(selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array(selector)], root);
}
var init_selectAll2 = __esm({
  "node_modules/d3-selection/src/selectAll.js"() {
    init_array3();
    init_selection();
  }
});

// node_modules/d3-selection/src/index.js
var src_exports7 = {};
__export(src_exports7, {
  create: () => create_default,
  creator: () => creator_default,
  local: () => local,
  matcher: () => matcher_default,
  namespace: () => namespace_default,
  namespaces: () => namespaces_default,
  pointer: () => pointer_default,
  pointers: () => pointers_default,
  select: () => select_default2,
  selectAll: () => selectAll_default2,
  selection: () => selection_default,
  selector: () => selector_default,
  selectorAll: () => selectorAll_default,
  style: () => styleValue,
  window: () => window_default
});
var init_src13 = __esm({
  "node_modules/d3-selection/src/index.js"() {
    init_create();
    init_creator();
    init_local();
    init_matcher();
    init_namespace();
    init_namespaces();
    init_pointer();
    init_pointers();
    init_select2();
    init_selectAll2();
    init_selection();
    init_selector();
    init_selectorAll();
    init_style();
    init_window();
  }
});

// node_modules/d3-drag/src/noevent.js
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
var nonpassivecapture;
var init_noevent = __esm({
  "node_modules/d3-drag/src/noevent.js"() {
    nonpassivecapture = { capture: true, passive: false };
  }
});

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
var init_nodrag = __esm({
  "node_modules/d3-drag/src/nodrag.js"() {
    init_src13();
    init_noevent();
  }
});

// node_modules/d3-drag/src/index.js
var init_src14 = __esm({
  "node_modules/d3-drag/src/index.js"() {
    init_nodrag();
  }
});

// node_modules/d3-timer/src/timer.js
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
function timer(callback, delay, time2) {
  var t = new Timer();
  t.restart(callback, delay, time2);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e3;
  while (t) {
    if ((e3 = clockNow - t._time) >= 0)
      t._call.call(void 0, e3);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t03, t13 = taskHead, t22, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time)
        time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t22 : taskHead = t22;
    }
  }
  taskTail = t03;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
var frame, timeout, interval, pokeDelay, taskHead, taskTail, clockLast, clockNow, clockSkew, clock, setFrame;
var init_timer = __esm({
  "node_modules/d3-timer/src/timer.js"() {
    frame = 0;
    timeout = 0;
    interval = 0;
    pokeDelay = 1e3;
    clockLast = 0;
    clockNow = 0;
    clockSkew = 0;
    clock = typeof performance === "object" && performance.now ? performance : Date;
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
      setTimeout(f, 17);
    };
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time2) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time2;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
  }
});

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t;
}
var init_timeout = __esm({
  "node_modules/d3-timer/src/timeout.js"() {
    init_timer();
  }
});

// node_modules/d3-timer/src/index.js
var init_src15 = __esm({
  "node_modules/d3-timer/src/index.js"() {
    init_timer();
    init_timeout();
  }
});

// node_modules/d3-transition/src/transition/schedule.js
function schedule_default(node, name310, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create2(node, id2, {
    name: name310,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create2(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}
var emptyOn, emptyTween, CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED;
var init_schedule = __esm({
  "node_modules/d3-transition/src/transition/schedule.js"() {
    init_src12();
    init_src15();
    emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
    emptyTween = [];
    CREATED = 0;
    SCHEDULED = 1;
    STARTING = 2;
    STARTED = 3;
    RUNNING = 4;
    ENDING = 5;
    ENDED = 6;
  }
});

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name310) {
  var schedules = node.__transition, schedule, active, empty2 = true, i;
  if (!schedules)
    return;
  name310 = name310 == null ? null : name310 + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name310) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty2)
    delete node.__transition;
}
var init_interrupt = __esm({
  "node_modules/d3-transition/src/interrupt.js"() {
    init_schedule();
  }
});

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name310) {
  return this.each(function() {
    interrupt_default(this, name310);
  });
}
var init_interrupt2 = __esm({
  "node_modules/d3-transition/src/selection/interrupt.js"() {
    init_interrupt();
  }
});

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name310) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name310) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name310, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name: name310, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name310) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name310, value) {
  var id2 = this._id;
  name310 += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name310) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name310, value));
}
function tweenValue(transition2, name310, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name310] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name310];
  };
}
var init_tween = __esm({
  "node_modules/d3-transition/src/transition/tween.js"() {
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a2, b) {
  var c2;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c2 = color(b)) ? (b = c2, rgb_default) : string_default)(a2, b);
}
var init_interpolate = __esm({
  "node_modules/d3-transition/src/transition/interpolate.js"() {
    init_src6();
    init_src7();
  }
});

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name310) {
  return function() {
    this.removeAttribute(name310);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name310, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name310);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name310, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name310);
    string0 = this.getAttribute(name310);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name310, value) {
  var fullname = namespace_default(name310), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name310, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name310, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}
var init_attr2 = __esm({
  "node_modules/d3-transition/src/transition/attr.js"() {
    init_src7();
    init_src13();
    init_tween();
    init_interpolate();
  }
});

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name310, i) {
  return function(t) {
    this.setAttribute(name310, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t03 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween(name310, value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t03 = (i0 = i) && attrInterpolate(name310, i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name310, value) {
  var key = "attr." + name310;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name310);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
var init_attrTween = __esm({
  "node_modules/d3-transition/src/transition/attrTween.js"() {
    init_src13();
  }
});

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}
var init_delay = __esm({
  "node_modules/d3-transition/src/transition/delay.js"() {
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}
var init_duration2 = __esm({
  "node_modules/d3-transition/src/transition/duration.js"() {
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}
var init_ease = __esm({
  "node_modules/d3-transition/src/transition/ease.js"() {
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}
var init_easeVarying = __esm({
  "node_modules/d3-transition/src/transition/easeVarying.js"() {
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
var init_filter2 = __esm({
  "node_modules/d3-transition/src/transition/filter.js"() {
    init_src13();
    init_transition2();
  }
});

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
var init_merge2 = __esm({
  "node_modules/d3-transition/src/transition/merge.js"() {
    init_transition2();
  }
});

// node_modules/d3-transition/src/transition/on.js
function start(name310) {
  return (name310 + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name310, listener) {
  var on0, on1, sit = start(name310) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name310, listener);
    schedule.on = on1;
  };
}
function on_default2(name310, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name310) : this.each(onFunction(id2, name310, listener));
}
var init_on2 = __esm({
  "node_modules/d3-transition/src/transition/on.js"() {
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}
var init_remove2 = __esm({
  "node_modules/d3-transition/src/transition/remove.js"() {
  }
});

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name310 = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name310, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name310, id2);
}
var init_select3 = __esm({
  "node_modules/d3-transition/src/transition/select.js"() {
    init_src13();
    init_transition2();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name310 = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {
          if (child = children2[k2]) {
            schedule_default(child, name310, id2, k2, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name310, id2);
}
var init_selectAll3 = __esm({
  "node_modules/d3-transition/src/transition/selectAll.js"() {
    init_src13();
    init_transition2();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/selection.js
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}
var Selection2;
var init_selection2 = __esm({
  "node_modules/d3-transition/src/transition/selection.js"() {
    init_src13();
    Selection2 = selection_default.prototype.constructor;
  }
});

// node_modules/d3-transition/src/transition/style.js
function styleNull(name310, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name310), string1 = (this.style.removeProperty(name310), styleValue(this, name310));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name310) {
  return function() {
    this.style.removeProperty(name310);
  };
}
function styleConstant2(name310, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name310);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name310, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name310), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name310), styleValue(this, name310));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name310) {
  var on0, on1, listener0, key = "style." + name310, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name310)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name310, value, priority) {
  var i = (name310 += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name310, styleNull(name310, i)).on("end.style." + name310, styleRemove2(name310)) : typeof value === "function" ? this.styleTween(name310, styleFunction2(name310, i, tweenValue(this, "style." + name310, value))).each(styleMaybeRemove(this._id, name310)) : this.styleTween(name310, styleConstant2(name310, i, value), priority).on("end.style." + name310, null);
}
var init_style2 = __esm({
  "node_modules/d3-transition/src/transition/style.js"() {
    init_src7();
    init_src13();
    init_schedule();
    init_tween();
    init_interpolate();
  }
});

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name310, i, priority) {
  return function(t) {
    this.style.setProperty(name310, i.call(this, t), priority);
  };
}
function styleTween(name310, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name310, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name310, value, priority) {
  var key = "style." + (name310 += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name310, value, priority == null ? "" : priority));
}
var init_styleTween = __esm({
  "node_modules/d3-transition/src/transition/styleTween.js"() {
  }
});

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}
var init_text2 = __esm({
  "node_modules/d3-transition/src/transition/text.js"() {
    init_tween();
  }
});

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t03 = (i0 = i) && textInterpolate(i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
var init_textTween = __esm({
  "node_modules/d3-transition/src/transition/textTween.js"() {
  }
});

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name310 = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name310, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name310, id1);
}
var init_transition = __esm({
  "node_modules/d3-transition/src/transition/transition.js"() {
    init_transition2();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}
var init_end = __esm({
  "node_modules/d3-transition/src/transition/end.js"() {
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/index.js
function Transition(groups, parents, name310, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name310;
  this._id = id2;
}
function transition(name310) {
  return selection_default().transition(name310);
}
function newId() {
  return ++id;
}
var id, selection_prototype;
var init_transition2 = __esm({
  "node_modules/d3-transition/src/transition/index.js"() {
    init_src13();
    init_attr2();
    init_attrTween();
    init_delay();
    init_duration2();
    init_ease();
    init_easeVarying();
    init_filter2();
    init_merge2();
    init_on2();
    init_remove2();
    init_select3();
    init_selectAll3();
    init_selection2();
    init_style2();
    init_styleTween();
    init_text2();
    init_textTween();
    init_transition();
    init_tween();
    init_end();
    id = 0;
    selection_prototype = selection_default.prototype;
    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: select_default3,
      selectAll: selectAll_default3,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: filter_default2,
      merge: merge_default2,
      selection: selection_default2,
      transition: transition_default,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: on_default2,
      attr: attr_default2,
      attrTween: attrTween_default,
      style: style_default2,
      styleTween: styleTween_default,
      text: text_default2,
      textTween: textTween_default,
      remove: remove_default2,
      tween: tween_default,
      delay: delay_default,
      duration: duration_default,
      ease: ease_default,
      easeVarying: easeVarying_default,
      end: end_default,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };
  }
});

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var init_cubic = __esm({
  "node_modules/d3-ease/src/cubic.js"() {
  }
});

// node_modules/d3-ease/src/index.js
var init_src16 = __esm({
  "node_modules/d3-ease/src/index.js"() {
    init_cubic();
  }
});

// node_modules/d3-transition/src/selection/transition.js
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name310) {
  var id2, timing;
  if (name310 instanceof Transition) {
    id2 = name310._id, name310 = name310._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name310 = name310 == null ? null : name310 + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name310, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name310, id2);
}
var defaultTiming;
var init_transition3 = __esm({
  "node_modules/d3-transition/src/selection/transition.js"() {
    init_transition2();
    init_schedule();
    init_src16();
    init_src15();
    defaultTiming = {
      time: null,
      // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };
  }
});

// node_modules/d3-transition/src/selection/index.js
var init_selection3 = __esm({
  "node_modules/d3-transition/src/selection/index.js"() {
    init_src13();
    init_interrupt2();
    init_transition3();
    selection_default.prototype.interrupt = interrupt_default2;
    selection_default.prototype.transition = transition_default2;
  }
});

// node_modules/d3-transition/src/index.js
var init_src17 = __esm({
  "node_modules/d3-transition/src/index.js"() {
    init_selection3();
    init_interrupt();
  }
});

// node_modules/d3-zoom/src/constant.js
var constant_default4;
var init_constant5 = __esm({
  "node_modules/d3-zoom/src/constant.js"() {
    constant_default4 = (x2) => () => x2;
  }
});

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
var init_event = __esm({
  "node_modules/d3-zoom/src/event.js"() {
  }
});

// node_modules/d3-zoom/src/transform.js
function Transform(k2, x2, y2) {
  this.k = k2;
  this.x = x2;
  this.y = y2;
}
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity4;
  return node.__zoom;
}
var identity4;
var init_transform2 = __esm({
  "node_modules/d3-zoom/src/transform.js"() {
    Transform.prototype = {
      constructor: Transform,
      scale: function(k2) {
        return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
      },
      translate: function(x2, y2) {
        return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
      },
      apply: function(point6) {
        return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];
      },
      applyX: function(x2) {
        return x2 * this.k + this.x;
      },
      applyY: function(y2) {
        return y2 * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x2) {
        return (x2 - this.x) / this.k;
      },
      invertY: function(y2) {
        return (y2 - this.y) / this.k;
      },
      rescaleX: function(x2) {
        return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
      },
      rescaleY: function(y2) {
        return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };
    identity4 = new Transform(1, 0, 0);
    transform.prototype = Transform.prototype;
  }
});

// node_modules/d3-zoom/src/noevent.js
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
var init_noevent2 = __esm({
  "node_modules/d3-zoom/src/noevent.js"() {
  }
});

// node_modules/d3-zoom/src/zoom.js
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e3 = this;
  if (e3 instanceof SVGElement) {
    e3 = e3.ownerSVGElement || e3;
    if (e3.hasAttribute("viewBox")) {
      e3 = e3.viewBox.baseVal;
      return [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]];
    }
    return [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]];
  }
  return [[0, 0], [e3.clientWidth, e3.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity4;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter3 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point6, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point6, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k2, p, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function(selection2, k2, p, event) {
    zoom.transform(selection2, function() {
      var e3 = extent.apply(this, arguments), t03 = this.__zoom, p0 = p == null ? centroid(e3) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t03.invert(p0), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate(scale(t03, k1), p0, p1), e3, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function(selection2, x2, y2, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 === "function" ? x2.apply(this, arguments) : x2,
        typeof y2 === "function" ? y2.apply(this, arguments) : y2
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x2, y2, p, event) {
    zoom.transform(selection2, function() {
      var e3 = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e3) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity4.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
      ), e3, translateExtent);
    }, p, event);
  };
  function scale(transform2, k2) {
    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition2, transform2, point6, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e3 = extent.apply(that, args), p = point6 == null ? centroid(e3) : typeof point6 === "function" ? point6.apply(that, args) : point6, w = Math.max(e3[1][0] - e3[0][0], e3[1][1] - e3[0][1]), a2 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a2.invert(p).concat(w / a2.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1)
          t = b;
        else {
          var l = i(t), k2 = w / l[2];
          t = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var g = gesture(this, args).event(event), t = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k2)
      return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default2(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter3.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    nodrag_default(event.view);
    nopropagation(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event2) {
      noevent_default2(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent_default2(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var t03 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p0), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale(t03, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent_default2(event);
    if (duration > 0)
      select_default2(this).transition().duration(duration).call(schedule, t13, p0, event);
    else
      select_default2(this).call(zoom.transform, t13, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent_default2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p)
            p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default4(+_), zoom) : wheelDelta;
  };
  zoom.filter = function(_) {
    return arguments.length ? (filter3 = typeof _ === "function" ? _ : constant_default4(!!_), zoom) : filter3;
  };
  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), zoom) : touchable;
  };
  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };
  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}
var init_zoom2 = __esm({
  "node_modules/d3-zoom/src/zoom.js"() {
    init_src12();
    init_src14();
    init_src7();
    init_src13();
    init_src17();
    init_constant5();
    init_event();
    init_transform2();
    init_noevent2();
  }
});

// node_modules/d3-zoom/src/index.js
var src_exports8 = {};
__export(src_exports8, {
  ZoomTransform: () => Transform,
  zoom: () => zoom_default2,
  zoomIdentity: () => identity4,
  zoomTransform: () => transform
});
var init_src18 = __esm({
  "node_modules/d3-zoom/src/index.js"() {
    init_zoom2();
    init_transform2();
  }
});

// node_modules/function-plot/dist/helpers/annotations.js
var require_annotations = __commonJS({
  "node_modules/function-plot/dist/helpers/annotations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_shape_1 = (init_src2(), __toCommonJS(src_exports));
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    function annotations(options) {
      const xScale = options.owner.meta.xScale;
      const yScale = options.owner.meta.yScale;
      const line = (0, d3_shape_1.line)().x(function(d) {
        return d[0];
      }).y(function(d) {
        return d[1];
      });
      return function(parentSelection) {
        parentSelection.each(function() {
          const current = (0, d3_selection_1.select)(this);
          const selection2 = current.selectAll("g.annotations").data(function(d) {
            return d.annotations || [];
          });
          const enter = selection2.enter().append("g").attr("class", "annotations");
          const yRange = yScale.range();
          const xRange = xScale.range();
          const path2 = selection2.merge(enter).selectAll("path").data(function(d) {
            if ("x" in d) {
              return [[[0, yRange[0]], [0, yRange[1]]]];
            } else {
              return [[[xRange[0], 0], [xRange[1], 0]]];
            }
          });
          path2.enter().append("path").attr("stroke", "#eee").attr("d", line);
          path2.exit().remove();
          const text = selection2.merge(enter).selectAll("text").data(function(d) {
            return [
              {
                text: d.text || "",
                hasX: "x" in d
              }
            ];
          });
          text.enter().append("text").attr("y", function(d) {
            return d.hasX ? 3 : 0;
          }).attr("x", function(d) {
            return d.hasX ? 0 : 3;
          }).attr("dy", function(d) {
            return d.hasX ? 5 : -5;
          }).attr("text-anchor", function(d) {
            return d.hasX ? "end" : "";
          }).attr("transform", function(d) {
            return d.hasX ? "rotate(-90)" : "";
          }).text(function(d) {
            return d.text;
          });
          text.exit().remove();
          selection2.merge(enter).attr("transform", function(d) {
            if ("x" in d) {
              return "translate(" + xScale(d.x) + ", 0)";
            } else {
              return "translate(0, " + yScale(d.y) + ")";
            }
          });
          selection2.exit().remove();
        });
      };
    }
    exports.default = annotations;
  }
});

// node_modules/function-plot/dist/globals.js
var require_globals = __commonJS({
  "node_modules/function-plot/dist/globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.registerGraphType = void 0;
    var d3_color_1 = (init_src6(), __toCommonJS(src_exports3));
    var Globals = {
      COLORS: [
        "steelblue",
        "red",
        "#05b378",
        "orange",
        "#4040e8",
        "yellow",
        "brown",
        "magenta",
        "cyan"
      ].map(function(v) {
        return (0, d3_color_1.hsl)(v);
      }),
      DEFAULT_WIDTH: 550,
      DEFAULT_HEIGHT: 350,
      DEFAULT_ITERATIONS: null,
      TIP_X_EPS: 1,
      MAX_ITERATIONS: 0,
      graphTypes: {}
    };
    Globals.MAX_ITERATIONS = Globals.DEFAULT_WIDTH * 10;
    function registerGraphType(graphType, graphTypeBulder) {
      if (Object.hasOwn(Globals.graphTypes, graphType)) {
        throw new Error(`registerGraphType: graphType ${graphType} is already registered.`);
      }
      Globals.graphTypes[graphType] = graphTypeBulder;
    }
    exports.registerGraphType = registerGraphType;
    exports.default = Globals;
  }
});

// node_modules/function-plot/dist/utils.js
var require_utils = __commonJS({
  "node_modules/function-plot/dist/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals_1 = __importDefault(require_globals());
    var utils = {
      linspace: function(lo, hi, n) {
        const step = (hi - lo) / (n - 1);
        return Array.from({ length: n }, (_, i) => lo + step * i);
      },
      logspace: function(lo, hi, n) {
        return this.linspace(lo, hi, n).map((x2) => Math.pow(10, x2));
      },
      isValidNumber: function(v) {
        return typeof v === "number" && !isNaN(v);
      },
      space: function(axis2, range2, n) {
        const lo = range2[0];
        const hi = range2[1];
        if (axis2.type === "log") {
          return this.logspace(Math.log10(lo), Math.log10(hi), n);
        }
        return this.linspace(lo, hi, n);
      },
      getterSetter: function(config4, option) {
        const me = this;
        this[option] = function(value) {
          if (!arguments.length) {
            return config4[option];
          }
          config4[option] = value;
          return me;
        };
      },
      sgn: function(v) {
        if (v < 0) {
          return -1;
        }
        if (v > 0) {
          return 1;
        }
        return 0;
      },
      clamp: function(v, vMin, vMax) {
        if (v < vMin)
          return vMin;
        if (v > vMax)
          return vMax;
        return v;
      },
      color: function(data, index) {
        const indexModLenColor = index % globals_1.default.COLORS.length;
        return data.color || globals_1.default.COLORS[indexModLenColor].hex();
      },
      /**
       * Infinity is a value that is close to Infinity but not Infinity, it can fit in a JS number.
       */
      infinity: function() {
        return 9007199254740991;
      }
    };
    exports.default = utils;
  }
});

// node_modules/mr-parser/lib/token-type.js
var require_token_type = __commonJS({
  "node_modules/mr-parser/lib/token-type.js"(exports, module2) {
    module2.exports = {
      EOF: 0,
      DELIMITER: 1,
      NUMBER: 2,
      STRING: 3,
      SYMBOL: 4
    };
  }
});

// node_modules/mr-parser/lib/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/mr-parser/lib/Lexer.js"(exports, module2) {
    var tokenType = require_token_type();
    var ESCAPES = {
      "n": "\n",
      "f": "\f",
      "r": "\r",
      "t": "	",
      "v": "\v",
      "'": "'",
      '"': '"'
    };
    var DELIMITERS = {
      ",": true,
      "(": true,
      ")": true,
      "[": true,
      "]": true,
      ";": true,
      // unary
      "~": true,
      // factorial
      "!": true,
      // arithmetic operators
      "+": true,
      "-": true,
      "*": true,
      "/": true,
      "%": true,
      "^": true,
      "**": true,
      // python power like
      // misc operators
      "|": true,
      // bitwise or
      "&": true,
      // bitwise and
      "^|": true,
      // bitwise xor
      "=": true,
      ":": true,
      "?": true,
      "||": true,
      // logical or
      "&&": true,
      // logical and
      "xor": true,
      // logical xor
      // relational
      "==": true,
      "!=": true,
      "===": true,
      "!==": true,
      "<": true,
      ">": true,
      ">=": true,
      "<=": true,
      // shifts
      ">>>": true,
      "<<": true,
      ">>": true
    };
    function isDigit(c2) {
      return c2 >= "0" && c2 <= "9";
    }
    function isIdentifier(c2) {
      return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_";
    }
    function isWhitespace(c2) {
      return c2 === " " || c2 === "\r" || c2 === "	" || c2 === "\n" || c2 === "\v" || c2 === "\xA0";
    }
    function isDelimiter(str) {
      return DELIMITERS[str];
    }
    function isQuote(c2) {
      return c2 === "'" || c2 === '"';
    }
    function Lexer() {
    }
    Lexer.prototype.throwError = function(message, index) {
      index = typeof index === "undefined" ? this.index : index;
      var error = new Error(message + " at index " + index);
      error.index = index;
      error.description = message;
      throw error;
    };
    Lexer.prototype.lex = function(text) {
      this.text = text;
      this.index = 0;
      this.tokens = [];
      while (this.index < this.text.length) {
        while (isWhitespace(this.peek())) {
          this.consume();
        }
        var c2 = this.peek();
        var c22 = c2 + this.peek(1);
        var c3 = c22 + this.peek(2);
        if (isDelimiter(c3)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c3
          });
          this.consume();
          this.consume();
          this.consume();
        } else if (isDelimiter(c22)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c22
          });
          this.consume();
          this.consume();
        } else if (isDelimiter(c2)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c2
          });
          this.consume();
        } else if (isDigit(c2) || c2 === "." && isDigit(this.peek(1))) {
          this.tokens.push({
            type: tokenType.NUMBER,
            value: this.readNumber()
          });
        } else if (isQuote(c2)) {
          this.tokens.push({
            type: tokenType.STRING,
            value: this.readString()
          });
        } else if (isIdentifier(c2)) {
          this.tokens.push({
            type: tokenType.SYMBOL,
            value: this.readIdentifier()
          });
        } else {
          this.throwError("unexpected character " + c2);
        }
      }
      this.tokens.push({ type: tokenType.EOF });
      return this.tokens;
    };
    Lexer.prototype.peek = function(nth) {
      nth = nth || 0;
      if (this.index + nth >= this.text.length) {
        return;
      }
      return this.text.charAt(this.index + nth);
    };
    Lexer.prototype.consume = function() {
      var current = this.peek();
      this.index += 1;
      return current;
    };
    Lexer.prototype.readNumber = function() {
      var number5 = "";
      if (this.peek() === ".") {
        number5 += this.consume();
        if (!isDigit(this.peek())) {
          this.throwError("number expected");
        }
      } else {
        while (isDigit(this.peek())) {
          number5 += this.consume();
        }
        if (this.peek() === ".") {
          number5 += this.consume();
        }
      }
      while (isDigit(this.peek())) {
        number5 += this.consume();
      }
      if (this.peek() === "e" || this.peek() === "E") {
        number5 += this.consume();
        if (!(isDigit(this.peek()) || this.peek() === "+" || this.peek() === "-")) {
          this.throwError();
        }
        if (this.peek() === "+" || this.peek() === "-") {
          number5 += this.consume();
        }
        if (!isDigit(this.peek())) {
          this.throwError("number expected");
        }
        while (isDigit(this.peek())) {
          number5 += this.consume();
        }
      }
      return number5;
    };
    Lexer.prototype.readIdentifier = function() {
      var text = "";
      while (isIdentifier(this.peek()) || isDigit(this.peek())) {
        text += this.consume();
      }
      return text;
    };
    Lexer.prototype.readString = function() {
      var quote = this.consume();
      var string = "";
      var escape2;
      while (true) {
        var c2 = this.consume();
        if (!c2) {
          this.throwError("string is not closed");
        }
        if (escape2) {
          if (c2 === "u") {
            var hex2 = this.text.substring(this.index + 1, this.index + 5);
            if (!hex2.match(/[\da-f]{4}/i)) {
              this.throwError("invalid unicode escape");
            }
            this.index += 4;
            string += String.fromCharCode(parseInt(hex2, 16));
          } else {
            var replacement = ESCAPES[c2];
            if (replacement) {
              string += replacement;
            } else {
              string += c2;
            }
          }
          escape2 = false;
        } else if (c2 === quote) {
          break;
        } else if (c2 === "\\") {
          escape2 = true;
        } else {
          string += c2;
        }
      }
      return string;
    };
    module2.exports = Lexer;
  }
});

// node_modules/mr-parser/lib/node/Node.js
var require_Node = __commonJS({
  "node_modules/mr-parser/lib/node/Node.js"(exports, module2) {
    function Node() {
    }
    Node.prototype.type = "Node";
    module2.exports = Node;
  }
});

// node_modules/mr-parser/lib/node/ConstantNode.js
var require_ConstantNode = __commonJS({
  "node_modules/mr-parser/lib/node/ConstantNode.js"(exports, module2) {
    var Node = require_Node();
    var SUPPORTED_TYPES = {
      number: true,
      string: true,
      "boolean": true,
      "undefined": true,
      "null": true
    };
    function ConstantNode(value, type) {
      if (!SUPPORTED_TYPES[type]) {
        throw Error("unsupported type '" + type + "'");
      }
      this.value = value;
      this.valueType = type;
    }
    ConstantNode.prototype = Object.create(Node.prototype);
    ConstantNode.prototype.type = "ConstantNode";
    module2.exports = ConstantNode;
  }
});

// node_modules/mr-parser/lib/node/OperatorNode.js
var require_OperatorNode = __commonJS({
  "node_modules/mr-parser/lib/node/OperatorNode.js"(exports, module2) {
    var Node = require_Node();
    function OperatorNode(op, args) {
      this.op = op;
      this.args = args || [];
    }
    OperatorNode.prototype = Object.create(Node.prototype);
    OperatorNode.prototype.type = "OperatorNode";
    module2.exports = OperatorNode;
  }
});

// node_modules/mr-parser/lib/node/UnaryNode.js
var require_UnaryNode = __commonJS({
  "node_modules/mr-parser/lib/node/UnaryNode.js"(exports, module2) {
    var Node = require_Node();
    function UnaryNode(op, argument) {
      this.op = op;
      this.argument = argument;
    }
    UnaryNode.prototype = Object.create(Node.prototype);
    UnaryNode.prototype.type = "UnaryNode";
    module2.exports = UnaryNode;
  }
});

// node_modules/mr-parser/lib/node/SymbolNode.js
var require_SymbolNode = __commonJS({
  "node_modules/mr-parser/lib/node/SymbolNode.js"(exports, module2) {
    var Node = require_Node();
    function SymbolNode(name310) {
      this.name = name310;
    }
    SymbolNode.prototype = Object.create(Node.prototype);
    SymbolNode.prototype.type = "SymbolNode";
    module2.exports = SymbolNode;
  }
});

// node_modules/mr-parser/lib/node/FunctionNode.js
var require_FunctionNode = __commonJS({
  "node_modules/mr-parser/lib/node/FunctionNode.js"(exports, module2) {
    var Node = require_Node();
    function FunctionNode(name310, args) {
      this.name = name310;
      this.args = args;
    }
    FunctionNode.prototype = Object.create(Node.prototype);
    FunctionNode.prototype.type = "FunctionNode";
    module2.exports = FunctionNode;
  }
});

// node_modules/mr-parser/lib/node/ArrayNode.js
var require_ArrayNode = __commonJS({
  "node_modules/mr-parser/lib/node/ArrayNode.js"(exports, module2) {
    var Node = require_Node();
    function ArrayNode(nodes) {
      this.nodes = nodes;
    }
    ArrayNode.prototype = Object.create(Node.prototype);
    ArrayNode.prototype.type = "ArrayNode";
    module2.exports = ArrayNode;
  }
});

// node_modules/mr-parser/lib/node/ConditionalNode.js
var require_ConditionalNode = __commonJS({
  "node_modules/mr-parser/lib/node/ConditionalNode.js"(exports, module2) {
    var Node = require_Node();
    function ConditionalNode(predicate, truthy, falsy) {
      this.condition = predicate;
      this.trueExpr = truthy;
      this.falseExpr = falsy;
    }
    ConditionalNode.prototype = Object.create(Node.prototype);
    ConditionalNode.prototype.type = "ConditionalNode";
    module2.exports = ConditionalNode;
  }
});

// node_modules/mr-parser/lib/node/AssignmentNode.js
var require_AssignmentNode = __commonJS({
  "node_modules/mr-parser/lib/node/AssignmentNode.js"(exports, module2) {
    var Node = require_Node();
    function AssignmentNode(name310, expr) {
      this.name = name310;
      this.expr = expr;
    }
    AssignmentNode.prototype = Object.create(Node.prototype);
    AssignmentNode.prototype.type = "AssignmentNode";
    module2.exports = AssignmentNode;
  }
});

// node_modules/mr-parser/lib/node/BlockNode.js
var require_BlockNode = __commonJS({
  "node_modules/mr-parser/lib/node/BlockNode.js"(exports, module2) {
    var Node = require_Node();
    function BlockNode(blocks) {
      this.blocks = blocks;
    }
    BlockNode.prototype = Object.create(Node.prototype);
    BlockNode.prototype.type = "BlockNode";
    module2.exports = BlockNode;
  }
});

// node_modules/mr-parser/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/mr-parser/lib/Parser.js"(exports, module2) {
    var tokenType = require_token_type();
    var Lexer = require_Lexer();
    var ConstantNode = require_ConstantNode();
    var OperatorNode = require_OperatorNode();
    var UnaryNode = require_UnaryNode();
    var SymbolNode = require_SymbolNode();
    var FunctionNode = require_FunctionNode();
    var ArrayNode = require_ArrayNode();
    var ConditionalNode = require_ConditionalNode();
    var AssignmentNode = require_AssignmentNode();
    var BlockNode = require_BlockNode();
    function Parser() {
      this.lexer = new Lexer();
      this.tokens = null;
    }
    Parser.prototype.current = function() {
      return this.tokens[0];
    };
    Parser.prototype.next = function() {
      return this.tokens[1];
    };
    Parser.prototype.peek = function() {
      if (this.tokens.length) {
        var first = this.tokens[0];
        for (var i = 0; i < arguments.length; i += 1) {
          if (first.value === arguments[i]) {
            return true;
          }
        }
      }
    };
    Parser.prototype.consume = function(e3) {
      return this.tokens.shift();
    };
    Parser.prototype.expect = function(e3) {
      if (!this.peek(e3)) {
        throw Error("expected " + e3);
      }
      return this.consume();
    };
    Parser.prototype.isEOF = function() {
      return this.current().type === tokenType.EOF;
    };
    Parser.prototype.parse = function(text) {
      this.tokens = this.lexer.lex(text);
      return this.program();
    };
    Parser.prototype.program = function() {
      var blocks = [];
      while (!this.isEOF()) {
        blocks.push(this.assignment());
        if (this.peek(";")) {
          this.consume();
        }
      }
      this.end();
      return new BlockNode(blocks);
    };
    Parser.prototype.assignment = function() {
      var left2 = this.ternary();
      if (left2 instanceof SymbolNode && this.peek("=")) {
        this.consume();
        return new AssignmentNode(left2.name, this.assignment());
      }
      return left2;
    };
    Parser.prototype.ternary = function() {
      var predicate = this.logicalOR();
      if (this.peek("?")) {
        this.consume();
        var truthy = this.ternary();
        this.expect(":");
        var falsy = this.ternary();
        return new ConditionalNode(predicate, truthy, falsy);
      }
      return predicate;
    };
    Parser.prototype.logicalOR = function() {
      var left2 = this.logicalXOR();
      if (this.peek("||")) {
        var op = this.consume();
        var right2 = this.logicalOR();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.logicalXOR = function() {
      var left2 = this.logicalAND();
      if (this.current().value === "xor") {
        var op = this.consume();
        var right2 = this.logicalXOR();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.logicalAND = function() {
      var left2 = this.bitwiseOR();
      if (this.peek("&&")) {
        var op = this.consume();
        var right2 = this.logicalAND();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.bitwiseOR = function() {
      var left2 = this.bitwiseXOR();
      if (this.peek("|")) {
        var op = this.consume();
        var right2 = this.bitwiseOR();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.bitwiseXOR = function() {
      var left2 = this.bitwiseAND();
      if (this.peek("^|")) {
        var op = this.consume();
        var right2 = this.bitwiseXOR();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.bitwiseAND = function() {
      var left2 = this.relational();
      if (this.peek("&")) {
        var op = this.consume();
        var right2 = this.bitwiseAND();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.relational = function() {
      var left2 = this.shift();
      if (this.peek("==", "===", "!=", "!==", ">=", "<=", ">", "<")) {
        var op = this.consume();
        var right2 = this.shift();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.shift = function() {
      var left2 = this.additive();
      if (this.peek(">>", "<<", ">>>")) {
        var op = this.consume();
        var right2 = this.shift();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.additive = function() {
      var left2 = this.multiplicative();
      while (this.peek("+", "-")) {
        var op = this.consume();
        left2 = new OperatorNode(op.value, [left2, this.multiplicative()]);
      }
      return left2;
    };
    Parser.prototype.multiplicative = function() {
      var op, right2;
      var left2 = this.unary();
      while (this.peek("*", "/", "%")) {
        op = this.consume();
        left2 = new OperatorNode(op.value, [left2, this.unary()]);
      }
      if (this.current().type === tokenType.SYMBOL || this.peek("(") || !(left2.type instanceof ConstantNode) && this.current().type === tokenType.NUMBER) {
        right2 = this.multiplicative();
        return new OperatorNode("*", [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.unary = function() {
      if (this.peek("-", "+", "~")) {
        var op = this.consume();
        var right2 = this.unary();
        return new UnaryNode(op.value, right2);
      }
      return this.pow();
    };
    Parser.prototype.pow = function() {
      var left2 = this.factorial();
      if (this.peek("^", "**")) {
        var op = this.consume();
        var right2 = this.unary();
        return new OperatorNode(op.value, [left2, right2]);
      }
      return left2;
    };
    Parser.prototype.factorial = function() {
      var left2 = this.symbol();
      if (this.peek("!")) {
        var op = this.consume();
        return new OperatorNode(op.value, [left2]);
      }
      return left2;
    };
    Parser.prototype.symbol = function() {
      var current = this.current();
      if (current.type === tokenType.SYMBOL) {
        var symbol = this.consume();
        var node = this.functionCall(symbol);
        return node;
      }
      return this.string();
    };
    Parser.prototype.functionCall = function(symbolToken) {
      var name310 = symbolToken.value;
      if (this.peek("(")) {
        this.consume();
        var params = [];
        while (!this.peek(")") && !this.isEOF()) {
          params.push(this.assignment());
          if (this.peek(",")) {
            this.consume();
          }
        }
        this.expect(")");
        return new FunctionNode(name310, params);
      }
      return new SymbolNode(name310);
    };
    Parser.prototype.string = function() {
      if (this.current().type === tokenType.STRING) {
        return new ConstantNode(this.consume().value, "string");
      }
      return this.array();
    };
    Parser.prototype.array = function() {
      if (this.peek("[")) {
        this.consume();
        var params = [];
        while (!this.peek("]") && !this.isEOF()) {
          params.push(this.assignment());
          if (this.peek(",")) {
            this.consume();
          }
        }
        this.expect("]");
        return new ArrayNode(params);
      }
      return this.number();
    };
    Parser.prototype.number = function() {
      var token = this.current();
      if (token.type === tokenType.NUMBER) {
        return new ConstantNode(this.consume().value, "number");
      }
      return this.parentheses();
    };
    Parser.prototype.parentheses = function() {
      var token = this.current();
      if (token.value === "(") {
        this.consume();
        var left2 = this.assignment();
        this.expect(")");
        return left2;
      }
      return this.end();
    };
    Parser.prototype.end = function() {
      var token = this.current();
      if (token.type !== tokenType.EOF) {
        throw Error("unexpected end of expression");
      }
    };
    module2.exports = Parser;
  }
});

// node_modules/mr-parser/lib/node/index.js
var require_node = __commonJS({
  "node_modules/mr-parser/lib/node/index.js"(exports, module2) {
    module2.exports = {
      ArrayNode: require_ArrayNode(),
      AssignmentNode: require_AssignmentNode(),
      BlockNode: require_BlockNode(),
      ConditionalNode: require_ConditionalNode(),
      ConstantNode: require_ConstantNode(),
      FunctionNode: require_FunctionNode(),
      Node: require_Node(),
      OperatorNode: require_OperatorNode(),
      SymbolNode: require_SymbolNode(),
      UnaryNode: require_UnaryNode()
    };
  }
});

// node_modules/mr-parser/index.js
var require_mr_parser = __commonJS({
  "node_modules/mr-parser/index.js"(exports, module2) {
    "use strict";
    module2.exports.Lexer = require_Lexer();
    module2.exports.Parser = require_Parser();
    module2.exports.nodeTypes = require_node();
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = function isArray3(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name310) {
      if (name310 === "__proto__") {
        if (!hasOwn.call(obj, name310)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name310).value;
        }
      }
      return obj[name310];
    };
    module2.exports = function extend3() {
      var options, name310, src, copy3, copyIsArray, clone4;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name310 in options) {
            src = getProperty(target, name310);
            copy3 = getProperty(options, name310);
            if (target !== copy3) {
              if (deep && copy3 && (isPlainObject2(copy3) || (copyIsArray = isArray2(copy3)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone4 = src && isArray2(src) ? src : [];
                } else {
                  clone4 = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name: name310, newValue: extend3(deep, clone4, copy3) });
              } else if (typeof copy3 !== "undefined") {
                setProperty(target, { name: name310, newValue: copy3 });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/math-codegen/lib/node/ArrayNode.js
var require_ArrayNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/ArrayNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      var self2 = this;
      var arr = [];
      this.rawify(this.options.rawArrayExpressionElements, function() {
        arr = node.nodes.map(function(el) {
          return self2.next(el);
        });
      });
      var arrString = "[" + arr.join(",") + "]";
      if (this.options.raw) {
        return arrString;
      }
      return this.options.factory + "(" + arrString + ")";
    };
  }
});

// node_modules/math-codegen/lib/node/AssignmentNode.js
var require_AssignmentNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/AssignmentNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      return 'scope["' + node.name + '"] = ' + this.next(node.expr);
    };
  }
});

// node_modules/math-codegen/lib/node/ConditionalNode.js
var require_ConditionalNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/ConditionalNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      var condition = "!!(" + this.next(node.condition) + ")";
      var trueExpr = this.next(node.trueExpr);
      var falseExpr = this.next(node.falseExpr);
      return "(" + condition + " ? (" + trueExpr + ") : (" + falseExpr + ") )";
    };
  }
});

// node_modules/math-codegen/lib/node/ConstantNode.js
var require_ConstantNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/ConstantNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      if (this.options.raw) {
        return node.value;
      }
      return this.options.factory + "(" + node.value + ")";
    };
  }
});

// node_modules/math-codegen/lib/node/FunctionNode.js
var require_FunctionNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/FunctionNode.js"(exports, module2) {
    "use strict";
    var SymbolNode = require_mr_parser().nodeTypes.SymbolNode;
    var functionProxy = function(node) {
      return "$$mathCodegen.functionProxy(" + this.next(new SymbolNode(node.name)) + ', "' + node.name + '")';
    };
    module2.exports = function(node) {
      var self2 = this;
      var method = functionProxy.call(this, node);
      var args = [];
      this.rawify(this.options.rawCallExpressionElements, function() {
        args = node.args.map(function(arg) {
          return self2.next(arg);
        });
      });
      return method + "(" + args.join(", ") + ")";
    };
    module2.exports.functionProxy = functionProxy;
  }
});

// node_modules/math-codegen/lib/misc/Operators.js
var require_Operators = __commonJS({
  "node_modules/math-codegen/lib/misc/Operators.js"(exports, module2) {
    "use strict";
    module2.exports = {
      // arithmetic
      "+": "add",
      "-": "sub",
      "*": "mul",
      "/": "div",
      "^": "pow",
      "%": "mod",
      "!": "factorial",
      // misc operators
      "|": "bitwiseOR",
      // bitwise or
      "^|": "bitwiseXOR",
      // bitwise xor
      "&": "bitwiseAND",
      // bitwise and
      "||": "logicalOR",
      // logical or
      "xor": "logicalXOR",
      // logical xor
      "&&": "logicalAND",
      // logical and
      // comparison
      "<": "lessThan",
      ">": "greaterThan",
      "<=": "lessEqualThan",
      ">=": "greaterEqualThan",
      "===": "strictlyEqual",
      "==": "equal",
      "!==": "strictlyNotEqual",
      "!=": "notEqual",
      // shift
      ">>": "shiftRight",
      "<<": "shiftLeft",
      ">>>": "unsignedRightShift"
    };
  }
});

// node_modules/math-codegen/lib/node/OperatorNode.js
var require_OperatorNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/OperatorNode.js"(exports, module2) {
    "use strict";
    var Operators = require_Operators();
    module2.exports = function(node) {
      if (this.options.raw) {
        return ["(" + this.next(node.args[0]), node.op, this.next(node.args[1]) + ")"].join(" ");
      }
      var namedOperator = Operators[node.op];
      if (!namedOperator) {
        throw TypeError("unidentified operator");
      }
      return this.FunctionNode({
        name: namedOperator,
        args: node.args
      });
    };
  }
});

// node_modules/math-codegen/lib/node/SymbolNode.js
var require_SymbolNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/SymbolNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      var id2 = node.name;
      return '$$mathCodegen.getProperty("' + id2 + '", scope, ns)';
    };
  }
});

// node_modules/math-codegen/lib/misc/UnaryOperators.js
var require_UnaryOperators = __commonJS({
  "node_modules/math-codegen/lib/misc/UnaryOperators.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "+": "positive",
      "-": "negative",
      "~": "oneComplement"
    };
  }
});

// node_modules/math-codegen/lib/node/UnaryNode.js
var require_UnaryNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/UnaryNode.js"(exports, module2) {
    "use strict";
    var UnaryOperators = require_UnaryOperators();
    module2.exports = function(node) {
      if (this.options.raw) {
        return node.op + this.next(node.argument);
      }
      if (!(node.op in UnaryOperators)) {
        throw new SyntaxError(node.op + " not implemented");
      }
      var namedOperator = UnaryOperators[node.op];
      return this.FunctionNode({
        name: namedOperator,
        args: [node.argument]
      });
    };
  }
});

// node_modules/math-codegen/lib/Interpreter.js
var require_Interpreter = __commonJS({
  "node_modules/math-codegen/lib/Interpreter.js"(exports, module2) {
    "use strict";
    var extend3 = require_extend();
    var types = {
      ArrayNode: require_ArrayNode2(),
      AssignmentNode: require_AssignmentNode2(),
      ConditionalNode: require_ConditionalNode2(),
      ConstantNode: require_ConstantNode2(),
      FunctionNode: require_FunctionNode2(),
      OperatorNode: require_OperatorNode2(),
      SymbolNode: require_SymbolNode2(),
      UnaryNode: require_UnaryNode2()
    };
    var Interpreter = function(owner, options) {
      this.owner = owner;
      this.options = extend3({
        factory: "ns.factory",
        raw: false,
        rawArrayExpressionElements: true,
        rawCallExpressionElements: false
      }, options);
    };
    extend3(Interpreter.prototype, types);
    Interpreter.prototype.next = function(node) {
      if (!(node.type in this)) {
        throw new TypeError("the node type " + node.type + " is not implemented");
      }
      return this[node.type](node);
    };
    Interpreter.prototype.rawify = function(test, fn) {
      var oldRaw = this.options.raw;
      if (test) {
        this.options.raw = true;
      }
      fn();
      if (test) {
        this.options.raw = oldRaw;
      }
    };
    module2.exports = Interpreter;
  }
});

// node_modules/math-codegen/lib/CodeGenerator.js
var require_CodeGenerator = __commonJS({
  "node_modules/math-codegen/lib/CodeGenerator.js"(exports, module2) {
    "use strict";
    var Parser = require_mr_parser().Parser;
    var Interpreter = require_Interpreter();
    var extend3 = require_extend();
    function CodeGenerator(options, defs) {
      this.statements = [];
      this.defs = defs || {};
      this.interpreter = new Interpreter(this, options);
    }
    CodeGenerator.prototype.setDefs = function(defs) {
      this.defs = extend3(this.defs, defs);
      return this;
    };
    CodeGenerator.prototype.compile = function(namespace) {
      if (!namespace || !(typeof namespace === "object" || typeof namespace === "function")) {
        throw TypeError("namespace must be an object");
      }
      if (typeof namespace.factory !== "function") {
        throw TypeError("namespace.factory must be a function");
      }
      this.defs.ns = namespace;
      this.defs.$$mathCodegen = {
        getProperty: function(symbol, scope, ns) {
          if (symbol in scope) {
            return scope[symbol];
          }
          if (symbol in ns) {
            return ns[symbol];
          }
          throw SyntaxError('symbol "' + symbol + '" is undefined');
        },
        functionProxy: function(fn, name310) {
          if (typeof fn !== "function") {
            throw SyntaxError('symbol "' + name310 + '" must be a function');
          }
          return fn;
        }
      };
      this.defs.$$processScope = this.defs.$$processScope || function() {
      };
      var defsCode = Object.keys(this.defs).map(function(name310) {
        return "var " + name310 + ' = defs["' + name310 + '"]';
      });
      if (!this.statements.length) {
        throw Error("there are no statements saved in this generator, make sure you parse an expression before compiling it");
      }
      this.statements[this.statements.length - 1] = "return " + this.statements[this.statements.length - 1];
      var code = this.statements.join(";");
      var factoryCode = defsCode.join("\n") + "\n" + [
        "return {",
        "  eval: function (scope) {",
        "    scope = scope || {}",
        "    $$processScope(scope)",
        "    " + code,
        "  },",
        "  code: '" + code + "'",
        "}"
      ].join("\n");
      var factory2 = new Function("defs", factoryCode);
      return factory2(this.defs);
    };
    CodeGenerator.prototype.parse = function(code) {
      var self2 = this;
      var program = new Parser().parse(code);
      this.statements = program.blocks.map(function(statement) {
        return self2.interpreter.next(statement);
      });
      return this;
    };
    module2.exports = CodeGenerator;
  }
});

// node_modules/math-codegen/index.js
var require_math_codegen = __commonJS({
  "node_modules/math-codegen/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_CodeGenerator();
  }
});

// node_modules/built-in-math-eval/lib/adapter.js
var require_adapter = __commonJS({
  "node_modules/built-in-math-eval/lib/adapter.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var math = Object.create(Math);
      math.factory = function(a2) {
        if (typeof a2 !== "number") {
          throw new TypeError("built-in math factory only accepts numbers");
        }
        return Number(a2);
      };
      math.add = function(a2, b) {
        return a2 + b;
      };
      math.sub = function(a2, b) {
        return a2 - b;
      };
      math.mul = function(a2, b) {
        return a2 * b;
      };
      math.div = function(a2, b) {
        return a2 / b;
      };
      math.mod = function(a2, b) {
        return a2 % b;
      };
      math.factorial = function(a2) {
        var res = 1;
        for (var i = 2; i <= a2; i += 1) {
          res *= i;
        }
        return res;
      };
      math.nthRoot = function(a2, root2) {
        var inv = root2 < 0;
        if (inv) {
          root2 = -root2;
        }
        if (root2 === 0) {
          throw new Error("Root must be non-zero");
        }
        if (a2 < 0 && Math.abs(root2) % 2 !== 1) {
          throw new Error("Root must be odd when a is negative.");
        }
        if (a2 === 0) {
          return 0;
        }
        if (!isFinite(a2)) {
          return inv ? 0 : a2;
        }
        var x2 = Math.pow(Math.abs(a2), 1 / root2);
        x2 = a2 < 0 ? -x2 : x2;
        return inv ? 1 / x2 : x2;
      };
      math.logicalOR = function(a2, b) {
        return a2 || b;
      };
      math.logicalXOR = function(a2, b) {
        return a2 != b;
      };
      math.logicalAND = function(a2, b) {
        return a2 && b;
      };
      math.bitwiseOR = function(a2, b) {
        return a2 | b;
      };
      math.bitwiseXOR = function(a2, b) {
        return a2 ^ b;
      };
      math.bitwiseAND = function(a2, b) {
        return a2 & b;
      };
      math.lessThan = function(a2, b) {
        return a2 < b;
      };
      math.lessEqualThan = function(a2, b) {
        return a2 <= b;
      };
      math.greaterThan = function(a2, b) {
        return a2 > b;
      };
      math.greaterEqualThan = function(a2, b) {
        return a2 >= b;
      };
      math.equal = function(a2, b) {
        return a2 == b;
      };
      math.strictlyEqual = function(a2, b) {
        return a2 === b;
      };
      math.notEqual = function(a2, b) {
        return a2 != b;
      };
      math.strictlyNotEqual = function(a2, b) {
        return a2 !== b;
      };
      math.shiftRight = function(a2, b) {
        return a2 >> b;
      };
      math.shiftLeft = function(a2, b) {
        return a2 << b;
      };
      math.unsignedRightShift = function(a2, b) {
        return a2 >>> b;
      };
      math.negative = function(a2) {
        return -a2;
      };
      math.positive = function(a2) {
        return a2;
      };
      return math;
    };
  }
});

// node_modules/built-in-math-eval/lib/eval.js
var require_eval = __commonJS({
  "node_modules/built-in-math-eval/lib/eval.js"(exports, module2) {
    "use strict";
    var CodeGenerator = require_math_codegen();
    var math = require_adapter()();
    function processScope(scope) {
      Object.keys(scope).forEach(function(k2) {
        var value = scope[k2];
        scope[k2] = math.factory(value);
      });
    }
    module2.exports = function(expression) {
      return new CodeGenerator().setDefs({
        $$processScope: processScope
      }).parse(expression).compile(math);
    };
    module2.exports.math = math;
  }
});

// node_modules/built-in-math-eval/index.js
var require_built_in_math_eval = __commonJS({
  "node_modules/built-in-math-eval/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_eval();
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ArrayNode.js
var require_ArrayNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ArrayNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      var self2 = this;
      var arr = [];
      this.rawify(this.options.rawArrayExpressionElements, function() {
        arr = node.nodes.map(function(el) {
          return self2.next(el);
        });
      });
      var arrString = "[" + arr.join(",") + "]";
      if (this.options.raw) {
        return arrString;
      }
      return this.options.factory + "(" + arrString + ")";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/AssignmentNode.js
var require_AssignmentNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/AssignmentNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      return 'scope["' + node.name + '"] = ' + this.next(node.expr);
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConditionalNode.js
var require_ConditionalNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConditionalNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      var condition = "!!(" + this.next(node.condition) + ")";
      var trueExpr = this.next(node.trueExpr);
      var falseExpr = this.next(node.falseExpr);
      return "(" + condition + " ? (" + trueExpr + ") : (" + falseExpr + ") )";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConstantNode.js
var require_ConstantNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConstantNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      if (this.options.raw) {
        return node.value;
      }
      return this.options.factory + "(" + node.value + ")";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/FunctionNode.js
var require_FunctionNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/FunctionNode.js"(exports, module2) {
    "use strict";
    var SymbolNode = require_mr_parser().nodeTypes.SymbolNode;
    var functionProxy = function(node) {
      return "$$mathCodegen.functionProxy(" + this.next(new SymbolNode(node.name)) + ', "' + node.name + '")';
    };
    module2.exports = function(node) {
      var self2 = this;
      var method = functionProxy.call(this, node);
      var args = [];
      this.rawify(this.options.rawCallExpressionElements, function() {
        args = node.args.map(function(arg) {
          return self2.next(arg);
        });
      });
      return method + "(" + args.join(", ") + ")";
    };
    module2.exports.functionProxy = functionProxy;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/Operators.js
var require_Operators2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/Operators.js"(exports, module2) {
    "use strict";
    module2.exports = {
      // arithmetic
      "+": "add",
      "-": "sub",
      "*": "mul",
      "/": "div",
      "^": "pow",
      "%": "mod",
      "!": "factorial",
      // misc operators
      "|": "bitwiseOR",
      // bitwise or
      "^|": "bitwiseXOR",
      // bitwise xor
      "&": "bitwiseAND",
      // bitwise and
      "||": "logicalOR",
      // logical or
      "xor": "logicalXOR",
      // logical xor
      "&&": "logicalAND",
      // logical and
      // comparison
      "<": "lessThan",
      ">": "greaterThan",
      "<=": "lessEqualThan",
      ">=": "greaterEqualThan",
      "===": "strictlyEqual",
      "==": "equal",
      "!==": "strictlyNotEqual",
      "!=": "notEqual",
      // shift
      ">>": "shiftRight",
      "<<": "shiftLeft",
      ">>>": "unsignedRightShift"
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/OperatorNode.js
var require_OperatorNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/OperatorNode.js"(exports, module2) {
    "use strict";
    var Operators = require_Operators2();
    module2.exports = function(node) {
      if (this.options.raw) {
        return ["(" + this.next(node.args[0]), node.op, this.next(node.args[1]) + ")"].join(" ");
      }
      var namedOperator = Operators[node.op];
      if (!namedOperator) {
        throw TypeError("unidentified operator");
      }
      return this.FunctionNode({
        name: namedOperator,
        args: node.args
      });
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/SymbolNode.js
var require_SymbolNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/SymbolNode.js"(exports, module2) {
    "use strict";
    module2.exports = function(node) {
      var id2 = node.name;
      return '$$mathCodegen.getProperty("' + id2 + '", scope, ns)';
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/UnaryOperators.js
var require_UnaryOperators2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/UnaryOperators.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "+": "positive",
      "-": "negative",
      "~": "oneComplement"
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/UnaryNode.js
var require_UnaryNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/UnaryNode.js"(exports, module2) {
    "use strict";
    var UnaryOperators = require_UnaryOperators2();
    module2.exports = function(node) {
      if (this.options.raw) {
        return node.op + this.next(node.argument);
      }
      if (!(node.op in UnaryOperators)) {
        throw new SyntaxError(node.op + " not implemented");
      }
      var namedOperator = UnaryOperators[node.op];
      return this.FunctionNode({
        name: namedOperator,
        args: [node.argument]
      });
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/Interpreter.js
var require_Interpreter2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/Interpreter.js"(exports, module2) {
    "use strict";
    var extend3 = require_extend();
    var types = {
      ArrayNode: require_ArrayNode3(),
      AssignmentNode: require_AssignmentNode3(),
      ConditionalNode: require_ConditionalNode3(),
      ConstantNode: require_ConstantNode3(),
      FunctionNode: require_FunctionNode3(),
      OperatorNode: require_OperatorNode3(),
      SymbolNode: require_SymbolNode3(),
      UnaryNode: require_UnaryNode3()
    };
    var Interpreter = function(owner, options) {
      this.owner = owner;
      this.options = extend3({
        factory: "ns.factory",
        raw: false,
        rawArrayExpressionElements: true,
        rawCallExpressionElements: false,
        applyFactoryToScope: false
      }, options);
    };
    extend3(Interpreter.prototype, types);
    Interpreter.prototype.next = function(node) {
      if (!(node.type in this)) {
        throw new TypeError("the node type " + node.type + " is not implemented");
      }
      return this[node.type](node);
    };
    Interpreter.prototype.rawify = function(test, fn) {
      var oldRaw = this.options.raw;
      if (test) {
        this.options.raw = true;
      }
      fn();
      if (test) {
        this.options.raw = oldRaw;
      }
    };
    module2.exports = Interpreter;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/CodeGenerator.js
var require_CodeGenerator2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/CodeGenerator.js"(exports, module2) {
    "use strict";
    var Parser = require_mr_parser().Parser;
    var Interpreter = require_Interpreter2();
    var extend3 = require_extend();
    function CodeGenerator(options, defs) {
      this.statements = [];
      this.defs = defs || {};
      this.interpreter = new Interpreter(this, options);
    }
    CodeGenerator.prototype.setDefs = function(defs) {
      this.defs = extend3(this.defs, defs);
      return this;
    };
    CodeGenerator.prototype.compile = function(namespace) {
      var self2 = this;
      if (!namespace || !(typeof namespace === "object" || typeof namespace === "function")) {
        throw TypeError("namespace must be an object");
      }
      if (typeof namespace.factory !== "function") {
        throw TypeError("namespace.factory must be a function");
      }
      this.defs.ns = namespace;
      this.defs.$$mathCodegen = {
        getProperty: function(symbol, scope, ns) {
          function applyFactoryIfNeeded(value) {
            if (self2.interpreter.options.applyFactoryToScope && typeof value !== "function") {
              return ns.factory(value);
            }
            return value;
          }
          if (symbol in scope) {
            return applyFactoryIfNeeded(scope[symbol]);
          }
          if (symbol in ns) {
            return applyFactoryIfNeeded(ns[symbol]);
          }
          throw SyntaxError('symbol "' + symbol + '" is undefined');
        },
        functionProxy: function(fn, name310) {
          if (typeof fn !== "function") {
            throw SyntaxError('symbol "' + name310 + '" must be a function');
          }
          return fn;
        }
      };
      this.defs.$$processScope = this.defs.$$processScope || function() {
      };
      var defsCode = Object.keys(this.defs).map(function(name310) {
        return "var " + name310 + ' = defs["' + name310 + '"]';
      });
      if (!this.statements.length) {
        throw Error("there are no statements saved in this generator, make sure you parse an expression before compiling it");
      }
      this.statements[this.statements.length - 1] = "return " + this.statements[this.statements.length - 1];
      var code = this.statements.join(";");
      var factoryCode = defsCode.join("\n") + "\n" + [
        "return {",
        "  eval: function (scope) {",
        "    scope = scope || {}",
        "    $$processScope(scope)",
        "    " + code,
        "  },",
        "  code: '" + code + "'",
        "}"
      ].join("\n");
      var factory2 = new Function("defs", factoryCode);
      return factory2(this.defs);
    };
    CodeGenerator.prototype.parse = function(code) {
      var self2 = this;
      var program = new Parser().parse(code);
      this.statements = program.blocks.map(function(statement) {
        return self2.interpreter.next(statement);
      });
      return this;
    };
    module2.exports = CodeGenerator;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/index.js
var require_math_codegen2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_CodeGenerator2();
  }
});

// node_modules/interval-arithmetic/lib/operations/utils.js
var require_utils2 = __commonJS({
  "node_modules/interval-arithmetic/lib/operations/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intervalsOverlap = exports.hasInterval = exports.hasValue = exports.zeroIn = exports.isSingleton = exports.isWhole = exports.isEmpty = exports.isInterval = void 0;
    function isInterval(x2) {
      return typeof x2 === "object" && typeof x2.lo === "number" && typeof x2.hi === "number";
    }
    exports.isInterval = isInterval;
    function isEmpty(i) {
      return i.lo > i.hi;
    }
    exports.isEmpty = isEmpty;
    function isWhole(i) {
      return i.lo === -Infinity && i.hi === Infinity;
    }
    exports.isWhole = isWhole;
    function isSingleton(i) {
      return i.lo === i.hi;
    }
    exports.isSingleton = isSingleton;
    function zeroIn(i) {
      return hasValue(i, 0);
    }
    exports.zeroIn = zeroIn;
    function hasValue(i, value) {
      if (isEmpty(i)) {
        return false;
      }
      return i.lo <= value && value <= i.hi;
    }
    exports.hasValue = hasValue;
    function hasInterval(x2, y2) {
      if (isEmpty(x2)) {
        return true;
      }
      return !isEmpty(y2) && y2.lo <= x2.lo && x2.hi <= y2.hi;
    }
    exports.hasInterval = hasInterval;
    function intervalsOverlap(x2, y2) {
      if (isEmpty(x2) || isEmpty(y2)) {
        return false;
      }
      return x2.lo <= y2.lo && y2.lo <= x2.hi || y2.lo <= x2.lo && x2.lo <= y2.hi;
    }
    exports.intervalsOverlap = intervalsOverlap;
  }
});

// node_modules/double-bits/double.js
var require_double = __commonJS({
  "node_modules/double-bits/double.js"(exports, module2) {
    var hasTypedArrays = false;
    if (typeof Float64Array !== "undefined") {
      DOUBLE_VIEW = new Float64Array(1), UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer);
      DOUBLE_VIEW[0] = 1;
      hasTypedArrays = true;
      if (UINT_VIEW[1] === 1072693248) {
        let toDoubleLE2 = function(lo, hi) {
          UINT_VIEW[0] = lo;
          UINT_VIEW[1] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintLE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[0];
        }, highUintLE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[1];
        };
        toDoubleLE = toDoubleLE2, lowUintLE = lowUintLE2, highUintLE = highUintLE2;
        module2.exports = function doubleBitsLE(n) {
          DOUBLE_VIEW[0] = n;
          return [UINT_VIEW[0], UINT_VIEW[1]];
        };
        module2.exports.pack = toDoubleLE2;
        module2.exports.lo = lowUintLE2;
        module2.exports.hi = highUintLE2;
      } else if (UINT_VIEW[0] === 1072693248) {
        let toDoubleBE2 = function(lo, hi) {
          UINT_VIEW[1] = lo;
          UINT_VIEW[0] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintBE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[1];
        }, highUintBE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[0];
        };
        toDoubleBE = toDoubleBE2, lowUintBE = lowUintBE2, highUintBE = highUintBE2;
        module2.exports = function doubleBitsBE(n) {
          DOUBLE_VIEW[0] = n;
          return [UINT_VIEW[1], UINT_VIEW[0]];
        };
        module2.exports.pack = toDoubleBE2;
        module2.exports.lo = lowUintBE2;
        module2.exports.hi = highUintBE2;
      } else {
        hasTypedArrays = false;
      }
    }
    var DOUBLE_VIEW;
    var UINT_VIEW;
    var toDoubleLE;
    var lowUintLE;
    var highUintLE;
    var toDoubleBE;
    var lowUintBE;
    var highUintBE;
    if (!hasTypedArrays) {
      let toDouble2 = function(lo, hi) {
        buffer.writeUInt32LE(lo, 0, true);
        buffer.writeUInt32LE(hi, 4, true);
        return buffer.readDoubleLE(0, true);
      }, lowUint2 = function(n) {
        buffer.writeDoubleLE(n, 0, true);
        return buffer.readUInt32LE(0, true);
      }, highUint2 = function(n) {
        buffer.writeDoubleLE(n, 0, true);
        return buffer.readUInt32LE(4, true);
      };
      toDouble = toDouble2, lowUint = lowUint2, highUint = highUint2;
      buffer = new Buffer(8);
      module2.exports = function doubleBits(n) {
        buffer.writeDoubleLE(n, 0, true);
        return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
      };
      module2.exports.pack = toDouble2;
      module2.exports.lo = lowUint2;
      module2.exports.hi = highUint2;
    }
    var buffer;
    var toDouble;
    var lowUint;
    var highUint;
    module2.exports.sign = function(n) {
      return module2.exports.hi(n) >>> 31;
    };
    module2.exports.exponent = function(n) {
      var b = module2.exports.hi(n);
      return (b << 1 >>> 21) - 1023;
    };
    module2.exports.fraction = function(n) {
      var lo = module2.exports.lo(n);
      var hi = module2.exports.hi(n);
      var b = hi & (1 << 20) - 1;
      if (hi & 2146435072) {
        b += 1 << 20;
      }
      return [lo, b];
    };
    module2.exports.denormalized = function(n) {
      var hi = module2.exports.hi(n);
      return !(hi & 2146435072);
    };
  }
});

// node_modules/nextafter/nextafter.js
var require_nextafter = __commonJS({
  "node_modules/nextafter/nextafter.js"(exports, module2) {
    "use strict";
    var doubleBits = require_double();
    var SMALLEST_DENORM = Math.pow(2, -1074);
    var UINT_MAX = -1 >>> 0;
    module2.exports = nextafter;
    function nextafter(x2, y2) {
      if (isNaN(x2) || isNaN(y2)) {
        return NaN;
      }
      if (x2 === y2) {
        return x2;
      }
      if (x2 === 0) {
        if (y2 < 0) {
          return -SMALLEST_DENORM;
        } else {
          return SMALLEST_DENORM;
        }
      }
      var hi = doubleBits.hi(x2);
      var lo = doubleBits.lo(x2);
      if (y2 > x2 === x2 > 0) {
        if (lo === UINT_MAX) {
          hi += 1;
          lo = 0;
        } else {
          lo += 1;
        }
      } else {
        if (lo === 0) {
          lo = UINT_MAX;
          hi -= 1;
        } else {
          lo -= 1;
        }
      }
      return doubleBits.pack(lo, hi);
    }
  }
});

// node_modules/interval-arithmetic/lib/round.js
var require_round = __commonJS({
  "node_modules/interval-arithmetic/lib/round.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var nextafter_1 = __importDefault(require_nextafter());
    function identity5(v) {
      return v;
    }
    function prev(v) {
      if (v === Infinity) {
        return v;
      }
      return (0, nextafter_1.default)(v, -Infinity);
    }
    function next(v) {
      if (v === -Infinity) {
        return v;
      }
      return (0, nextafter_1.default)(v, Infinity);
    }
    function toInteger(x2) {
      return x2 < 0 ? Math.ceil(x2) : Math.floor(x2);
    }
    var cache = {
      prev,
      next
    };
    var round2 = {
      /**
       * Computes the previous IEEE floating point representation of `v`
       * @example
       * Interval.round.safePrev(1)          // 0.9999999999999999
       * Interval.round.safePrev(3)          // 2.9999999999999996
       * Interval.round.safePrev(Infinity)   // Infinity
       * @param {number} v
       * @return {number}
       * @function
       */
      safePrev: prev,
      /**
       * Computes the next IEEE floating point representation of `v`
       * @example
       * Interval.round.safeNext(1)          // 1.0000000000000002
       * Interval.round.safeNext(3)          // 3.0000000000000004
       * Interval.round.safeNext(-Infinity)  // -Infinity
       * @param {number} v
       * @return {number}
       * @function
       */
      safeNext: next,
      prev(x2) {
        return cache.prev(x2);
      },
      next(x2) {
        return cache.next(x2);
      },
      // prettier-ignore
      addLo(x2, y2) {
        return round2.prev(x2 + y2);
      },
      // prettier-ignore
      addHi(x2, y2) {
        return round2.next(x2 + y2);
      },
      // prettier-ignore
      subLo(x2, y2) {
        return round2.prev(x2 - y2);
      },
      // prettier-ignore
      subHi(x2, y2) {
        return round2.next(x2 - y2);
      },
      // prettier-ignore
      mulLo(x2, y2) {
        return round2.prev(x2 * y2);
      },
      // prettier-ignore
      mulHi(x2, y2) {
        return round2.next(x2 * y2);
      },
      // prettier-ignore
      divLo(x2, y2) {
        return round2.prev(x2 / y2);
      },
      // prettier-ignore
      divHi(x2, y2) {
        return round2.next(x2 / y2);
      },
      // prettier-ignore
      intLo(x2) {
        return toInteger(round2.prev(x2));
      },
      // prettier-ignore
      intHi(x2) {
        return toInteger(round2.next(x2));
      },
      // prettier-ignore
      logLo(x2) {
        return round2.prev(Math.log(x2));
      },
      // prettier-ignore
      logHi(x2) {
        return round2.next(Math.log(x2));
      },
      // prettier-ignore
      expLo(x2) {
        return round2.prev(Math.exp(x2));
      },
      // prettier-ignore
      expHi(x2) {
        return round2.next(Math.exp(x2));
      },
      // prettier-ignore
      sinLo(x2) {
        return round2.prev(Math.sin(x2));
      },
      // prettier-ignore
      sinHi(x2) {
        return round2.next(Math.sin(x2));
      },
      // prettier-ignore
      cosLo(x2) {
        return round2.prev(Math.cos(x2));
      },
      // prettier-ignore
      cosHi(x2) {
        return round2.next(Math.cos(x2));
      },
      // prettier-ignore
      tanLo(x2) {
        return round2.prev(Math.tan(x2));
      },
      // prettier-ignore
      tanHi(x2) {
        return round2.next(Math.tan(x2));
      },
      // prettier-ignore
      asinLo(x2) {
        return round2.prev(Math.asin(x2));
      },
      // prettier-ignore
      asinHi(x2) {
        return round2.next(Math.asin(x2));
      },
      // prettier-ignore
      acosLo(x2) {
        return round2.prev(Math.acos(x2));
      },
      // prettier-ignore
      acosHi(x2) {
        return round2.next(Math.acos(x2));
      },
      // prettier-ignore
      atanLo(x2) {
        return round2.prev(Math.atan(x2));
      },
      // prettier-ignore
      atanHi(x2) {
        return round2.next(Math.atan(x2));
      },
      // polyfill required for hyperbolic functions
      // prettier-ignore
      sinhLo(x2) {
        return round2.prev(Math.sinh(x2));
      },
      // prettier-ignore
      sinhHi(x2) {
        return round2.next(Math.sinh(x2));
      },
      // prettier-ignore
      coshLo(x2) {
        return round2.prev(Math.cosh(x2));
      },
      // prettier-ignore
      coshHi(x2) {
        return round2.next(Math.cosh(x2));
      },
      // prettier-ignore
      tanhLo(x2) {
        return round2.prev(Math.tanh(x2));
      },
      // prettier-ignore
      tanhHi(x2) {
        return round2.next(Math.tanh(x2));
      },
      /**
       * @ignore
       * ln(power) exponentiation of x
       * @param {number} x
       * @param {number} power
       * @returns {number}
       */
      powLo(x2, power) {
        if (power % 1 !== 0) {
          return round2.prev(Math.pow(x2, power));
        }
        let y2 = (power & 1) === 1 ? x2 : 1;
        power >>= 1;
        while (power > 0) {
          x2 = round2.mulLo(x2, x2);
          if ((power & 1) === 1) {
            y2 = round2.mulLo(x2, y2);
          }
          power >>= 1;
        }
        return y2;
      },
      /**
       * @ignore
       * ln(power) exponentiation of x
       * @param {number} x
       * @param {number} power
       * @returns {number}
       */
      powHi(x2, power) {
        if (power % 1 !== 0) {
          return round2.next(Math.pow(x2, power));
        }
        let y2 = (power & 1) === 1 ? x2 : 1;
        power >>= 1;
        while (power > 0) {
          x2 = round2.mulHi(x2, x2);
          if ((power & 1) === 1) {
            y2 = round2.mulHi(x2, y2);
          }
          power >>= 1;
        }
        return y2;
      },
      // prettier-ignore
      sqrtLo(x2) {
        return round2.prev(Math.sqrt(x2));
      },
      // prettier-ignore
      sqrtHi(x2) {
        return round2.next(Math.sqrt(x2));
      },
      /**
       * Most operations on intervals will cary the rounding error so that the
       * resulting interval correctly represents all the possible values, this feature
       * can be disabled by calling this method allowing a little boost in the
       * performance while operating on intervals
       *
       * @see module:interval-arithmetic/round-math.enable
       * @example
       * var x = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       *
       * Interval.round.disable()
       * var y = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * y // equal to {lo: 2, hi: 2}
       * @function
       */
      disable() {
        cache.next = cache.prev = identity5;
      },
      /**
       * Enables IEEE previous/next floating point wrapping of values (enabled by
       * default)
       * @see module:interval-arithmetic/round-math.disable
       * @example
       * var x = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       *
       * Interval.round.disable()
       * var y = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * y // equal to {lo: 2, hi: 2}
       *
       * Interval.round.enable()
       * var z = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * z // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       * @function
       */
      enable() {
        cache.next = next;
        cache.prev = prev;
      }
    };
    exports.default = round2;
  }
});

// node_modules/interval-arithmetic/lib/interval.js
var require_interval = __commonJS({
  "node_modules/interval-arithmetic/lib/interval.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Interval = exports._Interval = void 0;
    var utils = __importStar(require_utils2());
    var round_1 = __importDefault(require_round());
    var _Interval = class {
      constructor(lo, hi) {
        this.lo = 0;
        this.hi = 0;
        if (!(this instanceof _Interval)) {
          console.log("calling with new");
          console.log(lo, hi);
          return new _Interval(lo, hi);
        }
        if (typeof lo !== "undefined" && typeof hi !== "undefined") {
          if (utils.isInterval(lo)) {
            if (!utils.isSingleton(lo)) {
              throw new TypeError("Interval: interval `lo` must be a singleton");
            }
            lo = lo.lo;
          }
          if (utils.isInterval(hi)) {
            if (!utils.isSingleton(hi)) {
              throw TypeError("Interval: interval `hi` must be a singleton");
            }
            hi = hi.hi;
          }
        } else if (typeof lo !== "undefined") {
          if (Array.isArray(lo)) {
            return new Interval(lo[0], lo[1]);
          }
          return new Interval(lo, lo);
        } else {
          lo = hi = 0;
        }
        this.assign(lo, hi);
      }
      /**
       * Sets `this.lo` and `this.hi` to a single value `v`
       *
       * @param {number} v
       * @return {Interval} The calling interval i.e. `this`
       */
      singleton(v) {
        return this.set(v, v);
      }
      /**
       * Sets new endpoints to this interval, the left endpoint is equal to the
       * previous IEEE floating point value of `lo` and the right endpoint
       * is equal to the next IEEE floating point
       * value of `hi`, it's assumed that `lo <= hi`
       *
       * @example
       * ```typescript
       * const x = Interval().bounded(1, 2)
       * x.lo < 1 // true, x.lo === 0.9999999999999999
       * x.hi > 2 // true, x.hi === 2.0000000000000004
       * ```
       *
       * @example
       * ```typescript
       * // the correct representation of 1/3
       * var x = Interval().bounded(1/3, 1/3)
       * x.lo < 1/3 // true
       * x.hi > 1/3 // true
       * // however the floating point representation of 1/3 is less than the real 1/3
       * // therefore the left endpoint could be 1/3 instead of the previous value of
       * var next = Interval.round.safeNext
       * var x = Interval().set(1/3, next(1/3))
       * // x now represents 1/3 correctly
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval i.e. `this`
       */
      bounded(lo, hi) {
        return this.set(round_1.default.prev(lo), round_1.default.next(hi));
      }
      /**
       * Equivalent to `Interval().bounded(v, v)`
       * @param {number} v
       * @return {Interval} The calling interval i.e. `this`
       */
      boundedSingleton(v) {
        return this.bounded(v, v);
      }
      /**
       * Sets new endpoints for this interval, this method bypasses any
       * checks on the type of arguments
       *
       * @param {Number} lo The left endpoint of the interval
       * @param {Number} hi The right endpoint of the interval
       * @return {Interval} The calling interval
       */
      set(lo, hi) {
        this.lo = lo;
        this.hi = hi;
        return this;
      }
      /**
       * Sets new endpoints for this interval checking that both arguments exist
       * and that are valid numbers, additionally if `lo > hi` the interval is set to
       * an empty interval
       *
       * @param {Number} lo The left endpoint of the interval
       * @param {Number} hi The right endpoint of the interval
       * @return {Interval} The calling interval
       */
      assign(lo, hi) {
        if (typeof lo !== "number" || typeof hi !== "number") {
          throw TypeError("Interval#assign: arguments must be numbers");
        }
        if (isNaN(lo) || isNaN(hi) || lo > hi) {
          return this.setEmpty();
        }
        return this.set(lo, hi);
      }
      /**
       * Sets the endpoints of this interval to `[∞, -∞]` effectively representing
       * no values
       * @return {Interval} The calling interval
       */
      setEmpty() {
        return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
      }
      /**
       * Sets the endpoints of this interval to `[-∞, ∞]` effectively representing all
       * the possible real values
       * @return {Interval} The calling interval
       */
      setWhole() {
        return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
      }
      /**
       * Sets the endpoints of this interval to the open interval `(lo, hi)`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // (2, 3)
       * Interval().open(2, 3)  // {lo: 2.0000000000000004, hi: 2.9999999999999996}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      open(lo, hi) {
        return this.assign(round_1.default.safeNext(lo), round_1.default.safePrev(hi));
      }
      /**
       * Sets the endpoints of this interval to the half open interval `(lo, hi]`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // (2, 3]
       * Interval().halfOpenLeft(2, 3)  // {lo: 2.0000000000000004, hi: 3}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      halfOpenLeft(lo, hi) {
        return this.assign(round_1.default.safeNext(lo), hi);
      }
      /**
       * Sets the endpoints of this interval to the half open interval `[lo, hi)`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // [2, 3)
       * Interval.halfOpenRight(2, 3)     // {lo: 2, hi: 2.9999999999999996}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      halfOpenRight(lo, hi) {
        return this.assign(lo, round_1.default.safePrev(hi));
      }
      /**
       * Array representation of this interval
       * @return {array}
       */
      toArray() {
        return [this.lo, this.hi];
      }
      /**
       * Creates an interval equal to the calling one
       * @see Interval.clone
       * @name Interval.prototype
       * @example
       * ```typescript
       * var x = Interval(2, 3)
       * x.clone()    // Interval(2, 3)
       * ```
       * @return {Interval}
       */
      clone() {
        return new Interval().set(this.lo, this.hi);
      }
    };
    exports._Interval = _Interval;
    function bindNew(Class) {
      function _Class() {
        for (var len = arguments.length, rest = Array(len), key = 0; key < len; key++) {
          rest[key] = arguments[key];
        }
        return new (Function.prototype.bind.apply(Class, [null].concat(rest)))();
      }
      _Class.prototype = Class.prototype;
      return _Class;
    }
    var Interval = bindNew(_Interval);
    exports.Interval = Interval;
    Interval.factory = Interval;
  }
});

// node_modules/interval-arithmetic/lib/constants.js
var require_constants = __commonJS({
  "node_modules/interval-arithmetic/lib/constants.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var interval_1 = require_interval();
    var round_1 = __importDefault(require_round());
    var piLow = (3373259426 + 273688 / (1 << 21)) / (1 << 30);
    var piHigh = (3373259426 + 273689 / (1 << 21)) / (1 << 30);
    var constants2 = {
      /**
       * Previous IEEE floating point value of PI (equal to Math.PI)
       * 3.141592653589793
       * @memberof constants
       * @type {number}
       */
      PI_LOW: piLow,
      /**
       * Next IEEE floating point value of PI, 3.1415926535897936
       * @memberof constants
       * @type {number}
       */
      PI_HIGH: piHigh,
      PI_HALF_LOW: piLow / 2,
      PI_HALF_HIGH: piHigh / 2,
      PI_TWICE_LOW: piLow * 2,
      PI_TWICE_HIGH: piHigh * 2,
      /**
       * An interval that represents PI, NOTE: calls to Interval.PI always return
       * a new interval representing PI
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval.E
       * ```
       * @name E
       * @type {Interval}
       */
      get E() {
        return new interval_1.Interval(round_1.default.prev(Math.E), round_1.default.next(Math.E));
      },
      /**
       * An interval that represents Euler's constant e, NOTE: calls to Interval.E always return
       * a new interval representing PI
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW, Interval.PI_HIGH)
       * ```
       * @name PI
       * @type {Interval}
       */
      get PI() {
        return new interval_1.Interval(piLow, piHigh);
      },
      /**
       * An interval that represents `PI / 2`, NOTE: calls to `Interval.PI_HALF` always
       * return a new interval representing `PI / 2`
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW / 2, Interval.PI_HIGH / 2)
       * ```
       * @name PI_HALF
       * @type {Interval}
       */
      get PI_HALF() {
        return new interval_1.Interval(constants2.PI_HALF_LOW, constants2.PI_HALF_HIGH);
      },
      /**
       * An interval that represents `PI * 2` NOTE: calls to `Interval.PI_TWICE` always
       * return a new interval representing `PI * 2`
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW * 2, Interval.PI_HIGH * 2)
       * ```
       * @name PI_TWICE
       * @type {Interval}
       */
      get PI_TWICE() {
        return new interval_1.Interval(constants2.PI_TWICE_LOW, constants2.PI_TWICE_HIGH);
      },
      /**
       * An interval that represents 0, NOTE: calls to `Interval.ZERO` always return a new interval representing 0
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.ZERO is equivalent to
       * Interval(0)
       * ```
       * @name ZERO
       * @type {Interval}
       */
      get ZERO() {
        return new interval_1.Interval(0);
      },
      /**
       * An interval that represents 1, NOTE: calls to Interval.ONE always
       * return a new interval representing 1
       * @memberof constants
       * @static
       * @example
       * // Interval.ONE is equivalent to
       * Interval(1)
       * @name ONE
       * @type {Interval}
       */
      get ONE() {
        return new interval_1.Interval(1);
      },
      /**
       * An interval that represents all the real values
       * NOTE: calls to Interval.WHOLE always return a new interval representing all the real values
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.WHOLE is equivalent to
       * Interval().setWhole()
       * ```
       * @name WHOLE
       * @type {Interval}
       */
      get WHOLE() {
        return new interval_1.Interval().setWhole();
      },
      /**
       * An interval that represents no values
       * NOTE: calls to Interval.EMPTY always return a new interval representing no values
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.EMPTY is equivalent to
       * Interval().setEmpty()
       * ```
       * @name EMPTY
       * @type {Interval}
       */
      get EMPTY() {
        return new interval_1.Interval().setEmpty();
      }
    };
    exports.default = constants2;
  }
});

// node_modules/interval-arithmetic/lib/operations/relational.js
var require_relational = __commonJS({
  "node_modules/interval-arithmetic/lib/operations/relational.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.geq = exports.greaterEqualThan = exports.leq = exports.lessEqualThan = exports.gt = exports.greaterThan = exports.lt = exports.lessThan = exports.notEqual = exports.assertIncludes = exports.almostEqual = exports.equal = void 0;
    var utils = __importStar(require_utils2());
    function equal(x2, y2) {
      if (utils.isEmpty(x2)) {
        return utils.isEmpty(y2);
      }
      return !utils.isEmpty(y2) && x2.lo === y2.lo && x2.hi === y2.hi;
    }
    exports.equal = equal;
    var EPS = 1e-7;
    function assert(a2, message) {
      if (!a2) {
        throw new Error(message || "assertion failed");
      }
    }
    function assertEps(a2, b) {
      if (!isFinite(a2)) {
        return assert(a2 === b, `[Infinity] expected ${a2} to be ${b}`);
      }
      assert(Math.abs(a2 - b) < EPS, `expected ${a2} to be close to ${b}`);
    }
    function almostEqual(x2, y2) {
      x2 = Array.isArray(x2) ? x2 : x2.toArray();
      y2 = Array.isArray(y2) ? y2 : y2.toArray();
      assertEps(x2[0], y2[0]);
      assertEps(x2[1], y2[1]);
    }
    exports.almostEqual = almostEqual;
    function assertIncludes(x2, y2) {
      almostEqual(x2, y2);
      x2 = Array.isArray(x2) ? x2 : x2.toArray();
      y2 = Array.isArray(y2) ? y2 : y2.toArray();
      assert(x2[0] <= y2[0], `${x2[0]} should be less/equal than ${y2[0]}`);
      assert(y2[1] <= x2[1], `${y2[1]} should be less/equal than ${x2[1]}`);
    }
    exports.assertIncludes = assertIncludes;
    function notEqual(x2, y2) {
      if (utils.isEmpty(x2)) {
        return !utils.isEmpty(y2);
      }
      return utils.isEmpty(y2) || x2.hi < y2.lo || x2.lo > y2.hi;
    }
    exports.notEqual = notEqual;
    function lessThan(x2, y2) {
      if (utils.isEmpty(x2) || utils.isEmpty(y2)) {
        return false;
      }
      return x2.hi < y2.lo;
    }
    exports.lessThan = lessThan;
    exports.lt = lessThan;
    function greaterThan(x2, y2) {
      if (utils.isEmpty(x2) || utils.isEmpty(y2)) {
        return false;
      }
      return x2.lo > y2.hi;
    }
    exports.greaterThan = greaterThan;
    exports.gt = greaterThan;
    function lessEqualThan(x2, y2) {
      if (utils.isEmpty(x2) || utils.isEmpty(y2)) {
        return false;
      }
      return x2.hi <= y2.lo;
    }
    exports.lessEqualThan = lessEqualThan;
    exports.leq = lessEqualThan;
    function greaterEqualThan(x2, y2) {
      if (utils.isEmpty(x2) || utils.isEmpty(y2)) {
        return false;
      }
      return x2.lo >= y2.hi;
    }
    exports.greaterEqualThan = greaterEqualThan;
    exports.geq = greaterEqualThan;
  }
});

// node_modules/interval-arithmetic/lib/operations/division.js
var require_division = __commonJS({
  "node_modules/interval-arithmetic/lib/operations/division.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zero = exports.negative = exports.positive = exports.nonZero = void 0;
    var interval_1 = require_interval();
    var round_1 = __importDefault(require_round());
    var utils = __importStar(require_utils2());
    var constants_1 = __importDefault(require_constants());
    function nonZero(x2, y2) {
      const xl = x2.lo;
      const xh = x2.hi;
      const yl = y2.lo;
      const yh = y2.hi;
      const out = new interval_1.Interval();
      if (xh < 0) {
        if (yh < 0) {
          out.lo = round_1.default.divLo(xh, yl);
          out.hi = round_1.default.divHi(xl, yh);
        } else {
          out.lo = round_1.default.divLo(xl, yl);
          out.hi = round_1.default.divHi(xh, yh);
        }
      } else if (xl < 0) {
        if (yh < 0) {
          out.lo = round_1.default.divLo(xh, yh);
          out.hi = round_1.default.divHi(xl, yh);
        } else {
          out.lo = round_1.default.divLo(xl, yl);
          out.hi = round_1.default.divHi(xh, yl);
        }
      } else {
        if (yh < 0) {
          out.lo = round_1.default.divLo(xh, yh);
          out.hi = round_1.default.divHi(xl, yl);
        } else {
          out.lo = round_1.default.divLo(xl, yh);
          out.hi = round_1.default.divHi(xh, yl);
        }
      }
      return out;
    }
    exports.nonZero = nonZero;
    function positive(x2, v) {
      if (x2.lo === 0 && x2.hi === 0) {
        return x2;
      }
      if (utils.zeroIn(x2)) {
        return constants_1.default.WHOLE;
      }
      if (x2.hi < 0) {
        return new interval_1.Interval(Number.NEGATIVE_INFINITY, round_1.default.divHi(x2.hi, v));
      } else {
        return new interval_1.Interval(round_1.default.divLo(x2.lo, v), Number.POSITIVE_INFINITY);
      }
    }
    exports.positive = positive;
    function negative(x2, v) {
      if (x2.lo === 0 && x2.hi === 0) {
        return x2;
      }
      if (utils.zeroIn(x2)) {
        return constants_1.default.WHOLE;
      }
      if (x2.hi < 0) {
        return new interval_1.Interval(round_1.default.divLo(x2.hi, v), Number.POSITIVE_INFINITY);
      } else {
        return new interval_1.Interval(Number.NEGATIVE_INFINITY, round_1.default.divHi(x2.lo, v));
      }
    }
    exports.negative = negative;
    function zero3(x2) {
      if (x2.lo === 0 && x2.hi === 0) {
        return x2;
      }
      return constants_1.default.WHOLE;
    }
    exports.zero = zero3;
  }
});

// node_modules/interval-arithmetic/lib/operations/arithmetic.js
var require_arithmetic = __commonJS({
  "node_modules/interval-arithmetic/lib/operations/arithmetic.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.negative = exports.positive = exports.div = exports.divide = exports.mul = exports.multiply = exports.sub = exports.subtract = exports.add = void 0;
    var interval_1 = require_interval();
    var round_1 = __importDefault(require_round());
    var constants_1 = __importDefault(require_constants());
    var utils = __importStar(require_utils2());
    var division = __importStar(require_division());
    function add2(x2, y2) {
      return new interval_1.Interval(round_1.default.addLo(x2.lo, y2.lo), round_1.default.addHi(x2.hi, y2.hi));
    }
    exports.add = add2;
    function subtract(x2, y2) {
      return new interval_1.Interval(round_1.default.subLo(x2.lo, y2.hi), round_1.default.subHi(x2.hi, y2.lo));
    }
    exports.subtract = subtract;
    exports.sub = subtract;
    function multiply(x2, y2) {
      if (utils.isEmpty(x2) || utils.isEmpty(y2)) {
        return constants_1.default.EMPTY;
      }
      const xl = x2.lo;
      const xh = x2.hi;
      const yl = y2.lo;
      const yh = y2.hi;
      const out = new interval_1.Interval();
      if (xl < 0) {
        if (xh > 0) {
          if (yl < 0) {
            if (yh > 0) {
              out.lo = Math.min(round_1.default.mulLo(xl, yh), round_1.default.mulLo(xh, yl));
              out.hi = Math.max(round_1.default.mulHi(xl, yl), round_1.default.mulHi(xh, yh));
            } else {
              out.lo = round_1.default.mulLo(xh, yl);
              out.hi = round_1.default.mulHi(xl, yl);
            }
          } else {
            if (yh > 0) {
              out.lo = round_1.default.mulLo(xl, yh);
              out.hi = round_1.default.mulHi(xh, yh);
            } else {
              out.lo = 0;
              out.hi = 0;
            }
          }
        } else {
          if (yl < 0) {
            if (yh > 0) {
              out.lo = round_1.default.mulLo(xl, yh);
              out.hi = round_1.default.mulHi(xl, yl);
            } else {
              out.lo = round_1.default.mulLo(xh, yh);
              out.hi = round_1.default.mulHi(xl, yl);
            }
          } else {
            if (yh > 0) {
              out.lo = round_1.default.mulLo(xl, yh);
              out.hi = round_1.default.mulHi(xh, yl);
            } else {
              out.lo = 0;
              out.hi = 0;
            }
          }
        }
      } else {
        if (xh > 0) {
          if (yl < 0) {
            if (yh > 0) {
              out.lo = round_1.default.mulLo(xh, yl);
              out.hi = round_1.default.mulHi(xh, yh);
            } else {
              out.lo = round_1.default.mulLo(xh, yl);
              out.hi = round_1.default.mulHi(xl, yh);
            }
          } else {
            if (yh > 0) {
              out.lo = round_1.default.mulLo(xl, yl);
              out.hi = round_1.default.mulHi(xh, yh);
            } else {
              out.lo = 0;
              out.hi = 0;
            }
          }
        } else {
          out.lo = 0;
          out.hi = 0;
        }
      }
      return out;
    }
    exports.multiply = multiply;
    exports.mul = multiply;
    function divide2(x2, y2) {
      if (utils.isEmpty(x2) || utils.isEmpty(y2)) {
        return constants_1.default.EMPTY;
      }
      if (utils.zeroIn(y2)) {
        if (y2.lo !== 0) {
          if (y2.hi !== 0) {
            return division.zero(x2);
          } else {
            return division.negative(x2, y2.lo);
          }
        } else {
          if (y2.hi !== 0) {
            return division.positive(x2, y2.hi);
          } else {
            return constants_1.default.EMPTY;
          }
        }
      } else {
        return division.nonZero(x2, y2);
      }
    }
    exports.divide = divide2;
    exports.div = divide2;
    function positive(x2) {
      return new interval_1.Interval(x2.lo, x2.hi);
    }
    exports.positive = positive;
    function negative(x2) {
      return new interval_1.Interval(-x2.hi, -x2.lo);
    }
    exports.negative = negative;
  }
});

// node_modules/interval-arithmetic/lib/operations/algebra.js
var require_algebra = __commonJS({
  "node_modules/interval-arithmetic/lib/operations/algebra.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nthRoot = exports.sqrt = exports.pow = exports.multiplicativeInverse = exports.fmod = void 0;
    var interval_1 = require_interval();
    var round_1 = __importDefault(require_round());
    var constants_1 = __importDefault(require_constants());
    var utils = __importStar(require_utils2());
    var arithmetic = __importStar(require_arithmetic());
    function fmod(x2, y2) {
      if (utils.isEmpty(x2) || utils.isEmpty(y2)) {
        return constants_1.default.EMPTY;
      }
      const yb = x2.lo < 0 ? y2.lo : y2.hi;
      let n = x2.lo / yb;
      if (n < 0)
        n = Math.ceil(n);
      else
        n = Math.floor(n);
      return arithmetic.sub(x2, arithmetic.mul(y2, new interval_1.Interval(n)));
    }
    exports.fmod = fmod;
    function multiplicativeInverse(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      if (utils.zeroIn(x2)) {
        if (x2.lo !== 0) {
          if (x2.hi !== 0) {
            return constants_1.default.WHOLE;
          } else {
            return new interval_1.Interval(Number.NEGATIVE_INFINITY, round_1.default.divHi(1, x2.lo));
          }
        } else {
          if (x2.hi !== 0) {
            return new interval_1.Interval(round_1.default.divLo(1, x2.hi), Number.POSITIVE_INFINITY);
          } else {
            return constants_1.default.EMPTY;
          }
        }
      } else {
        return new interval_1.Interval(round_1.default.divLo(1, x2.hi), round_1.default.divHi(1, x2.lo));
      }
    }
    exports.multiplicativeInverse = multiplicativeInverse;
    function pow3(x2, power) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      if (typeof power === "object") {
        if (!utils.isSingleton(power)) {
          return constants_1.default.EMPTY;
        }
        power = power.lo;
      }
      if (power === 0) {
        if (x2.lo === 0 && x2.hi === 0) {
          return constants_1.default.EMPTY;
        } else {
          return constants_1.default.ONE;
        }
      } else if (power < 0) {
        return pow3(multiplicativeInverse(x2), -power);
      }
      if (Number.isSafeInteger(power)) {
        if (x2.hi < 0) {
          const yl = round_1.default.powLo(-x2.hi, power);
          const yh = round_1.default.powHi(-x2.lo, power);
          if ((power & 1) === 1) {
            return new interval_1.Interval(-yh, -yl);
          } else {
            return new interval_1.Interval(yl, yh);
          }
        } else if (x2.lo < 0) {
          if ((power & 1) === 1) {
            return new interval_1.Interval(-round_1.default.powLo(-x2.lo, power), round_1.default.powHi(x2.hi, power));
          } else {
            return new interval_1.Interval(0, round_1.default.powHi(Math.max(-x2.lo, x2.hi), power));
          }
        } else {
          return new interval_1.Interval(round_1.default.powLo(x2.lo, power), round_1.default.powHi(x2.hi, power));
        }
      } else {
        console.warn("power is not an integer, you should use nth-root instead, returning an empty interval");
        return constants_1.default.EMPTY;
      }
    }
    exports.pow = pow3;
    function sqrt5(x2) {
      return nthRoot(x2, 2);
    }
    exports.sqrt = sqrt5;
    function nthRoot(x2, n) {
      if (utils.isEmpty(x2) || n < 0) {
        return constants_1.default.EMPTY;
      }
      if (typeof n === "object") {
        if (!utils.isSingleton(n)) {
          return constants_1.default.EMPTY;
        }
        n = n.lo;
      }
      const power = 1 / n;
      if (x2.hi < 0) {
        if (Number.isSafeInteger(n) && (n & 1) === 1) {
          const yl = round_1.default.powHi(-x2.lo, power);
          const yh = round_1.default.powLo(-x2.hi, power);
          return new interval_1.Interval(-yl, -yh);
        }
        return constants_1.default.EMPTY;
      } else if (x2.lo < 0) {
        const yp = round_1.default.powHi(x2.hi, power);
        if (Number.isSafeInteger(n) && (n & 1) === 1) {
          const yn = -round_1.default.powHi(-x2.lo, power);
          return new interval_1.Interval(yn, yp);
        }
        return new interval_1.Interval(0, yp);
      } else {
        return new interval_1.Interval(round_1.default.powLo(x2.lo, power), round_1.default.powHi(x2.hi, power));
      }
    }
    exports.nthRoot = nthRoot;
  }
});

// node_modules/interval-arithmetic/lib/operations/misc.js
var require_misc = __commonJS({
  "node_modules/interval-arithmetic/lib/operations/misc.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = exports.min = exports.max = exports.abs = exports.wid = exports.width = exports.difference = exports.union = exports.intersection = exports.hull = exports.log2 = exports.LOG_EXP_2 = exports.log10 = exports.LOG_EXP_10 = exports.ln = exports.log = exports.exp = void 0;
    var interval_1 = require_interval();
    var round_1 = __importDefault(require_round());
    var constants_1 = __importDefault(require_constants());
    var utils = __importStar(require_utils2());
    var arithmetic = __importStar(require_arithmetic());
    function exp2(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      return new interval_1.Interval(round_1.default.expLo(x2.lo), round_1.default.expHi(x2.hi));
    }
    exports.exp = exp2;
    function log4(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      const l = x2.lo <= 0 ? Number.NEGATIVE_INFINITY : round_1.default.logLo(x2.lo);
      return new interval_1.Interval(l, round_1.default.logHi(x2.hi));
    }
    exports.log = log4;
    exports.ln = log4;
    exports.LOG_EXP_10 = log4(new interval_1.Interval(10, 10));
    function log104(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      return arithmetic.div(log4(x2), exports.LOG_EXP_10);
    }
    exports.log10 = log104;
    exports.LOG_EXP_2 = log4(new interval_1.Interval(2, 2));
    function log24(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      return arithmetic.div(log4(x2), exports.LOG_EXP_2);
    }
    exports.log2 = log24;
    function hull(x2, y2) {
      const badX = utils.isEmpty(x2);
      const badY = utils.isEmpty(y2);
      if (badX && badY) {
        return constants_1.default.EMPTY;
      } else if (badX) {
        return y2.clone();
      } else if (badY) {
        return x2.clone();
      } else {
        return new interval_1.Interval(Math.min(x2.lo, y2.lo), Math.max(x2.hi, y2.hi));
      }
    }
    exports.hull = hull;
    function intersection(x2, y2) {
      if (utils.isEmpty(x2) || utils.isEmpty(y2)) {
        return constants_1.default.EMPTY;
      }
      const lo = Math.max(x2.lo, y2.lo);
      const hi = Math.min(x2.hi, y2.hi);
      if (lo <= hi) {
        return new interval_1.Interval(lo, hi);
      }
      return constants_1.default.EMPTY;
    }
    exports.intersection = intersection;
    function union(x2, y2) {
      if (!utils.intervalsOverlap(x2, y2)) {
        throw Error("Interval#union: intervals do not overlap");
      }
      return new interval_1.Interval(Math.min(x2.lo, y2.lo), Math.max(x2.hi, y2.hi));
    }
    exports.union = union;
    function difference(x2, y2) {
      if (utils.isEmpty(x2) || utils.isWhole(y2)) {
        return constants_1.default.EMPTY;
      }
      if (utils.intervalsOverlap(x2, y2)) {
        if (x2.lo < y2.lo && y2.hi < x2.hi) {
          throw Error("Interval.difference: difference creates multiple intervals");
        }
        if (y2.lo <= x2.lo && y2.hi === Infinity || y2.hi >= x2.hi && y2.lo === -Infinity) {
          return constants_1.default.EMPTY;
        }
        if (y2.lo <= x2.lo) {
          return new interval_1.Interval().halfOpenLeft(y2.hi, x2.hi);
        }
        return new interval_1.Interval().halfOpenRight(x2.lo, y2.lo);
      }
      return x2.clone();
    }
    exports.difference = difference;
    function width(x2) {
      if (utils.isEmpty(x2)) {
        return 0;
      }
      return round_1.default.subHi(x2.hi, x2.lo);
    }
    exports.width = width;
    exports.wid = width;
    function abs3(x2) {
      if (utils.isEmpty(x2) || utils.isWhole(x2)) {
        return constants_1.default.EMPTY;
      }
      if (x2.lo >= 0) {
        return x2.clone();
      }
      if (x2.hi <= 0) {
        return arithmetic.negative(x2);
      }
      return new interval_1.Interval(0, Math.max(-x2.lo, x2.hi));
    }
    exports.abs = abs3;
    function max4(x2, y2) {
      const badX = utils.isEmpty(x2);
      const badY = utils.isEmpty(y2);
      if (badX && badY) {
        return constants_1.default.EMPTY;
      } else if (badX) {
        return y2.clone();
      } else if (badY) {
        return x2.clone();
      } else {
        return new interval_1.Interval(Math.max(x2.lo, y2.lo), Math.max(x2.hi, y2.hi));
      }
    }
    exports.max = max4;
    function min4(x2, y2) {
      const badX = utils.isEmpty(x2);
      const badY = utils.isEmpty(y2);
      if (badX && badY) {
        return constants_1.default.EMPTY;
      } else if (badX) {
        return y2.clone();
      } else if (badY) {
        return x2.clone();
      } else {
        return new interval_1.Interval(Math.min(x2.lo, y2.lo), Math.min(x2.hi, y2.hi));
      }
    }
    exports.min = min4;
    function clone4(x2) {
      return new interval_1.Interval().set(x2.lo, x2.hi);
    }
    exports.clone = clone4;
  }
});

// node_modules/interval-arithmetic/lib/operations/trigonometric.js
var require_trigonometric = __commonJS({
  "node_modules/interval-arithmetic/lib/operations/trigonometric.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tanh = exports.cosh = exports.sinh = exports.atan = exports.acos = exports.asin = exports.tan = exports.sin = exports.cos = void 0;
    var interval_1 = require_interval();
    var round_1 = __importDefault(require_round());
    var constants_1 = __importDefault(require_constants());
    var utils = __importStar(require_utils2());
    var arithmetic = __importStar(require_arithmetic());
    var algebra = __importStar(require_algebra());
    var misc = __importStar(require_misc());
    function onlyInfinity(x2) {
      return !isFinite(x2.lo) && x2.lo === x2.hi;
    }
    function handleNegative(interval2) {
      if (interval2.lo < 0) {
        if (interval2.lo === -Infinity) {
          interval2.lo = 0;
          interval2.hi = Infinity;
        } else {
          const n = Math.ceil(-interval2.lo / constants_1.default.PI_TWICE_LOW);
          interval2.lo += constants_1.default.PI_TWICE_LOW * n;
          interval2.hi += constants_1.default.PI_TWICE_LOW * n;
        }
      }
      return interval2;
    }
    function cos3(x2) {
      if (utils.isEmpty(x2) || onlyInfinity(x2)) {
        return constants_1.default.EMPTY;
      }
      const cache = new interval_1.Interval().set(x2.lo, x2.hi);
      handleNegative(cache);
      const pi22 = constants_1.default.PI_TWICE;
      const t = algebra.fmod(cache, pi22);
      if (misc.width(t) >= pi22.lo) {
        return new interval_1.Interval(-1, 1);
      }
      if (t.lo >= constants_1.default.PI_HIGH) {
        const cosv = cos3(arithmetic.sub(t, constants_1.default.PI));
        return arithmetic.negative(cosv);
      }
      const lo = t.lo;
      const hi = t.hi;
      const rlo = round_1.default.cosLo(hi);
      const rhi = round_1.default.cosHi(lo);
      if (hi <= constants_1.default.PI_LOW) {
        return new interval_1.Interval(rlo, rhi);
      } else if (hi <= pi22.lo) {
        return new interval_1.Interval(-1, Math.max(rlo, rhi));
      } else {
        return new interval_1.Interval(-1, 1);
      }
    }
    exports.cos = cos3;
    function sin3(x2) {
      if (utils.isEmpty(x2) || onlyInfinity(x2)) {
        return constants_1.default.EMPTY;
      }
      return cos3(arithmetic.sub(x2, constants_1.default.PI_HALF));
    }
    exports.sin = sin3;
    function tan2(x2) {
      if (utils.isEmpty(x2) || onlyInfinity(x2)) {
        return constants_1.default.EMPTY;
      }
      const cache = new interval_1.Interval().set(x2.lo, x2.hi);
      handleNegative(cache);
      const pi4 = constants_1.default.PI;
      let t = algebra.fmod(cache, pi4);
      if (t.lo >= constants_1.default.PI_HALF_LOW) {
        t = arithmetic.sub(t, pi4);
      }
      if (t.lo <= -constants_1.default.PI_HALF_LOW || t.hi >= constants_1.default.PI_HALF_LOW) {
        return constants_1.default.WHOLE;
      }
      return new interval_1.Interval(round_1.default.tanLo(t.lo), round_1.default.tanHi(t.hi));
    }
    exports.tan = tan2;
    function asin3(x2) {
      if (utils.isEmpty(x2) || x2.hi < -1 || x2.lo > 1) {
        return constants_1.default.EMPTY;
      }
      const lo = x2.lo <= -1 ? -constants_1.default.PI_HALF_HIGH : round_1.default.asinLo(x2.lo);
      const hi = x2.hi >= 1 ? constants_1.default.PI_HALF_HIGH : round_1.default.asinHi(x2.hi);
      return new interval_1.Interval(lo, hi);
    }
    exports.asin = asin3;
    function acos3(x2) {
      if (utils.isEmpty(x2) || x2.hi < -1 || x2.lo > 1) {
        return constants_1.default.EMPTY;
      }
      const lo = x2.hi >= 1 ? 0 : round_1.default.acosLo(x2.hi);
      const hi = x2.lo <= -1 ? constants_1.default.PI_HIGH : round_1.default.acosHi(x2.lo);
      return new interval_1.Interval(lo, hi);
    }
    exports.acos = acos3;
    function atan3(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      return new interval_1.Interval(round_1.default.atanLo(x2.lo), round_1.default.atanHi(x2.hi));
    }
    exports.atan = atan3;
    function sinh4(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      return new interval_1.Interval(round_1.default.sinhLo(x2.lo), round_1.default.sinhHi(x2.hi));
    }
    exports.sinh = sinh4;
    function cosh4(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      if (x2.hi < 0) {
        return new interval_1.Interval(round_1.default.coshLo(x2.hi), round_1.default.coshHi(x2.lo));
      } else if (x2.lo >= 0) {
        return new interval_1.Interval(round_1.default.coshLo(x2.lo), round_1.default.coshHi(x2.hi));
      } else {
        return new interval_1.Interval(1, round_1.default.coshHi(-x2.lo > x2.hi ? x2.lo : x2.hi));
      }
    }
    exports.cosh = cosh4;
    function tanh4(x2) {
      if (utils.isEmpty(x2)) {
        return constants_1.default.EMPTY;
      }
      return new interval_1.Interval(round_1.default.tanhLo(x2.lo), round_1.default.tanhHi(x2.hi));
    }
    exports.tanh = tanh4;
  }
});

// node_modules/interval-arithmetic/lib/index.js
var require_lib = __commonJS({
  "node_modules/interval-arithmetic/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.constants = exports.round = exports.Interval = void 0;
    var interval_1 = require_interval();
    Object.defineProperty(exports, "Interval", { enumerable: true, get: function() {
      return interval_1._Interval;
    } });
    var round_1 = __importDefault(require_round());
    exports.round = round_1.default;
    var constants_1 = __importDefault(require_constants());
    exports.constants = constants_1.default;
    var relational = __importStar(require_relational());
    var arithmetic = __importStar(require_arithmetic());
    var algebra = __importStar(require_algebra());
    var trigonometric = __importStar(require_trigonometric());
    var misc = __importStar(require_misc());
    var utils = __importStar(require_utils2());
    var MixedInterval = Object.assign(interval_1.Interval, constants_1.default, round_1.default, misc, utils, relational, arithmetic, algebra, trigonometric, { round: round_1.default });
    exports.default = MixedInterval;
    __exportStar(require_relational(), exports);
    __exportStar(require_arithmetic(), exports);
    __exportStar(require_algebra(), exports);
    __exportStar(require_trigonometric(), exports);
    __exportStar(require_misc(), exports);
    __exportStar(require_utils2(), exports);
  }
});

// node_modules/interval-arithmetic-eval/lib/adapter.js
var require_adapter2 = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/adapter.js"(exports, module2) {
    "use strict";
    module2.exports = function(ns) {
      ns.mod = ns.fmod;
      ns.lessThan = ns.lt;
      ns.lessEqualThan = ns.leq;
      ns.greaterThan = ns.gt;
      ns.greaterEqualThan = ns.geq;
      ns.strictlyEqual = ns.equal;
      ns.strictlyNotEqual = ns.notEqual;
      ns.logicalAND = function(a2, b) {
        return a2 && b;
      };
      ns.logicalXOR = function(a2, b) {
        return a2 ^ b;
      };
      ns.logicalOR = function(a2, b) {
        return a2 || b;
      };
    };
  }
});

// node_modules/interval-arithmetic-eval/lib/policies.js
var require_policies = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/policies.js"(exports, module2) {
    "use strict";
    module2.exports = function(Interval) {
      return {
        disableRounding: function() {
          Interval.round.disable();
        },
        enableRounding: function() {
          Interval.round.enable();
        }
      };
    };
  }
});

// node_modules/interval-arithmetic-eval/lib/eval.js
var require_eval2 = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/eval.js"(exports, module2) {
    "use strict";
    var CodeGenerator = require_math_codegen2();
    var Interval = require_lib().default;
    require_adapter2()(Interval);
    function processScope(scope) {
      Object.keys(scope).forEach(function(k2) {
        const value = scope[k2];
        if (typeof value === "number" || Array.isArray(value)) {
          scope[k2] = Interval.factory(value);
        } else if (typeof value === "object" && "lo" in value && "hi" in value) {
          scope[k2] = Interval.factory(value.lo, value.hi);
        }
      });
    }
    module2.exports = function(expression) {
      return new CodeGenerator().setDefs({
        $$processScope: processScope
      }).parse(expression).compile(Interval);
    };
    module2.exports.policies = require_policies()(Interval);
    module2.exports.Interval = Interval;
  }
});

// node_modules/interval-arithmetic-eval/index.js
var require_interval_arithmetic_eval = __commonJS({
  "node_modules/interval-arithmetic-eval/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_eval2();
  }
});

// node_modules/function-plot/dist/helpers/eval.js
var require_eval3 = __commonJS({
  "node_modules/function-plot/dist/helpers/eval.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = exports.builtIn = void 0;
    var built_in_math_eval_1 = __importDefault(require_built_in_math_eval());
    var interval_arithmetic_eval_1 = __importDefault(require_interval_arithmetic_eval());
    var samplers = {
      interval: interval_arithmetic_eval_1.default,
      builtIn: built_in_math_eval_1.default
    };
    function getMathJS() {
      if (typeof global === "object" && "math" in global) {
        return global.math;
      }
      if (typeof window === "object" && "math" in window) {
        return window.math;
      }
      return null;
    }
    var mathJS = getMathJS();
    if (mathJS) {
      samplers.builtIn = mathJS.compile;
    }
    function generateEvaluator(samplerName) {
      function doCompile(expression) {
        if (typeof expression === "string") {
          const compiled = samplers[samplerName](expression);
          if (mathJS && samplerName === "builtIn") {
            return { eval: compiled.evaluate || compiled.eval };
          }
          return compiled;
        } else if (typeof expression === "function") {
          return { eval: expression };
        } else {
          throw Error("expression must be a string or a function");
        }
      }
      function compileIfPossible(meta, property) {
        const expression = meta[property];
        const hiddenProperty = samplerName + "_Expression_" + property;
        const hiddenCompiled = samplerName + "_Compiled_" + property;
        if (expression !== meta[hiddenProperty]) {
          meta[hiddenProperty] = expression;
          meta[hiddenCompiled] = doCompile(expression);
        }
      }
      function getCompiledExpression(meta, property) {
        return meta[samplerName + "_Compiled_" + property];
      }
      function evaluate(meta, property, variables) {
        compileIfPossible(meta, property);
        return getCompiledExpression(meta, property).eval(Object.assign({}, meta.scope || {}, variables));
      }
      return evaluate;
    }
    var builtIn = generateEvaluator("builtIn");
    exports.builtIn = builtIn;
    var interval2 = generateEvaluator("interval");
    exports.interval = interval2;
  }
});

// node_modules/function-plot/dist/tip.js
var require_tip = __commonJS({
  "node_modules/function-plot/dist/tip.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_shape_1 = (init_src2(), __toCommonJS(src_exports));
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var utils_1 = __importDefault(require_utils());
    var globals_1 = __importDefault(require_globals());
    var eval_1 = require_eval3();
    function mouseTip(config4) {
      config4 = Object.assign({
        xLine: false,
        yLine: false,
        renderer: function(x2, y2) {
          return "(" + x2.toFixed(3) + ", " + y2.toFixed(3) + ")";
        },
        owner: null
      }, config4);
      const MARGIN = 20;
      const line = (0, d3_shape_1.line)().x(function(d) {
        return d[0];
      }).y(function(d) {
        return d[1];
      });
      function lineGenerator(el, data) {
        return el.append("path").datum(data).attr("stroke", "grey").attr("stroke-dasharray", "5,5").attr("opacity", 0.5).attr("d", line);
      }
      let tipInnerJoin, tipInnerEnter;
      function tip(selection2) {
        const join2 = selection2.selectAll("g.tip").data(function(d) {
          return [d];
        });
        const tipEnter = join2.enter().append("g").attr("class", "tip").attr("clip-path", "url(#function-plot-clip-" + config4.owner.id + ")");
        tipInnerJoin = join2.merge(tipEnter).selectAll("g.inner-tip").data(function(d) {
          return [d];
        });
        tipInnerEnter = tipInnerJoin.enter().append("g").attr("class", "inner-tip").style("display", "none").each(function() {
          const el = (0, d3_selection_1.select)(this);
          lineGenerator(el, [
            [0, -config4.owner.meta.height - MARGIN],
            [0, config4.owner.meta.height + MARGIN]
          ]).attr("class", "tip-x-line").style("display", "none");
          lineGenerator(el, [
            [-config4.owner.meta.width - MARGIN, 0],
            [config4.owner.meta.width + MARGIN, 0]
          ]).attr("class", "tip-y-line").style("display", "none");
          el.append("circle").attr("r", 3);
          el.append("text").attr("transform", "translate(5,-5)");
        });
        tipInnerJoin.merge(tipInnerEnter).selectAll(".tip-x-line").style("display", config4.xLine ? null : "none");
        tipInnerJoin.merge(tipInnerEnter).selectAll(".tip-y-line").style("display", config4.yLine ? null : "none");
      }
      tip.move = function(coordinates) {
        let i;
        let minDist = Infinity;
        let closestIndex = -1;
        let x2, y2;
        const selection2 = tipInnerJoin.merge(tipInnerEnter);
        const meta = config4.owner.meta;
        const data = selection2.datum().data;
        const xScale = meta.xScale;
        const yScale = meta.yScale;
        const width = meta.width;
        const height = meta.height;
        const x0 = coordinates.x;
        const y0 = coordinates.y;
        for (i = 0; i < data.length; i += 1) {
          if (data[i].skipTip || data[i].fnType !== "linear") {
            continue;
          }
          const range2 = data[i].range || [-utils_1.default.infinity(), utils_1.default.infinity()];
          let candidateY;
          if (x0 > range2[0] - globals_1.default.TIP_X_EPS && x0 < range2[1] + globals_1.default.TIP_X_EPS) {
            try {
              candidateY = (0, eval_1.builtIn)(data[i], "fn", { x: x0 });
            } catch (e3) {
            }
            if (utils_1.default.isValidNumber(candidateY)) {
              const tDist = Math.abs(candidateY - y0);
              if (tDist < minDist) {
                minDist = tDist;
                closestIndex = i;
              }
            }
          }
        }
        if (closestIndex !== -1) {
          x2 = x0;
          if (data[closestIndex].range) {
            x2 = Math.max(x2, data[closestIndex].range[0]);
            x2 = Math.min(x2, data[closestIndex].range[1]);
          }
          y2 = (0, eval_1.builtIn)(data[closestIndex], "fn", { x: x2 });
          tip.show();
          config4.owner.emit("tip:update", { x: x2, y: y2, index: closestIndex });
          const clampX = utils_1.default.clamp(x2, xScale.invert(-MARGIN), xScale.invert(width + MARGIN));
          const clampY = utils_1.default.clamp(y2, yScale.invert(height + MARGIN), yScale.invert(-MARGIN));
          const color2 = utils_1.default.color(data[closestIndex], closestIndex);
          selection2.style("color", "red");
          selection2.attr("transform", "translate(" + xScale(clampX) + "," + yScale(clampY) + ")");
          selection2.select("circle").attr("fill", color2);
          selection2.select("text").attr("fill", color2).text(config4.renderer(x2, y2, closestIndex));
        } else {
          tip.hide();
        }
      };
      tip.show = function() {
        tipInnerJoin.merge(tipInnerEnter).style("display", null);
      };
      tip.hide = function() {
        tipInnerJoin.merge(tipInnerEnter).style("display", "none");
      };
      Object.keys(config4).forEach(function(option) {
        utils_1.default.getterSetter.call(tip, config4, option);
      });
      return tip;
    }
    exports.default = mouseTip;
  }
});

// node_modules/function-plot/dist/samplers/interval.js
var require_interval2 = __commonJS({
  "node_modules/function-plot/dist/samplers/interval.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var interval_arithmetic_eval_1 = __importStar(require_interval_arithmetic_eval());
    var eval_1 = require_eval3();
    var utils_1 = __importDefault(require_utils());
    interval_arithmetic_eval_1.default.policies.disableRounding();
    function interval1d(samplerParams) {
      const xCoords = utils_1.default.space(samplerParams.xAxis, samplerParams.range, samplerParams.nSamples);
      const xScale = samplerParams.xScale;
      const yScale = samplerParams.yScale;
      const yMin = yScale.domain()[0];
      const yMax = yScale.domain()[1];
      const samples = [];
      let i;
      for (i = 0; i < xCoords.length - 1; i += 1) {
        const x2 = { lo: xCoords[i], hi: xCoords[i + 1] };
        const y2 = (0, eval_1.interval)(samplerParams.d, "fn", { x: x2 });
        if (!interval_arithmetic_eval_1.Interval.isEmpty(y2) && !interval_arithmetic_eval_1.Interval.isWhole(y2)) {
          samples.push([x2, y2]);
        }
        if (interval_arithmetic_eval_1.Interval.isWhole(y2)) {
          samples.push(null);
        }
      }
      for (i = 1; i < samples.length - 1; i += 1) {
        if (!samples[i]) {
          const prev = samples[i - 1];
          const next = samples[i + 1];
          if (prev && next && !interval_arithmetic_eval_1.Interval.intervalsOverlap(prev[1], next[1])) {
            if (prev[1].lo > next[1].hi) {
              prev[1].hi = Math.max(yMax, prev[1].hi);
              next[1].lo = Math.min(yMin, next[1].lo);
            }
            if (prev[1].hi < next[1].lo) {
              prev[1].lo = Math.min(yMin, prev[1].lo);
              next[1].hi = Math.max(yMax, next[1].hi);
            }
          }
        }
      }
      ;
      samples.scaledDx = xScale(xCoords[1]) - xScale(xCoords[0]);
      return [samples];
    }
    var rectEps;
    function smallRect(x2, y2) {
      return interval_arithmetic_eval_1.Interval.width(x2) < rectEps;
    }
    function quadTree(x2, y2, d) {
      const sample = (0, eval_1.interval)(d, "fn", { x: x2, y: y2 });
      const fulfills = interval_arithmetic_eval_1.Interval.zeroIn(sample);
      if (!fulfills) {
        return this;
      }
      if (smallRect(x2, y2)) {
        this.push([x2, y2]);
        return this;
      }
      const midX = x2.lo + (x2.hi - x2.lo) / 2;
      const midY = y2.lo + (y2.hi - y2.lo) / 2;
      const east = { lo: midX, hi: x2.hi };
      const west = { lo: x2.lo, hi: midX };
      const north = { lo: midY, hi: y2.hi };
      const south = { lo: y2.lo, hi: midY };
      quadTree.call(this, east, north, d);
      quadTree.call(this, east, south, d);
      quadTree.call(this, west, north, d);
      quadTree.call(this, west, south, d);
    }
    function interval2d(samplerParams) {
      const xScale = samplerParams.xScale;
      const xDomain = samplerParams.xScale.domain();
      const yDomain = samplerParams.yScale.domain();
      const x2 = { lo: xDomain[0], hi: xDomain[1] };
      const y2 = { lo: yDomain[0], hi: yDomain[1] };
      const samples = [];
      rectEps = xScale.invert(1) - xScale.invert(0);
      quadTree.call(samples, x2, y2, samplerParams.d);
      samples.scaledDx = 1;
      return [samples];
    }
    var sampler = function sampler2(samplerParams) {
      const fnTypes = {
        implicit: interval2d,
        linear: interval1d
      };
      if (!Object.hasOwn(fnTypes, samplerParams.d.fnType)) {
        throw Error(samplerParams.d.fnType + " is not supported in the `interval` sampler");
      }
      return fnTypes[samplerParams.d.fnType].apply(null, arguments);
    };
    exports.default = sampler;
  }
});

// node_modules/function-plot/dist/samplers/builtIn.js
var require_builtIn = __commonJS({
  "node_modules/function-plot/dist/samplers/builtIn.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = __importDefault(require_utils());
    var eval_1 = require_eval3();
    function checkAsymptote(d0, d1, d, sign4, level) {
      if (!level) {
        return { asymptote: true, d0, d1 };
      }
      const n = 10;
      const x0 = d0[0];
      const x1 = d1[0];
      const samples = utils_1.default.linspace(x0, x1, n);
      let oldY, oldX;
      for (let i = 0; i < n; i += 1) {
        const x2 = samples[i];
        const y2 = (0, eval_1.builtIn)(d, "fn", { x: x2 });
        if (oldY) {
          const deltaY = y2 - oldY;
          const newSign = utils_1.default.sgn(deltaY);
          if (newSign === sign4) {
            return checkAsymptote([oldX, oldY], [x2, y2], d, sign4, level - 1);
          }
        }
        oldY = y2;
        oldX = x2;
      }
      return { asymptote: false, d0, d1 };
    }
    function split(d, data, yScale) {
      let oldSign;
      const evalResult = [];
      const yMin = yScale.domain()[0] - utils_1.default.infinity();
      const yMax = yScale.domain()[1] + utils_1.default.infinity();
      let evalGroup = [data[0]];
      let i = 1;
      let deltaX = utils_1.default.infinity();
      while (i < data.length) {
        const yOld = data[i - 1][1];
        const yNew = data[i][1];
        const deltaY = yNew - yOld;
        const newSign = utils_1.default.sgn(deltaY);
        if (
          // we have at least 2 entries (so that we can compute deltaY)
          evalGroup.length >= 2 && // utils.sgn(y1) * utils.sgn(y0) < 0 && // there's a change in the evaluated values sign
          // there's a change in the slope sign
          oldSign !== newSign && // the slope is bigger to some value (according to the current zoom scale)
          Math.abs(deltaY / deltaX) > 1
        ) {
          const check = checkAsymptote(data[i - 1], data[i], d, newSign, 3);
          if (check.asymptote) {
            data[i - 1][0] = check.d0[0];
            data[i - 1][1] = utils_1.default.clamp(check.d0[1], yMin, yMax);
            evalResult.push(evalGroup);
            data[i][0] = check.d1[0];
            data[i][1] = utils_1.default.clamp(check.d1[1], yMin, yMax);
            evalGroup = [data[i]];
          } else {
            evalGroup.push(data[i]);
          }
        } else {
          evalGroup.push(data[i]);
        }
        if (evalGroup.length > 1) {
          deltaX = evalGroup[evalGroup.length - 1][0] - evalGroup[evalGroup.length - 2][0];
          oldSign = newSign;
        }
        ++i;
      }
      if (evalGroup.length) {
        evalResult.push(evalGroup);
      }
      return evalResult;
    }
    function linear3(samplerParams) {
      const allX = utils_1.default.space(samplerParams.xAxis, samplerParams.range, samplerParams.nSamples);
      const yDomain = samplerParams.yScale.domain();
      const yMin = yDomain[0] - utils_1.default.infinity();
      const yMax = yDomain[1] + utils_1.default.infinity();
      const data = [];
      for (let i = 0; i < allX.length; i += 1) {
        const x2 = allX[i];
        let y2 = (0, eval_1.builtIn)(samplerParams.d, "fn", { x: x2 });
        if (utils_1.default.isValidNumber(x2) && utils_1.default.isValidNumber(y2)) {
          y2 = utils_1.default.clamp(y2, yMin, yMax);
          data.push([x2, y2]);
        }
      }
      const splitData = split(samplerParams.d, data, samplerParams.yScale);
      return splitData;
    }
    function parametric(samplerParams) {
      const parametricRange = samplerParams.d.range || [0, 2 * Math.PI];
      const tCoords = utils_1.default.space(samplerParams.xAxis, parametricRange, samplerParams.nSamples);
      const samples = [];
      for (let i = 0; i < tCoords.length; i += 1) {
        const t = tCoords[i];
        const x2 = (0, eval_1.builtIn)(samplerParams.d, "x", { t });
        const y2 = (0, eval_1.builtIn)(samplerParams.d, "y", { t });
        samples.push([x2, y2]);
      }
      return [samples];
    }
    function polar(samplerParams) {
      const polarRange = samplerParams.d.range || [-Math.PI, Math.PI];
      const thetaSamples = utils_1.default.space(samplerParams.xAxis, polarRange, samplerParams.nSamples);
      const samples = [];
      for (let i = 0; i < thetaSamples.length; i += 1) {
        const theta = thetaSamples[i];
        const r = (0, eval_1.builtIn)(samplerParams.d, "r", { theta });
        const x2 = r * Math.cos(theta);
        const y2 = r * Math.sin(theta);
        samples.push([x2, y2]);
      }
      return [samples];
    }
    function points(samplerParams) {
      return [samplerParams.d.points];
    }
    function vector(sampleParams) {
      const d = sampleParams.d;
      d.offset = d.offset || [0, 0];
      return [[d.offset, [d.vector[0] + d.offset[0], d.vector[1] + d.offset[1]]]];
    }
    var sampler = function sampler2(samplerParams) {
      const fnTypes = {
        parametric,
        polar,
        points,
        vector,
        linear: linear3
      };
      if (!(samplerParams.d.fnType in fnTypes)) {
        throw Error(samplerParams.d.fnType + " is not supported in the `builtIn` sampler");
      }
      return fnTypes[samplerParams.d.fnType].apply(null, arguments);
    };
    exports.default = sampler;
  }
});

// node_modules/function-plot/dist/evaluate.js
var require_evaluate = __commonJS({
  "node_modules/function-plot/dist/evaluate.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals_1 = __importDefault(require_globals());
    var interval_1 = __importDefault(require_interval2());
    var builtIn_1 = __importDefault(require_builtIn());
    function computeEndpoints(scale, d) {
      const range2 = d.range || [-Infinity, Infinity];
      const start2 = Math.max(scale.domain()[0], range2[0]);
      const end = Math.min(scale.domain()[1], range2[1]);
      return [start2, end];
    }
    function evaluate(chart, d) {
      const range2 = computeEndpoints(chart.meta.xScale, d);
      let samplerFn;
      if (d.sampler === "builtIn") {
        samplerFn = builtIn_1.default;
      } else if (d.sampler === "interval") {
        samplerFn = interval_1.default;
      } else {
        throw new Error(`Invalid sampler function ${d.sampler}`);
      }
      const nSamples = d.nSamples || Math.min(globals_1.default.MAX_ITERATIONS, globals_1.default.DEFAULT_ITERATIONS || chart.meta.width * 2);
      const data = samplerFn({
        d,
        range: range2,
        xScale: chart.meta.xScale,
        yScale: chart.meta.yScale,
        xAxis: chart.options.xAxis,
        yAxis: chart.options.yAxis,
        nSamples
      });
      chart.emit("eval", data, d.index, d.isHelper);
      return data;
    }
    exports.default = evaluate;
  }
});

// node_modules/function-plot/dist/graph-types/polyline.js
var require_polyline = __commonJS({
  "node_modules/function-plot/dist/graph-types/polyline.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var d3_shape_1 = (init_src2(), __toCommonJS(src_exports));
    var utils_1 = __importDefault(require_utils());
    var evaluate_1 = __importDefault(require_evaluate());
    function polyline(chart) {
      function plotLine(selection2) {
        selection2.each(function(d) {
          const el = plotLine.el = (0, d3_selection_1.select)(this);
          const index = d.index;
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const color2 = utils_1.default.color(d, index);
          const innerSelection = el.selectAll(":scope > path.line").data(evaluatedData);
          const yRange = chart.meta.yScale.range();
          let yMax = yRange[0];
          let yMin = yRange[1];
          const diff = yMax - yMin;
          yMax += diff * 1e6;
          yMin -= diff * 1e6;
          if (d.skipBoundsCheck) {
            yMax = utils_1.default.infinity();
            yMin = -utils_1.default.infinity();
          }
          function y2(d2) {
            return utils_1.default.clamp(chart.meta.yScale(d2[1]), yMin, yMax);
          }
          const line = (0, d3_shape_1.line)().curve(d3_shape_1.curveLinear).x(function(d2) {
            return chart.meta.xScale(d2[0]);
          }).y(y2);
          const area = (0, d3_shape_1.area)().x(function(d2) {
            return chart.meta.xScale(d2[0]);
          }).y0(chart.meta.yScale(0)).y1(y2);
          const cls = `line line-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("path").attr("class", cls).attr("stroke-width", 1).attr("stroke-linecap", "round");
          innerSelection.merge(innerSelectionEnter).each(function() {
            const path2 = (0, d3_selection_1.select)(this);
            let pathD;
            if (d.closed) {
              path2.attr("fill", color2);
              path2.attr("fill-opacity", 0.3);
              pathD = area;
            } else {
              path2.attr("fill", "none");
              pathD = line;
            }
            path2.attr("stroke", color2).attr("marker-end", function() {
              return d.fnType === "vector" ? "url(#" + chart.markerId + ")" : null;
            }).attr("d", pathD);
            if (d.attr) {
              for (const k2 in d.attr) {
                let val = d.attr[k2];
                if (k2 === "class") {
                  val = `${cls} ${d.attr[k2]}`;
                }
                path2.attr(k2, val);
              }
            }
          });
          innerSelection.exit().remove();
        });
      }
      return plotLine;
    }
    exports.default = polyline;
  }
});

// node_modules/function-plot/dist/graph-types/interval.js
var require_interval3 = __commonJS({
  "node_modules/function-plot/dist/graph-types/interval.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var evaluate_1 = __importDefault(require_evaluate());
    var utils_1 = __importDefault(require_utils());
    function interval2(chart) {
      let minWidthHeight;
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function clampRange(vLo, vHi, gLo, gHi) {
        if (gLo > gHi) {
          const t = gLo;
          gLo = gHi;
          gHi = t;
        }
        const hi = Math.min(vHi, gHi);
        const lo = Math.max(vLo, gLo);
        if (lo > hi) {
          return [-minWidthHeight, 0];
        }
        return [lo, hi];
      }
      const line = function(points, closed) {
        let path2 = "";
        const range2 = yScale.range();
        const minY = Math.min.apply(Math, range2);
        const maxY = Math.max.apply(Math, range2);
        for (let i = 0, length = points.length; i < length; i += 1) {
          if (points[i]) {
            const x2 = points[i][0];
            const y2 = points[i][1];
            let yLo = y2.lo;
            let yHi = y2.hi;
            if (closed) {
              yLo = Math.min(yLo, 0);
              yHi = Math.max(yHi, 0);
            }
            const moveX = xScale(x2.lo) + points.scaledDx / 2;
            const viewportY = clampRange(minY, maxY, isFinite(yHi) ? yScale(yHi) : -Infinity, isFinite(yLo) ? yScale(yLo) : Infinity);
            const vLo = viewportY[0];
            const vHi = viewportY[1];
            path2 += " M " + moveX + " " + vLo;
            path2 += " v " + Math.max(vHi - vLo, minWidthHeight);
          }
        }
        return path2;
      };
      function plotLine(selection2) {
        selection2.each(function(d) {
          const el = plotLine.el = (0, d3_selection_1.select)(this);
          const index = d.index;
          const closed = d.closed;
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const innerSelection = el.selectAll(":scope > path.line").data(evaluatedData);
          minWidthHeight = Math.max(evaluatedData[0].scaledDx, 1);
          const cls = `line line-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("path").attr("class", cls).attr("fill", "none");
          const selection3 = innerSelection.merge(innerSelectionEnter).attr("stroke-width", minWidthHeight).attr("stroke", utils_1.default.color(d, index)).attr("opacity", closed ? 0.5 : 1).attr("d", function(d2) {
            return line(d2, closed);
          });
          if (d.attr) {
            for (const k2 in d.attr) {
              let val = d.attr[k2];
              if (k2 === "class") {
                val = `${cls} ${d.attr[k2]}`;
              }
              selection3.attr(k2, val);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return plotLine;
    }
    exports.default = interval2;
  }
});

// node_modules/function-plot/dist/graph-types/scatter.js
var require_scatter = __commonJS({
  "node_modules/function-plot/dist/graph-types/scatter.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var d3_color_1 = (init_src6(), __toCommonJS(src_exports3));
    var utils_1 = __importDefault(require_utils());
    var evaluate_1 = __importDefault(require_evaluate());
    function Scatter(chart) {
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function scatter2(selection2) {
        selection2.each(function(d) {
          let i, j;
          const index = d.index;
          const color2 = utils_1.default.color(d, index);
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const joined = [];
          for (i = 0; i < evaluatedData.length; i += 1) {
            for (j = 0; j < evaluatedData[i].length; j += 1) {
              joined.push(evaluatedData[i][j]);
            }
          }
          const innerSelection = (0, d3_selection_1.select)(this).selectAll(":scope > circle.scatter").data(joined);
          const cls = `scatter scatter-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("circle").attr("class", cls);
          const selection3 = innerSelection.merge(innerSelectionEnter).attr("fill", (0, d3_color_1.hsl)(color2.toString()).brighter(1.5).formatHex()).attr("stroke", color2).attr("opacity", 0.7).attr("r", 1).attr("cx", function(d2) {
            return xScale(d2[0]);
          }).attr("cy", function(d2) {
            return yScale(d2[1]);
          });
          if (d.attr) {
            for (const k2 in d.attr) {
              let val = d.attr[k2];
              if (k2 === "class") {
                val = `${cls} ${d.attr[k2]}`;
              }
              selection3.attr(k2, val);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return scatter2;
    }
    exports.default = Scatter;
  }
});

// node_modules/function-plot/dist/graph-types/text.js
var require_text = __commonJS({
  "node_modules/function-plot/dist/graph-types/text.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var d3_color_1 = (init_src6(), __toCommonJS(src_exports3));
    var utils_1 = __importDefault(require_utils());
    function Text(chart) {
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function text(selection2) {
        selection2.each(function(d) {
          d.sampler = "builtIn";
          d.fnType = "vector";
          const innerSelection = (0, d3_selection_1.select)(this).selectAll(":scope > text.fn-text").data([d.location]);
          const innerSelectionEnter = innerSelection.enter().append("text").attr("class", `fn-text fn-text-${d.index}`);
          const color2 = utils_1.default.color(d, d.index);
          const selection3 = innerSelection.merge(innerSelectionEnter).attr("fill", (0, d3_color_1.hsl)(color2.toString()).brighter(1.5).formatHex()).attr("x", (d2) => xScale(d2[0])).attr("y", (d2) => yScale(d2[1])).text(() => d.text);
          if (d.attr) {
            for (const k2 in d.attr) {
              selection3.attr(k2, d.attr[k2]);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return text;
    }
    exports.default = Text;
  }
});

// node_modules/function-plot/dist/graph-types/index.js
var require_graph_types = __commonJS({
  "node_modules/function-plot/dist/graph-types/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.text = exports.scatter = exports.interval = exports.polyline = void 0;
    var polyline_1 = __importDefault(require_polyline());
    exports.polyline = polyline_1.default;
    var interval_1 = __importDefault(require_interval3());
    exports.interval = interval_1.default;
    var scatter_1 = __importDefault(require_scatter());
    exports.scatter = scatter_1.default;
    var text_1 = __importDefault(require_text());
    exports.text = text_1.default;
  }
});

// node_modules/function-plot/dist/datum-defaults.js
var require_datum_defaults = __commonJS({
  "node_modules/function-plot/dist/datum-defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function datumDefaults(d) {
      if (!("graphType" in d)) {
        d.graphType = "interval";
      }
      if (!("sampler" in d)) {
        d.sampler = d.graphType !== "interval" ? "builtIn" : "interval";
      }
      if (!("fnType" in d)) {
        d.fnType = "linear";
      }
      return d;
    }
    exports.default = datumDefaults;
  }
});

// node_modules/function-plot/dist/helpers/derivative.js
var require_derivative = __commonJS({
  "node_modules/function-plot/dist/helpers/derivative.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var graph_types_1 = require_graph_types();
    var eval_1 = require_eval3();
    var datum_defaults_1 = __importDefault(require_datum_defaults());
    var utils_1 = __importDefault(require_utils());
    function derivative(chart) {
      const derivativeDatum = (0, datum_defaults_1.default)({
        isHelper: true,
        skipTip: true,
        skipBoundsCheck: true,
        nSamples: 2,
        graphType: "polyline"
      });
      function computeLine(d) {
        if (!d.derivative) {
          return [];
        }
        const x0 = typeof d.derivative.x0 === "number" ? d.derivative.x0 : utils_1.default.infinity();
        derivativeDatum.index = d.index;
        derivativeDatum.scope = {
          m: (0, eval_1.builtIn)(d.derivative, "fn", { x: x0 }),
          x0,
          y0: (0, eval_1.builtIn)(d, "fn", { x: x0 })
        };
        derivativeDatum.fn = "m * (x - x0) + y0";
        return [derivativeDatum];
      }
      function checkAutoUpdate(d) {
        const self2 = this;
        if (!d.derivative) {
          return;
        }
        if (d.derivative.updateOnMouseMove && !d.derivative.$$mouseListener) {
          d.derivative.$$mouseListener = function({ x: x2 }) {
            if (d.derivative) {
              d.derivative.x0 = x2;
            }
            derivative2(self2);
          };
          chart.on("tip:update", d.derivative.$$mouseListener);
        }
      }
      const derivative2 = function(selection2) {
        selection2.each(function(d) {
          const el = (0, d3_selection_1.select)(this);
          const data = computeLine.call(selection2, d);
          checkAutoUpdate.call(selection2, d);
          const innerSelection = el.selectAll("g.derivative").data(data);
          const innerSelectionEnter = innerSelection.enter().append("g").attr("class", "derivative");
          innerSelection.merge(innerSelectionEnter).call((0, graph_types_1.polyline)(chart));
          innerSelection.merge(innerSelectionEnter).selectAll("path").attr("opacity", 0.5);
          innerSelection.exit().remove();
        });
      };
      return derivative2;
    }
    exports.default = derivative;
  }
});

// node_modules/function-plot/dist/helpers/secant.js
var require_secant = __commonJS({
  "node_modules/function-plot/dist/helpers/secant.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var eval_1 = require_eval3();
    var datum_defaults_1 = __importDefault(require_datum_defaults());
    var graph_types_1 = require_graph_types();
    var utils_1 = __importDefault(require_utils());
    function secant(chart) {
      const secantDefaults = (0, datum_defaults_1.default)({
        isHelper: true,
        skipTip: true,
        skipBoundsCheck: true,
        nSamples: 2,
        graphType: "polyline"
      });
      function computeSlope(scope) {
        scope.m = (scope.y1 - scope.y0) / (scope.x1 - scope.x0);
      }
      function updateLine(d, secant3) {
        if (!("x0" in secant3)) {
          throw Error("secant must have the property `x0` defined");
        }
        secant3.scope = secant3.scope || {};
        const x0 = secant3.x0;
        const x1 = typeof secant3.x1 === "number" ? secant3.x1 : utils_1.default.infinity();
        Object.assign(secant3.scope, {
          x0,
          x1,
          y0: (0, eval_1.builtIn)(d, "fn", { x: x0 }),
          y1: (0, eval_1.builtIn)(d, "fn", { x: x1 })
        });
        computeSlope(secant3.scope);
      }
      function setFn(d, secant3) {
        updateLine(d, secant3);
        secant3.fn = "m * (x - x0) + y0";
      }
      function setMouseListener(d, secantObject) {
        const self2 = this;
        if (secantObject.updateOnMouseMove && !secantObject.$$mouseListener) {
          secantObject.$$mouseListener = function({ x: x2 }) {
            secantObject.x1 = x2;
            updateLine(d, secantObject);
            secant2(self2);
          };
          chart.on("tip:update", secantObject.$$mouseListener);
        }
      }
      function computeLines(d) {
        const self2 = this;
        const data = [];
        d.secants = d.secants || [];
        for (let i = 0; i < d.secants.length; i += 1) {
          const secant3 = d.secants[i] = Object.assign({}, secantDefaults, d.secants[i]);
          secant3.index = d.index;
          if (!secant3.fn) {
            setFn.call(self2, d, secant3);
            setMouseListener.call(self2, d, secant3);
          }
          data.push(secant3);
        }
        return data;
      }
      function secant2(selection2) {
        selection2.each(function(d) {
          const el = (0, d3_selection_1.select)(this);
          const data = computeLines.call(selection2, d);
          const innerSelection = el.selectAll("g.secant").data(data);
          const innerSelectionEnter = innerSelection.enter().append("g").attr("class", "secant");
          innerSelection.merge(innerSelectionEnter).call((0, graph_types_1.polyline)(chart));
          innerSelection.merge(innerSelectionEnter).selectAll("path").attr("opacity", 0.5);
          innerSelection.exit().remove();
        });
      }
      return secant2;
    }
    exports.default = secant;
  }
});

// node_modules/function-plot/dist/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/function-plot/dist/helpers/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var derivative_1 = __importDefault(require_derivative());
    var secant_1 = __importDefault(require_secant());
    function helpers(chart) {
      function helper(selection2) {
        selection2.each(function() {
          const el = (0, d3_selection_1.select)(this);
          el.call((0, derivative_1.default)(chart));
          el.call((0, secant_1.default)(chart));
        });
      }
      return helper;
    }
    exports.default = helpers;
  }
});

// node_modules/function-plot/dist/chart.js
var require_chart = __commonJS({
  "node_modules/function-plot/dist/chart.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chart = void 0;
    var d3_shape_1 = (init_src2(), __toCommonJS(src_exports));
    var d3_format_1 = (init_src3(), __toCommonJS(src_exports2));
    var d3_scale_1 = (init_src10(), __toCommonJS(src_exports5));
    var d3_axis_1 = (init_src11(), __toCommonJS(src_exports6));
    var d3_zoom_1 = (init_src18(), __toCommonJS(src_exports8));
    var d3_selection_1 = (init_src13(), __toCommonJS(src_exports7));
    var d3_interpolate_1 = (init_src7(), __toCommonJS(src_exports4));
    var events_1 = __importDefault(require("events"));
    var annotations_1 = __importDefault(require_annotations());
    var tip_1 = __importDefault(require_tip());
    var helpers_1 = __importDefault(require_helpers());
    var datum_defaults_1 = __importDefault(require_datum_defaults());
    var globals_1 = __importDefault(require_globals());
    function getD3Scale(type) {
      if (type === "linear")
        return d3_scale_1.scaleLinear;
      return d3_scale_1.scaleLog;
    }
    var Chart = class extends events_1.default.EventEmitter {
      constructor(options) {
        super();
        const n = Math.random();
        const letter = String.fromCharCode(Math.floor(n * 26) + 97);
        this.options = options;
        this.id = letter + n.toString(16).substr(2);
        this.options.id = this.id;
        this.markerId = this.id + "-marker";
        Chart.cache[this.id] = this;
        this.linkedGraphs = [this];
        this.meta = {};
        this.setUpEventListeners();
      }
      /**
       * Rebuilds the entire graph from scratch recomputing
       *
       * - the inner width/height
       * - scales/axes
       *
       * After this is done it does a complete redraw of all the datums,
       * if only the datums need to be redrawn call `instance.draw()` instead
       *
       * @returns Chart
       */
      build() {
        this.internalVars();
        this.drawGraphWrapper();
        return this;
      }
      getDraggableNode() {
        return (0, d3_selection_1.select)(this.options.target).select(".zoom-and-drag").node();
      }
      /**
       * The draggable container won't change across different instances of Chart,
       * therefore multiple instances will share the draggable container, to avoid dispatching
       * the event from the old instance grab it in runtime with this function
       */
      getEmitInstance() {
        let cachedInstance = this;
        const cachedNode = this.getDraggableNode();
        if (cachedNode) {
          cachedInstance = cachedNode.instance;
        }
        return cachedInstance;
      }
      internalVars() {
        const margin = this.meta.margin = { left: 40, right: 20, top: 20, bottom: 20 };
        if (this.options.title) {
          this.meta.margin.top = 40;
        }
        this.meta.width = (this.options.width || globals_1.default.DEFAULT_WIDTH) - margin.left - margin.right;
        this.meta.height = (this.options.height || globals_1.default.DEFAULT_HEIGHT) - margin.top - margin.bottom;
        this.initializeAxes();
      }
      initializeAxes() {
        const self2 = this;
        const integerFormat = (0, d3_format_1.format)("~s");
        function formatter(d) {
          const frac = Math.abs(d) - Math.floor(Math.abs(d));
          if (frac > 0) {
            return d.toString();
          } else {
            return integerFormat(d);
          }
        }
        function computeYScale(xScale) {
          const xDiff = xScale[1] - xScale[0];
          return self2.meta.height * xDiff / self2.meta.width;
        }
        this.options.xAxis = this.options.xAxis || {};
        this.options.xAxis.type = this.options.xAxis.type || "linear";
        this.options.yAxis = this.options.yAxis || {};
        this.options.yAxis.type = this.options.yAxis.type || "linear";
        const xDomain = this.meta.xDomain = function(axis2) {
          if (axis2.domain) {
            return axis2.domain;
          }
          if (axis2.type === "linear") {
            const xLimit = 12;
            return [-xLimit / 2, xLimit / 2];
          } else if (axis2.type === "log") {
            return [1, 10];
          }
          throw Error("axis type " + axis2.type + " unsupported");
        }(this.options.xAxis);
        const yDomain = this.meta.yDomain = function(axis2) {
          if (axis2.domain) {
            return axis2.domain;
          }
          const yLimit = computeYScale(xDomain);
          if (axis2.type === "linear") {
            return [-yLimit / 2, yLimit / 2];
          } else if (axis2.type === "log") {
            return [1, 10];
          }
          throw Error("axis type " + axis2.type + " unsupported");
        }(this.options.yAxis);
        if (!this.meta.xScale) {
          this.meta.xScale = getD3Scale(this.options.xAxis.type)();
        }
        this.meta.xScale.domain(xDomain).range(this.options.xAxis.invert ? [this.meta.width, 0] : [0, this.meta.width]);
        if (!this.meta.yScale) {
          this.meta.yScale = getD3Scale(this.options.yAxis.type)();
        }
        this.meta.yScale.domain(yDomain).range(this.options.yAxis.invert ? [0, this.meta.height] : [this.meta.height, 0]);
        if (!this.meta.xAxis) {
          this.meta.xAxis = (0, d3_axis_1.axisBottom)(this.meta.xScale);
        }
        this.meta.xAxis.tickSize(this.options.grid ? -this.meta.height : 0).tickFormat(formatter);
        if (!this.meta.yAxis) {
          this.meta.yAxis = (0, d3_axis_1.axisLeft)(this.meta.yScale);
        }
        this.meta.yAxis.tickSize(this.options.grid ? -this.meta.width : 0).tickFormat(formatter);
        this.line = (0, d3_shape_1.line)().x(function(d) {
          return self2.meta.xScale(d[0]);
        }).y(function(d) {
          return self2.meta.yScale(d[1]);
        });
      }
      drawGraphWrapper() {
        const root2 = this.root = (0, d3_selection_1.select)(this.options.target).selectAll("svg").data([this.options]);
        this.root.enter = root2.enter().append("svg").attr("class", "function-plot").attr("font-size", this.getFontSize());
        root2.merge(this.root.enter).attr("width", this.meta.width + this.meta.margin.left + this.meta.margin.right).attr("height", this.meta.height + this.meta.margin.top + this.meta.margin.bottom);
        this.buildTitle();
        this.buildLegend();
        this.buildCanvas();
        this.buildClip();
        this.buildAxis();
        this.buildAxisLabel();
        const tip = this.tip = (0, tip_1.default)(Object.assign(this.options.tip || {}, { owner: this }));
        this.canvas.merge(this.canvas.enter).call(tip);
        this.setUpPlugins();
        this.draw();
        this.buildZoomHelper();
      }
      buildTitle() {
        const selection2 = this.root.merge(this.root.enter).selectAll("text.title").data(function(d) {
          return [d.title].filter(Boolean);
        });
        const selectionEnter = selection2.enter().append("text");
        selectionEnter.merge(selection2).attr("class", "title").attr("y", this.meta.margin.top / 2).attr("x", this.meta.margin.left + this.meta.width / 2).attr("font-size", 25).attr("text-anchor", "middle").attr("alignment-baseline", "middle").text(this.options.title);
        selection2.exit().remove();
      }
      buildLegend() {
        this.root.enter.append("text").attr("class", "top-right-legend").attr("text-anchor", "end");
        this.root.merge(this.root.enter).select(".top-right-legend").attr("y", this.meta.margin.top / 2).attr("x", this.meta.width + this.meta.margin.left);
      }
      buildCanvas() {
        const canvas = this.canvas = this.root.merge(this.root.enter).selectAll(".canvas").data(function(d) {
          return [d];
        });
        this.canvas.enter = canvas.enter().append("g").attr("class", "canvas");
      }
      buildClip() {
        const id2 = this.id;
        const defs = this.canvas.enter.append("defs");
        defs.append("clipPath").attr("id", "function-plot-clip-" + id2).append("rect").attr("class", "clip static-clip");
        this.canvas.merge(this.canvas.enter).selectAll(".clip").attr("width", this.meta.width).attr("height", this.meta.height);
        defs.append("clipPath").append("marker").attr("id", this.markerId).attr("viewBox", "0 -5 10 10").attr("refX", 10).attr("markerWidth", 5).attr("markerHeight", 5).attr("orient", "auto").append("svg:path").attr("d", "M0,-5L10,0L0,5L0,0").attr("stroke-width", "0px").attr("fill-opacity", 1).attr("fill", "#777");
      }
      buildAxis() {
        const canvasEnter = this.canvas.enter;
        canvasEnter.append("g").attr("class", "x axis");
        canvasEnter.append("g").attr("class", "y axis");
        this.canvas.merge(this.canvas.enter).select(".x.axis").attr("transform", "translate(0," + this.meta.height + ")").call(this.meta.xAxis);
        this.canvas.merge(this.canvas.enter).select(".y.axis").call(this.meta.yAxis);
      }
      buildAxisLabel() {
        const canvas = this.canvas;
        const xLabel = canvas.merge(canvas.enter).selectAll("text.x.axis-label").data(function(d) {
          return [d.xAxis.label].filter(Boolean);
        });
        const xLabelEnter = xLabel.enter().append("text").attr("class", "x axis-label").attr("text-anchor", "end");
        xLabel.merge(xLabelEnter).attr("x", this.meta.width).attr("y", this.meta.height - 6).text(function(d) {
          return d;
        });
        xLabel.exit().remove();
        const yLabel = canvas.merge(canvas.enter).selectAll("text.y.axis-label").data(function(d) {
          return [d.yAxis.label].filter(Boolean);
        });
        const yLabelEnter = yLabel.enter().append("text").attr("class", "y axis-label").attr("y", 6).attr("dy", ".75em").attr("text-anchor", "end").attr("transform", "rotate(-90)");
        yLabel.merge(yLabelEnter).text(function(d) {
          return d;
        });
        yLabel.exit().remove();
      }
      /**
       * @private
       *
       * Draws each of the datums stored in data.options, to do a full
       * redraw call `instance.draw()`
       */
      buildContent() {
        const self2 = this;
        const canvas = this.canvas;
        canvas.merge(canvas.enter).attr("transform", "translate(" + this.meta.margin.left + "," + this.meta.margin.top + ")");
        const content = this.content = canvas.merge(canvas.enter).selectAll(":scope > g.content").data(function(d) {
          return [d];
        });
        const contentEnter = content.enter().append("g").attr("clip-path", "url(#function-plot-clip-" + this.id + ")").attr("class", "content");
        if (this.options.xAxis.type === "linear") {
          const yOrigin = content.merge(contentEnter).selectAll(":scope > path.y.origin").data([
            [
              [0, this.meta.yScale.domain()[0]],
              [0, this.meta.yScale.domain()[1]]
            ]
          ]);
          const yOriginEnter = yOrigin.enter().append("path").attr("class", "y origin").attr("stroke", "black").attr("opacity", 0.2);
          yOrigin.merge(yOriginEnter).attr("d", this.line);
        }
        if (this.options.yAxis.type === "linear") {
          const xOrigin = content.merge(contentEnter).selectAll(":scope > path.x.origin").data([
            [
              [this.meta.xScale.domain()[0], 0],
              [this.meta.xScale.domain()[1], 0]
            ]
          ]);
          const xOriginEnter = xOrigin.enter().append("path").attr("class", "x origin").attr("stroke", "black").attr("opacity", 0.2);
          xOrigin.merge(xOriginEnter).attr("d", this.line);
        }
        content.merge(contentEnter).call((0, annotations_1.default)({ owner: self2 }));
        const graphs = content.merge(contentEnter).selectAll(":scope > g.graph").data((d) => {
          return d.data.map(datum_defaults_1.default);
        }, (d) => {
          return d.fn || d.r || d.x || d.text;
        });
        graphs.exit().remove();
        const graphsEnter = graphs.enter().append("g").attr("class", "graph");
        graphs.merge(graphsEnter).each(function(d, index) {
          d.index = index;
          const selection2 = (0, d3_selection_1.select)(this);
          selection2.call(globals_1.default.graphTypes[d.graphType](self2));
          selection2.call((0, helpers_1.default)(self2));
        });
      }
      buildZoomHelper() {
        const self2 = this;
        if (!this.meta.zoomBehavior) {
          this.meta.zoomBehavior = (0, d3_zoom_1.zoom)().on("zoom", function onZoom(ev) {
            self2.getEmitInstance().emit("all:zoom", ev);
          });
          self2.meta.zoomBehavior.xScale = self2.meta.xScale.copy();
          self2.meta.zoomBehavior.yScale = self2.meta.yScale.copy();
        }
        self2.meta.zoomBehavior.xScale.range(self2.meta.xScale.range());
        self2.meta.zoomBehavior.yScale.range(self2.meta.yScale.range());
        this.canvas.enter.append("rect").call(this.meta.zoomBehavior).attr("class", "zoom-and-drag").style("fill", "none").style("pointer-events", "all").on("mouseover", function(event) {
          self2.getEmitInstance().emit("all:mouseover", event);
        }).on("mouseout", function(event) {
          self2.getEmitInstance().emit("all:mouseout", event);
        }).on("mousemove", function(event) {
          self2.getEmitInstance().emit("all:mousemove", event);
        });
        this.draggable = this.canvas.merge(this.canvas.enter).select(".zoom-and-drag").call((selection2) => {
          if (selection2.node()) {
            selection2.node().instance = self2;
          }
        }).attr("width", this.meta.width).attr("height", this.meta.height);
      }
      setUpPlugins() {
        const plugins = this.options.plugins || [];
        const self2 = this;
        plugins.forEach(function(plugin) {
          plugin(self2);
        });
      }
      addLink() {
        for (let i = 0; i < arguments.length; i += 1) {
          this.linkedGraphs.push(arguments[i]);
        }
      }
      updateAxes() {
        const instance = this;
        const canvas = instance.canvas.merge(instance.canvas.enter);
        canvas.select(".x.axis").call(instance.meta.xAxis);
        if (this.options.xAxis.position === "sticky") {
          const yMin = this.meta.yScale.domain()[0];
          const yMax = this.meta.yScale.domain()[1];
          const yMid = (yMax + yMin) / 2;
          const yScaleFactor = this.meta.height / (yMax - yMin);
          let yTranslation = yScaleFactor * yMid + this.meta.height / 2;
          yTranslation = yTranslation < 0 ? 0 : yTranslation;
          yTranslation = yTranslation > this.meta.height ? this.meta.height : yTranslation;
          canvas.select(".x.axis").attr("transform", "translate(0," + yTranslation + ")");
          canvas.selectAll(".x.axis path, .x.axis line").attr("transform", "translate(0," + (this.meta.height / 2 - yTranslation + this.meta.height / 2) + ")");
        }
        canvas.select(".y.axis").call(instance.meta.yAxis);
        if (this.options.yAxis.position === "sticky") {
          const xMin = this.meta.xScale.domain()[0];
          const xMax = this.meta.xScale.domain()[1];
          const xMid = (xMax + xMin) / 2;
          const xScaleFactor = this.meta.width / (xMin - xMax);
          let xTranslation = xScaleFactor * xMid + this.meta.width / 2;
          xTranslation = xTranslation < 0 ? 0 : xTranslation;
          xTranslation = xTranslation > this.meta.width ? this.meta.width : xTranslation;
          canvas.select(".y.axis").attr("transform", "translate(" + xTranslation + ",0)");
          canvas.selectAll(".y.axis path, .y.axis line").attr("transform", "translate(" + -xTranslation + ",0)");
        }
        canvas.selectAll(".axis path, .axis line").attr("fill", "none").attr("stroke", "black").attr("shape-rendering", "crispedges").attr("opacity", 0.1);
      }
      syncOptions() {
        this.options.xAxis.domain = this.meta.xScale.domain();
        this.options.yAxis.domain = this.meta.yScale.domain();
      }
      getFontSize() {
        return Math.max(Math.max(this.meta.width, this.meta.height) / 50, 8);
      }
      draw() {
        const instance = this;
        instance.emit("before:draw");
        instance.syncOptions();
        instance.updateAxes();
        instance.buildContent();
        instance.emit("after:draw");
      }
      setUpEventListeners() {
        const self2 = this;
        const prevInstance = this.getEmitInstance();
        if (prevInstance) {
          prevInstance.removeAllListeners();
        }
        const events = {
          mousemove: function(coordinates) {
            self2.tip.move(coordinates);
          },
          mouseover: function() {
            self2.tip.show();
          },
          mouseout: function() {
            self2.tip.hide();
          },
          zoom: function zoom({ transform: transform2 }) {
            if (self2.options.disableZoom)
              return;
            const xScaleClone = transform2.rescaleX(self2.meta.zoomBehavior.xScale).interpolate(d3_interpolate_1.interpolateRound);
            const yScaleClone = transform2.rescaleY(self2.meta.zoomBehavior.yScale).interpolate(d3_interpolate_1.interpolateRound);
            self2.meta.xScale.domain(xScaleClone.domain()).range(xScaleClone.range());
            self2.meta.yScale.domain(yScaleClone.domain()).range(yScaleClone.range());
          },
          "tip:update": function({ x: x2, y: y2, index }) {
            const meta = self2.root.merge(self2.root.enter).datum().data[index];
            const title = meta.title || "";
            const format6 = meta.renderer || function(x3, y3) {
              return x3.toFixed(3) + ", " + y3.toFixed(3);
            };
            const text = [];
            title && text.push(title);
            text.push(format6(x2, y2));
            self2.root.select(".top-right-legend").attr("fill", globals_1.default.COLORS[index]).text(text.join(" "));
          }
        };
        const all2 = {
          mousemove: function(event) {
            const mouse = (0, d3_selection_1.pointer)(event, self2.draggable.node());
            const coordinates = {
              x: self2.meta.xScale.invert(mouse[0]),
              y: self2.meta.yScale.invert(mouse[1])
            };
            self2.linkedGraphs.forEach(function(graph) {
              graph.emit("before:mousemove", coordinates);
              graph.emit("mousemove", coordinates);
            });
          },
          zoom: function(event) {
            self2.linkedGraphs.forEach(function(graph) {
              graph.draggable.node().__zoom = self2.draggable.node().__zoom;
              graph.emit("zoom", event);
              graph.draw();
            });
            self2.emit("all:mousemove", event);
          }
        };
        Object.keys(events).forEach(function(e3) {
          !all2[e3] && self2.on("all:" + e3, function() {
            const args = Array.prototype.slice.call(arguments);
            self2.linkedGraphs.forEach(function(graph) {
              const localArgs = args.slice();
              localArgs.unshift(e3);
              graph.emit.apply(graph, localArgs);
            });
          });
          self2.on(e3, events[e3]);
        });
        Object.keys(all2).forEach(function(e3) {
          self2.on("all:" + e3, all2[e3]);
        });
      }
    };
    exports.Chart = Chart;
    Chart.cache = {};
  }
});

// node_modules/function-plot/dist/types.js
var require_types = __commonJS({
  "node_modules/function-plot/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/function-plot/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/function-plot/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphTypeScatter = exports.GraphTypePolyline = exports.GraphTypeInterval = exports.EvalInterval = exports.EvalBuiltIn = exports.registerGraphType = exports.Chart = void 0;
    require_polyfills();
    var chart_1 = require_chart();
    Object.defineProperty(exports, "Chart", { enumerable: true, get: function() {
      return chart_1.Chart;
    } });
    var globals_1 = __importStar(require_globals());
    Object.defineProperty(exports, "registerGraphType", { enumerable: true, get: function() {
      return globals_1.registerGraphType;
    } });
    var graph_types_1 = require_graph_types();
    var $eval = __importStar(require_eval3());
    (0, globals_1.registerGraphType)("polyline", graph_types_1.polyline);
    (0, globals_1.registerGraphType)("interval", graph_types_1.interval);
    (0, globals_1.registerGraphType)("scatter", graph_types_1.scatter);
    (0, globals_1.registerGraphType)("text", graph_types_1.text);
    function functionPlot2(options) {
      options.data = options.data || [];
      let instance = chart_1.Chart.cache[options.id];
      if (!instance) {
        instance = new chart_1.Chart(options);
      }
      return instance.build();
    }
    exports.default = functionPlot2;
    functionPlot2.globals = globals_1.default;
    functionPlot2.$eval = $eval;
    functionPlot2.graphTypes = { interval: graph_types_1.interval, polyline: graph_types_1.polyline, scatter: graph_types_1.scatter };
    __exportStar(require_types(), exports);
    var eval_1 = require_eval3();
    Object.defineProperty(exports, "EvalBuiltIn", { enumerable: true, get: function() {
      return eval_1.builtIn;
    } });
    Object.defineProperty(exports, "EvalInterval", { enumerable: true, get: function() {
      return eval_1.interval;
    } });
    var graph_types_2 = require_graph_types();
    Object.defineProperty(exports, "GraphTypeInterval", { enumerable: true, get: function() {
      return graph_types_2.interval;
    } });
    Object.defineProperty(exports, "GraphTypePolyline", { enumerable: true, get: function() {
      return graph_types_2.polyline;
    } });
    Object.defineProperty(exports, "GraphTypeScatter", { enumerable: true, get: function() {
      return graph_types_2.scatter;
    } });
    __exportStar(require_helpers(), exports);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EnhancedMathPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t = arguments[e3];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/mathjs/lib/esm/core/config.js
var DEFAULT_CONFIG = {
  // minimum relative difference between two compared values,
  // used by all comparison functions
  epsilon: 1e-12,
  // type of default matrix output. Choose 'matrix' (default) or 'array'
  matrix: "Matrix",
  // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
  number: "number",
  // number of significant digits in BigNumbers
  precision: 64,
  // predictable output type of functions. When true, output type depends only
  // on the input types. When false (default), output type can vary depending
  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
  // predictable is false, and returns `NaN` when true.
  predictable: false,
  // random seed for seeded pseudo random number generation
  // null = randomly seed
  randomSeed: null
};

// node_modules/mathjs/lib/esm/utils/is.js
function isNumber(x2) {
  return typeof x2 === "number";
}
function isBigNumber(x2) {
  if (!x2 || typeof x2 !== "object" || typeof x2.constructor !== "function") {
    return false;
  }
  if (x2.isBigNumber === true && typeof x2.constructor.prototype === "object" && x2.constructor.prototype.isBigNumber === true) {
    return true;
  }
  if (typeof x2.constructor.isDecimal === "function" && x2.constructor.isDecimal(x2) === true) {
    return true;
  }
  return false;
}
function isComplex(x2) {
  return x2 && typeof x2 === "object" && Object.getPrototypeOf(x2).isComplex === true || false;
}
function isFraction(x2) {
  return x2 && typeof x2 === "object" && Object.getPrototypeOf(x2).isFraction === true || false;
}
function isUnit(x2) {
  return x2 && x2.constructor.prototype.isUnit === true || false;
}
function isString(x2) {
  return typeof x2 === "string";
}
var isArray = Array.isArray;
function isMatrix(x2) {
  return x2 && x2.constructor.prototype.isMatrix === true || false;
}
function isCollection(x2) {
  return Array.isArray(x2) || isMatrix(x2);
}
function isDenseMatrix(x2) {
  return x2 && x2.isDenseMatrix && x2.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x2) {
  return x2 && x2.isSparseMatrix && x2.constructor.prototype.isMatrix === true || false;
}
function isRange(x2) {
  return x2 && x2.constructor.prototype.isRange === true || false;
}
function isIndex(x2) {
  return x2 && x2.constructor.prototype.isIndex === true || false;
}
function isBoolean(x2) {
  return typeof x2 === "boolean";
}
function isResultSet(x2) {
  return x2 && x2.constructor.prototype.isResultSet === true || false;
}
function isHelp(x2) {
  return x2 && x2.constructor.prototype.isHelp === true || false;
}
function isFunction(x2) {
  return typeof x2 === "function";
}
function isDate(x2) {
  return x2 instanceof Date;
}
function isRegExp(x2) {
  return x2 instanceof RegExp;
}
function isObject(x2) {
  return !!(x2 && typeof x2 === "object" && x2.constructor === Object && !isComplex(x2) && !isFraction(x2));
}
function isNull(x2) {
  return x2 === null;
}
function isUndefined(x2) {
  return x2 === void 0;
}
function isAccessorNode(x2) {
  return x2 && x2.isAccessorNode === true && x2.constructor.prototype.isNode === true || false;
}
function isArrayNode(x2) {
  return x2 && x2.isArrayNode === true && x2.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x2) {
  return x2 && x2.isAssignmentNode === true && x2.constructor.prototype.isNode === true || false;
}
function isBlockNode(x2) {
  return x2 && x2.isBlockNode === true && x2.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x2) {
  return x2 && x2.isConditionalNode === true && x2.constructor.prototype.isNode === true || false;
}
function isConstantNode(x2) {
  return x2 && x2.isConstantNode === true && x2.constructor.prototype.isNode === true || false;
}
function rule2Node(node) {
  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
}
function isFunctionAssignmentNode(x2) {
  return x2 && x2.isFunctionAssignmentNode === true && x2.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x2) {
  return x2 && x2.isFunctionNode === true && x2.constructor.prototype.isNode === true || false;
}
function isIndexNode(x2) {
  return x2 && x2.isIndexNode === true && x2.constructor.prototype.isNode === true || false;
}
function isNode(x2) {
  return x2 && x2.isNode === true && x2.constructor.prototype.isNode === true || false;
}
function isObjectNode(x2) {
  return x2 && x2.isObjectNode === true && x2.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x2) {
  return x2 && x2.isOperatorNode === true && x2.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x2) {
  return x2 && x2.isParenthesisNode === true && x2.constructor.prototype.isNode === true || false;
}
function isRangeNode(x2) {
  return x2 && x2.isRangeNode === true && x2.constructor.prototype.isNode === true || false;
}
function isRelationalNode(x2) {
  return x2 && x2.isRelationalNode === true && x2.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x2) {
  return x2 && x2.isSymbolNode === true && x2.constructor.prototype.isNode === true || false;
}
function isChain(x2) {
  return x2 && x2.constructor.prototype.isChain === true || false;
}
function typeOf(x2) {
  var t = typeof x2;
  if (t === "object") {
    if (x2 === null)
      return "null";
    if (isBigNumber(x2))
      return "BigNumber";
    if (x2.constructor && x2.constructor.name)
      return x2.constructor.name;
    return "Object";
  }
  return t;
}

// node_modules/mathjs/lib/esm/utils/object.js
function clone(x2) {
  var type = typeof x2;
  if (type === "number" || type === "string" || type === "boolean" || x2 === null || x2 === void 0) {
    return x2;
  }
  if (typeof x2.clone === "function") {
    return x2.clone();
  }
  if (Array.isArray(x2)) {
    return x2.map(function(value) {
      return clone(value);
    });
  }
  if (x2 instanceof Date)
    return new Date(x2.valueOf());
  if (isBigNumber(x2))
    return x2;
  if (isObject(x2)) {
    return mapObject(x2, clone);
  }
  throw new TypeError("Cannot clone: unknown type of value (value: ".concat(x2, ")"));
}
function mapObject(object, callback) {
  var clone4 = {};
  for (var key in object) {
    if (hasOwnProperty(object, key)) {
      clone4[key] = callback(object[key]);
    }
  }
  return clone4;
}
function extend(a2, b) {
  for (var prop in b) {
    if (hasOwnProperty(b, prop)) {
      a2[prop] = b[prop];
    }
  }
  return a2;
}
function deepExtend(a2, b) {
  if (Array.isArray(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }
  for (var prop in b) {
    if (hasOwnProperty(b, prop) && !(prop in Object.prototype) && !(prop in Function.prototype)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a2[prop] === void 0) {
          a2[prop] = {};
        }
        if (a2[prop] && a2[prop].constructor === Object) {
          deepExtend(a2[prop], b[prop]);
        } else {
          a2[prop] = b[prop];
        }
      } else if (Array.isArray(b[prop])) {
        throw new TypeError("Arrays are not supported by deepExtend");
      } else {
        a2[prop] = b[prop];
      }
    }
  }
  return a2;
}
function deepStrictEqual(a2, b) {
  var prop, i, len;
  if (Array.isArray(a2)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a2.length !== b.length) {
      return false;
    }
    for (i = 0, len = a2.length; i < len; i++) {
      if (!deepStrictEqual(a2[i], b[i])) {
        return false;
      }
    }
    return true;
  } else if (typeof a2 === "function") {
    return a2 === b;
  } else if (a2 instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    for (prop in a2) {
      if (!(prop in b) || !deepStrictEqual(a2[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      if (!(prop in a2)) {
        return false;
      }
    }
    return true;
  } else {
    return a2 === b;
  }
}
function deepFlatten(nestedObject) {
  var flattenedObject = {};
  _deepFlatten(nestedObject, flattenedObject);
  return flattenedObject;
}
function _deepFlatten(nestedObject, flattenedObject) {
  for (var prop in nestedObject) {
    if (hasOwnProperty(nestedObject, prop)) {
      var value = nestedObject[prop];
      if (typeof value === "object" && value !== null) {
        _deepFlatten(value, flattenedObject);
      } else {
        flattenedObject[prop] = value;
      }
    }
  }
}
function lazy(object, prop, valueResolver) {
  var _uninitialized = true;
  var _value;
  Object.defineProperty(object, prop, {
    get: function get3() {
      if (_uninitialized) {
        _value = valueResolver();
        _uninitialized = false;
      }
      return _value;
    },
    set: function set3(value) {
      _value = value;
      _uninitialized = false;
    },
    configurable: true,
    enumerable: true
  });
}
function hasOwnProperty(object, property) {
  return object && Object.hasOwnProperty.call(object, property);
}
function isLegacyFactory(object) {
  return object && typeof object.factory === "function";
}
function pickShallow(object, properties2) {
  var copy3 = {};
  for (var i = 0; i < properties2.length; i++) {
    var key = properties2[i];
    var value = object[key];
    if (value !== void 0) {
      copy3[key] = value;
    }
  }
  return copy3;
}
function values(object) {
  return Object.keys(object).map((key) => object[key]);
}

// node_modules/mathjs/lib/esm/core/function/config.js
var MATRIX_OPTIONS = ["Matrix", "Array"];
var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
function configFactory(config4, emit) {
  function _config(options) {
    if (options) {
      var prev = mapObject(config4, clone);
      validateOption(options, "matrix", MATRIX_OPTIONS);
      validateOption(options, "number", NUMBER_OPTIONS);
      deepExtend(config4, options);
      var curr = mapObject(config4, clone);
      var changes = mapObject(options, clone);
      emit("config", curr, prev, changes);
      return curr;
    } else {
      return mapObject(config4, clone);
    }
  }
  _config.MATRIX_OPTIONS = MATRIX_OPTIONS;
  _config.NUMBER_OPTIONS = NUMBER_OPTIONS;
  Object.keys(DEFAULT_CONFIG).forEach((key) => {
    Object.defineProperty(_config, key, {
      get: () => config4[key],
      enumerable: true,
      configurable: true
    });
  });
  return _config;
}
function contains(array2, item) {
  return array2.indexOf(item) !== -1;
}
function validateOption(options, name310, values2) {
  if (options[name310] !== void 0 && !contains(values2, options[name310])) {
    console.warn('Warning: Unknown value "' + options[name310] + '" for configuration option "' + name310 + '". Available options: ' + values2.map((value) => JSON.stringify(value)).join(", ") + ".");
  }
}

// node_modules/mathjs/lib/esm/entry/configReadonly.js
var config = function config2(options) {
  if (options) {
    throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
  }
  return Object.freeze(DEFAULT_CONFIG);
};
_extends(config, DEFAULT_CONFIG, {
  MATRIX_OPTIONS,
  NUMBER_OPTIONS
});

// node_modules/mathjs/lib/esm/factoriesAny.js
var factoriesAny_exports = {};
__export(factoriesAny_exports, {
  createAbs: () => createAbs,
  createAccessorNode: () => createAccessorNode,
  createAcos: () => createAcos,
  createAcosh: () => createAcosh,
  createAcot: () => createAcot,
  createAcoth: () => createAcoth,
  createAcsc: () => createAcsc,
  createAcsch: () => createAcsch,
  createAdd: () => createAdd,
  createAddScalar: () => createAddScalar,
  createAnd: () => createAnd,
  createApply: () => createApply,
  createApplyTransform: () => createApplyTransform,
  createArg: () => createArg,
  createArrayNode: () => createArrayNode,
  createAsec: () => createAsec,
  createAsech: () => createAsech,
  createAsin: () => createAsin,
  createAsinh: () => createAsinh,
  createAssignmentNode: () => createAssignmentNode,
  createAtan: () => createAtan,
  createAtan2: () => createAtan2,
  createAtanh: () => createAtanh,
  createAtomicMass: () => createAtomicMass,
  createAvogadro: () => createAvogadro,
  createBellNumbers: () => createBellNumbers,
  createBigNumberClass: () => createBigNumberClass,
  createBignumber: () => createBignumber,
  createBin: () => createBin,
  createBitAnd: () => createBitAnd,
  createBitNot: () => createBitNot,
  createBitOr: () => createBitOr,
  createBitXor: () => createBitXor,
  createBlockNode: () => createBlockNode,
  createBohrMagneton: () => createBohrMagneton,
  createBohrRadius: () => createBohrRadius,
  createBoltzmann: () => createBoltzmann,
  createBoolean: () => createBoolean,
  createCatalan: () => createCatalan,
  createCbrt: () => createCbrt,
  createCeil: () => createCeil,
  createChain: () => createChain,
  createChainClass: () => createChainClass,
  createClassicalElectronRadius: () => createClassicalElectronRadius,
  createClone: () => createClone,
  createColumn: () => createColumn,
  createColumnTransform: () => createColumnTransform,
  createCombinations: () => createCombinations,
  createCombinationsWithRep: () => createCombinationsWithRep,
  createCompare: () => createCompare,
  createCompareNatural: () => createCompareNatural,
  createCompareText: () => createCompareText,
  createCompile: () => createCompile,
  createComplex: () => createComplex,
  createComplexClass: () => createComplexClass,
  createComposition: () => createComposition,
  createConcat: () => createConcat,
  createConcatTransform: () => createConcatTransform,
  createConditionalNode: () => createConditionalNode,
  createConductanceQuantum: () => createConductanceQuantum,
  createConj: () => createConj,
  createConstantNode: () => createConstantNode,
  createCorr: () => createCorr,
  createCos: () => createCos,
  createCosh: () => createCosh,
  createCot: () => createCot,
  createCoth: () => createCoth,
  createCoulomb: () => createCoulomb,
  createCount: () => createCount,
  createCreateUnit: () => createCreateUnit,
  createCross: () => createCross,
  createCsc: () => createCsc,
  createCsch: () => createCsch,
  createCtranspose: () => createCtranspose,
  createCube: () => createCube,
  createCumSum: () => createCumSum,
  createCumSumTransform: () => createCumSumTransform,
  createDeepEqual: () => createDeepEqual,
  createDenseMatrixClass: () => createDenseMatrixClass,
  createDerivative: () => createDerivative,
  createDet: () => createDet,
  createDeuteronMass: () => createDeuteronMass,
  createDiag: () => createDiag,
  createDiff: () => createDiff,
  createDiffTransform: () => createDiffTransform,
  createDistance: () => createDistance,
  createDivide: () => createDivide,
  createDivideScalar: () => createDivideScalar,
  createDot: () => createDot,
  createDotDivide: () => createDotDivide,
  createDotMultiply: () => createDotMultiply,
  createDotPow: () => createDotPow,
  createE: () => createE,
  createEfimovFactor: () => createEfimovFactor,
  createEigs: () => createEigs,
  createElectricConstant: () => createElectricConstant,
  createElectronMass: () => createElectronMass,
  createElementaryCharge: () => createElementaryCharge,
  createEqual: () => createEqual,
  createEqualScalar: () => createEqualScalar,
  createEqualText: () => createEqualText,
  createErf: () => createErf,
  createEvaluate: () => createEvaluate,
  createExp: () => createExp,
  createExpm: () => createExpm,
  createExpm1: () => createExpm1,
  createFactorial: () => createFactorial,
  createFalse: () => createFalse,
  createFaraday: () => createFaraday,
  createFermiCoupling: () => createFermiCoupling,
  createFft: () => createFft,
  createFibonacciHeapClass: () => createFibonacciHeapClass,
  createFilter: () => createFilter,
  createFilterTransform: () => createFilterTransform,
  createFineStructure: () => createFineStructure,
  createFirstRadiation: () => createFirstRadiation,
  createFix: () => createFix,
  createFlatten: () => createFlatten,
  createFloor: () => createFloor,
  createForEach: () => createForEach,
  createForEachTransform: () => createForEachTransform,
  createFormat: () => createFormat,
  createFraction: () => createFraction,
  createFractionClass: () => createFractionClass,
  createFreqz: () => createFreqz,
  createFunctionAssignmentNode: () => createFunctionAssignmentNode,
  createFunctionNode: () => createFunctionNode,
  createGamma: () => createGamma,
  createGasConstant: () => createGasConstant,
  createGcd: () => createGcd,
  createGetMatrixDataType: () => createGetMatrixDataType,
  createGravitationConstant: () => createGravitationConstant,
  createGravity: () => createGravity,
  createHartreeEnergy: () => createHartreeEnergy,
  createHasNumericValue: () => createHasNumericValue,
  createHelp: () => createHelp,
  createHelpClass: () => createHelpClass,
  createHex: () => createHex,
  createHypot: () => createHypot,
  createI: () => createI,
  createIdentity: () => createIdentity,
  createIfft: () => createIfft,
  createIm: () => createIm,
  createImmutableDenseMatrixClass: () => createImmutableDenseMatrixClass,
  createIndex: () => createIndex,
  createIndexClass: () => createIndexClass,
  createIndexNode: () => createIndexNode,
  createIndexTransform: () => createIndexTransform,
  createInfinity: () => createInfinity,
  createIntersect: () => createIntersect,
  createInv: () => createInv,
  createInverseConductanceQuantum: () => createInverseConductanceQuantum,
  createInvmod: () => createInvmod,
  createIsInteger: () => createIsInteger,
  createIsNaN: () => createIsNaN,
  createIsNegative: () => createIsNegative,
  createIsNumeric: () => createIsNumeric,
  createIsPositive: () => createIsPositive,
  createIsPrime: () => createIsPrime,
  createIsZero: () => createIsZero,
  createKldivergence: () => createKldivergence,
  createKlitzing: () => createKlitzing,
  createKron: () => createKron,
  createLN10: () => createLN10,
  createLN2: () => createLN2,
  createLOG10E: () => createLOG10E,
  createLOG2E: () => createLOG2E,
  createLarger: () => createLarger,
  createLargerEq: () => createLargerEq,
  createLcm: () => createLcm,
  createLeafCount: () => createLeafCount,
  createLeftShift: () => createLeftShift,
  createLgamma: () => createLgamma,
  createLog: () => createLog,
  createLog10: () => createLog10,
  createLog1p: () => createLog1p,
  createLog2: () => createLog2,
  createLoschmidt: () => createLoschmidt,
  createLsolve: () => createLsolve,
  createLsolveAll: () => createLsolveAll,
  createLup: () => createLup,
  createLusolve: () => createLusolve,
  createLyap: () => createLyap,
  createMad: () => createMad,
  createMagneticConstant: () => createMagneticConstant,
  createMagneticFluxQuantum: () => createMagneticFluxQuantum,
  createMap: () => createMap2,
  createMapTransform: () => createMapTransform,
  createMatrix: () => createMatrix,
  createMatrixClass: () => createMatrixClass,
  createMatrixFromColumns: () => createMatrixFromColumns,
  createMatrixFromFunction: () => createMatrixFromFunction,
  createMatrixFromRows: () => createMatrixFromRows,
  createMax: () => createMax,
  createMaxTransform: () => createMaxTransform,
  createMean: () => createMean,
  createMeanTransform: () => createMeanTransform,
  createMedian: () => createMedian,
  createMin: () => createMin,
  createMinTransform: () => createMinTransform,
  createMod: () => createMod,
  createMode: () => createMode,
  createMolarMass: () => createMolarMass,
  createMolarMassC12: () => createMolarMassC12,
  createMolarPlanckConstant: () => createMolarPlanckConstant,
  createMolarVolume: () => createMolarVolume,
  createMultinomial: () => createMultinomial,
  createMultiply: () => createMultiply,
  createMultiplyScalar: () => createMultiplyScalar,
  createNaN: () => createNaN,
  createNeutronMass: () => createNeutronMass,
  createNode: () => createNode,
  createNorm: () => createNorm,
  createNot: () => createNot,
  createNthRoot: () => createNthRoot,
  createNthRoots: () => createNthRoots,
  createNuclearMagneton: () => createNuclearMagneton,
  createNull: () => createNull,
  createNumber: () => createNumber,
  createNumeric: () => createNumeric,
  createObjectNode: () => createObjectNode,
  createOct: () => createOct,
  createOnes: () => createOnes,
  createOperatorNode: () => createOperatorNode,
  createOr: () => createOr,
  createParenthesisNode: () => createParenthesisNode,
  createParse: () => createParse,
  createParser: () => createParser,
  createParserClass: () => createParserClass,
  createPartitionSelect: () => createPartitionSelect,
  createPermutations: () => createPermutations,
  createPhi: () => createPhi,
  createPi: () => createPi,
  createPickRandom: () => createPickRandom,
  createPinv: () => createPinv,
  createPlanckCharge: () => createPlanckCharge,
  createPlanckConstant: () => createPlanckConstant,
  createPlanckLength: () => createPlanckLength,
  createPlanckMass: () => createPlanckMass,
  createPlanckTemperature: () => createPlanckTemperature,
  createPlanckTime: () => createPlanckTime,
  createPolynomialRoot: () => createPolynomialRoot,
  createPow: () => createPow,
  createPrint: () => createPrint,
  createPrintTransform: () => createPrintTransform,
  createProd: () => createProd,
  createProtonMass: () => createProtonMass,
  createQr: () => createQr,
  createQuantileSeq: () => createQuantileSeq,
  createQuantileSeqTransform: () => createQuantileSeqTransform,
  createQuantumOfCirculation: () => createQuantumOfCirculation,
  createRandom: () => createRandom,
  createRandomInt: () => createRandomInt,
  createRange: () => createRange,
  createRangeClass: () => createRangeClass,
  createRangeNode: () => createRangeNode,
  createRangeTransform: () => createRangeTransform,
  createRationalize: () => createRationalize,
  createRe: () => createRe,
  createReducedPlanckConstant: () => createReducedPlanckConstant,
  createRelationalNode: () => createRelationalNode,
  createReplacer: () => createReplacer,
  createReshape: () => createReshape,
  createResize: () => createResize,
  createResolve: () => createResolve,
  createResultSet: () => createResultSet,
  createReviver: () => createReviver,
  createRightArithShift: () => createRightArithShift,
  createRightLogShift: () => createRightLogShift,
  createRotate: () => createRotate,
  createRotationMatrix: () => createRotationMatrix,
  createRound: () => createRound,
  createRow: () => createRow,
  createRowTransform: () => createRowTransform,
  createRydberg: () => createRydberg,
  createSQRT1_2: () => createSQRT1_2,
  createSQRT2: () => createSQRT2,
  createSackurTetrode: () => createSackurTetrode,
  createSchur: () => createSchur,
  createSec: () => createSec,
  createSech: () => createSech,
  createSecondRadiation: () => createSecondRadiation,
  createSetCartesian: () => createSetCartesian,
  createSetDifference: () => createSetDifference,
  createSetDistinct: () => createSetDistinct,
  createSetIntersect: () => createSetIntersect,
  createSetIsSubset: () => createSetIsSubset,
  createSetMultiplicity: () => createSetMultiplicity,
  createSetPowerset: () => createSetPowerset,
  createSetSize: () => createSetSize,
  createSetSymDifference: () => createSetSymDifference,
  createSetUnion: () => createSetUnion,
  createSign: () => createSign,
  createSimplify: () => createSimplify,
  createSimplifyConstant: () => createSimplifyConstant,
  createSimplifyCore: () => createSimplifyCore,
  createSin: () => createSin,
  createSinh: () => createSinh,
  createSize: () => createSize,
  createSlu: () => createSlu,
  createSmaller: () => createSmaller,
  createSmallerEq: () => createSmallerEq,
  createSolveODE: () => createSolveODE,
  createSort: () => createSort,
  createSpaClass: () => createSpaClass,
  createSparse: () => createSparse,
  createSparseMatrixClass: () => createSparseMatrixClass,
  createSpeedOfLight: () => createSpeedOfLight,
  createSplitUnit: () => createSplitUnit,
  createSqrt: () => createSqrt,
  createSqrtm: () => createSqrtm,
  createSquare: () => createSquare,
  createSqueeze: () => createSqueeze,
  createStd: () => createStd,
  createStdTransform: () => createStdTransform,
  createStefanBoltzmann: () => createStefanBoltzmann,
  createStirlingS2: () => createStirlingS2,
  createString: () => createString,
  createSubset: () => createSubset,
  createSubsetTransform: () => createSubsetTransform,
  createSubtract: () => createSubtract,
  createSubtractScalar: () => createSubtractScalar,
  createSum: () => createSum,
  createSumTransform: () => createSumTransform,
  createSylvester: () => createSylvester,
  createSymbolNode: () => createSymbolNode,
  createSymbolicEqual: () => createSymbolicEqual,
  createTan: () => createTan,
  createTanh: () => createTanh,
  createTau: () => createTau,
  createThomsonCrossSection: () => createThomsonCrossSection,
  createTo: () => createTo,
  createTrace: () => createTrace,
  createTranspose: () => createTranspose,
  createTrue: () => createTrue,
  createTypeOf: () => createTypeOf,
  createTyped: () => createTyped,
  createUnaryMinus: () => createUnaryMinus,
  createUnaryPlus: () => createUnaryPlus,
  createUnequal: () => createUnequal,
  createUnitClass: () => createUnitClass,
  createUnitFunction: () => createUnitFunction,
  createUppercaseE: () => createUppercaseE,
  createUppercasePi: () => createUppercasePi,
  createUsolve: () => createUsolve,
  createUsolveAll: () => createUsolveAll,
  createVacuumImpedance: () => createVacuumImpedance,
  createVariance: () => createVariance,
  createVarianceTransform: () => createVarianceTransform,
  createVersion: () => createVersion,
  createWeakMixingAngle: () => createWeakMixingAngle,
  createWienDisplacement: () => createWienDisplacement,
  createXgcd: () => createXgcd,
  createXor: () => createXor,
  createZeros: () => createZeros,
  createZeta: () => createZeta,
  createZpk2tf: () => createZpk2tf
});

// node_modules/mathjs/lib/esm/core/function/typed.js
var import_typed_function = __toESM(require_typed_function(), 1);

// node_modules/mathjs/lib/esm/utils/number.js
function isInteger(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
var sign = Math.sign || function(x2) {
  if (x2 > 0) {
    return 1;
  } else if (x2 < 0) {
    return -1;
  } else {
    return 0;
  }
};
var log2 = Math.log2 || function log22(x2) {
  return Math.log(x2) / Math.LN2;
};
var log10 = Math.log10 || function log102(x2) {
  return Math.log(x2) / Math.LN10;
};
var log1p = Math.log1p || function(x2) {
  return Math.log(x2 + 1);
};
var cbrt = Math.cbrt || function cbrt2(x2) {
  if (x2 === 0) {
    return x2;
  }
  var negate = x2 < 0;
  var result;
  if (negate) {
    x2 = -x2;
  }
  if (isFinite(x2)) {
    result = Math.exp(Math.log(x2) / 3);
    result = (x2 / (result * result) + 2 * result) / 3;
  } else {
    result = x2;
  }
  return negate ? -result : result;
};
var expm1 = Math.expm1 || function expm12(x2) {
  return x2 >= 2e-4 || x2 <= -2e-4 ? Math.exp(x2) - 1 : x2 + x2 * x2 / 2 + x2 * x2 * x2 / 6;
};
function formatNumberToBase(n, base, size) {
  var prefixes2 = {
    2: "0b",
    8: "0o",
    16: "0x"
  };
  var prefix = prefixes2[base];
  var suffix = "";
  if (size) {
    if (size < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
      throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
    }
    if (!isInteger(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size;
    }
    suffix = "i".concat(size);
  }
  var sign4 = "";
  if (n < 0) {
    n = -n;
    sign4 = "-";
  }
  return "".concat(sign4).concat(prefix).concat(n.toString(base)).concat(suffix);
}
function format(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options) {
    if (options.notation) {
      notation = options.notation;
    }
    if (isNumber(options)) {
      precision = options;
    } else if (isNumber(options.precision)) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e3 = arguments[4];
        return digits2 !== "." ? digits2 + e3 : e3;
      });
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function splitNumber(value) {
  var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  var sign4 = match[1];
  var digits2 = match[2];
  var exponent = parseFloat(match[4] || "0");
  var dot = digits2.indexOf(".");
  exponent += dot !== -1 ? dot - 1 : digits2.length - 1;
  var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros2) {
    exponent -= zeros2.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent++;
  }
  return {
    sign: sign4,
    coefficients,
    exponent
  };
}
function toEngineering(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = roundDigits(split, precision);
  var e3 = rounded.exponent;
  var c2 = rounded.coefficients;
  var newExp = e3 % 3 === 0 ? e3 : e3 < 0 ? e3 - 3 - e3 % 3 : e3 - e3 % 3;
  if (isNumber(precision)) {
    while (precision > c2.length || e3 - newExp + 1 > c2.length) {
      c2.push(0);
    }
  } else {
    var missingZeros = Math.abs(e3 - newExp) - (c2.length - 1);
    for (var i = 0; i < missingZeros; i++) {
      c2.push(0);
    }
  }
  var expDiff = Math.abs(e3 - newExp);
  var decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  var decimals = c2.slice(decimalIdx).join("");
  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  var str = c2.slice(0, decimalIdx).join("") + decimalVal + "e" + (e3 >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var splitValue = splitNumber(value);
  var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  var c2 = rounded.coefficients;
  var p = rounded.exponent + 1;
  var pp = p + (precision || 0);
  if (c2.length < pp) {
    c2 = c2.concat(zeros(pp - c2.length));
  }
  if (p < 0) {
    c2 = zeros(-p + 1).concat(c2);
    p = 1;
  }
  if (p < c2.length) {
    c2.splice(p, 0, p === 0 ? "0." : ".");
  }
  return rounded.sign + c2.join("");
}
function toExponential(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  var c2 = rounded.coefficients;
  var e3 = rounded.exponent;
  if (c2.length < precision) {
    c2 = c2.concat(zeros(precision - c2.length));
  }
  var first = c2.shift();
  return rounded.sign + first + (c2.length > 0 ? "." + c2.join("") : "") + "e" + (e3 >= 0 ? "+" : "") + e3;
}
function toPrecision(value, precision, options) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
  var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential(value, precision);
  } else {
    var c2 = rounded.coefficients;
    var e3 = rounded.exponent;
    if (c2.length < precision) {
      c2 = c2.concat(zeros(precision - c2.length));
    }
    c2 = c2.concat(zeros(e3 - c2.length + 1 + (c2.length < precision ? precision - c2.length : 0)));
    c2 = zeros(-e3).concat(c2);
    var dot = e3 > 0 ? e3 : 0;
    if (dot < c2.length - 1) {
      c2.splice(dot + 1, 0, ".");
    }
    return rounded.sign + c2.join("");
  }
}
function roundDigits(split, precision) {
  var rounded = {
    sign: split.sign,
    coefficients: split.coefficients,
    exponent: split.exponent
  };
  var c2 = rounded.coefficients;
  while (precision <= 0) {
    c2.unshift(0);
    rounded.exponent++;
    precision++;
  }
  if (c2.length > precision) {
    var removed = c2.splice(precision, c2.length - precision);
    if (removed[0] >= 5) {
      var i = precision - 1;
      c2[i]++;
      while (c2[i] === 10) {
        c2.pop();
        if (i === 0) {
          c2.unshift(0);
          rounded.exponent++;
          i++;
        }
        i--;
        c2[i]++;
      }
    }
  }
  return rounded;
}
function zeros(length) {
  var arr = [];
  for (var i = 0; i < length; i++) {
    arr.push(0);
  }
  return arr;
}
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
function nearlyEqual(x2, y2, epsilon4) {
  if (epsilon4 === null || epsilon4 === void 0) {
    return x2 === y2;
  }
  if (x2 === y2) {
    return true;
  }
  if (isNaN(x2) || isNaN(y2)) {
    return false;
  }
  if (isFinite(x2) && isFinite(y2)) {
    var diff = Math.abs(x2 - y2);
    if (diff < DBL_EPSILON) {
      return true;
    } else {
      return diff <= Math.max(Math.abs(x2), Math.abs(y2)) * epsilon4;
    }
  }
  return false;
}
var acosh = Math.acosh || function(x2) {
  return Math.log(Math.sqrt(x2 * x2 - 1) + x2);
};
var asinh = Math.asinh || function(x2) {
  return Math.log(Math.sqrt(x2 * x2 + 1) + x2);
};
var atanh = Math.atanh || function(x2) {
  return Math.log((1 + x2) / (1 - x2)) / 2;
};
var cosh = Math.cosh || function(x2) {
  return (Math.exp(x2) + Math.exp(-x2)) / 2;
};
var sinh = Math.sinh || function(x2) {
  return (Math.exp(x2) - Math.exp(-x2)) / 2;
};
var tanh = Math.tanh || function(x2) {
  var e3 = Math.exp(2 * x2);
  return (e3 - 1) / (e3 + 1);
};
function copysign(x2, y2) {
  var signx = x2 > 0 ? true : x2 < 0 ? false : 1 / x2 === Infinity;
  var signy = y2 > 0 ? true : y2 < 0 ? false : 1 / y2 === Infinity;
  return signx ^ signy ? -x2 : x2;
}

// node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
function formatBigNumberToBase(n, base, size) {
  var BigNumberCtor = n.constructor;
  var big2 = new BigNumberCtor(2);
  var suffix = "";
  if (size) {
    if (size < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
      throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size));
    }
    suffix = "i".concat(size);
  }
  switch (base) {
    case 2:
      return "".concat(n.toBinary()).concat(suffix);
    case 8:
      return "".concat(n.toOctal()).concat(suffix);
    case 16:
      return "".concat(n.toHexadecimal()).concat(suffix);
    default:
      throw new Error("Base ".concat(base, " not supported "));
  }
}
function format2(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options !== void 0) {
    if (options.notation) {
      notation = options.notation;
    }
    if (typeof options === "number") {
      precision = options;
    } else if (options.precision !== void 0) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed2(value, precision);
    case "exponential":
      return toExponential2(value, precision);
    case "engineering":
      return toEngineering2(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
      var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
      if (value.isZero())
        return "0";
      var str;
      var rounded = value.toSignificantDigits(precision);
      var exp2 = rounded.e;
      if (exp2 >= lowerExp && exp2 < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential2(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e3 = arguments[4];
        return digits2 !== "." ? digits2 + e3 : e3;
      });
    }
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering2(value, precision) {
  var e3 = value.e;
  var newExp = e3 % 3 === 0 ? e3 : e3 < 0 ? e3 - 3 - e3 % 3 : e3 - e3 % 3;
  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
  var valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.indexOf("e") !== -1) {
    var BigNumber2 = value.constructor;
    valueStr = new BigNumber2(valueStr).toFixed();
  }
  return valueStr + "e" + (e3 >= 0 ? "+" : "") + newExp.toString();
}
function toExponential2(value, precision) {
  if (precision !== void 0) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed2(value, precision) {
  return value.toFixed(precision);
}

// node_modules/mathjs/lib/esm/utils/string.js
function endsWith(text, search) {
  var start2 = text.length - search.length;
  var end = text.length;
  return text.substring(start2, end) === search;
}
function format3(value, options) {
  var result = _format(value, options);
  if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
    return result.substring(0, options.truncate - 3) + "...";
  }
  return result;
}
function _format(value, options) {
  if (typeof value === "number") {
    return format(value, options);
  }
  if (isBigNumber(value)) {
    return format2(value, options);
  }
  if (looksLikeFraction(value)) {
    if (!options || options.fraction !== "decimal") {
      return value.s * value.n + "/" + value.d;
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options);
  }
  if (isString(value)) {
    return stringify(value);
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options);
    } else if (value && value.toString(options) !== {}.toString()) {
      return value.toString(options);
    } else {
      var entries = Object.keys(value).map((key) => {
        return stringify(key) + ": " + format3(value[key], options);
      });
      return "{" + entries.join(", ") + "}";
    }
  }
  return String(value);
}
function stringify(value) {
  var text = String(value);
  var escaped = "";
  var i = 0;
  while (i < text.length) {
    var c2 = text.charAt(i);
    escaped += c2 in controlCharacters ? controlCharacters[c2] : c2;
    i++;
  }
  return '"' + escaped + '"';
}
var controlCharacters = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
function escape(value) {
  var text = String(value);
  text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return text;
}
function formatArray(array2, options) {
  if (Array.isArray(array2)) {
    var str = "[";
    var len = array2.length;
    for (var i = 0; i < len; i++) {
      if (i !== 0) {
        str += ", ";
      }
      str += formatArray(array2[i], options);
    }
    str += "]";
    return str;
  } else {
    return format3(array2, options);
  }
}
function looksLikeFraction(value) {
  return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
}
function compareText(x2, y2) {
  if (!isString(x2)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(x2) + ", index: 0)");
  }
  if (!isString(y2)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(y2) + ", index: 1)");
  }
  return x2 === y2 ? 0 : x2 > y2 ? 1 : -1;
}

// node_modules/mathjs/lib/esm/error/DimensionError.js
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.actual = actual;
  this.expected = expected;
  this.relation = relation;
  this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
  this.stack = new Error().stack;
}
DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = true;

// node_modules/mathjs/lib/esm/error/IndexError.js
function IndexError(index, min4, max4) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.index = index;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min4;
  } else {
    this.min = min4;
    this.max = max4;
  }
  if (this.min !== void 0 && this.index < this.min) {
    this.message = "Index out of range (" + this.index + " < " + this.min + ")";
  } else if (this.max !== void 0 && this.index >= this.max) {
    this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
  } else {
    this.message = "Index out of range (" + this.index + ")";
  }
  this.stack = new Error().stack;
}
IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = true;

// node_modules/mathjs/lib/esm/utils/array.js
function arraySize(x2) {
  var s2 = [];
  while (Array.isArray(x2)) {
    s2.push(x2.length);
    x2 = x2[0];
  }
  return s2;
}
function _validate(array2, size, dim) {
  var i;
  var len = array2.length;
  if (len !== size[dim]) {
    throw new DimensionError(len, size[dim]);
  }
  if (dim < size.length - 1) {
    var dimNext = dim + 1;
    for (i = 0; i < len; i++) {
      var child = array2[i];
      if (!Array.isArray(child)) {
        throw new DimensionError(size.length - 1, size.length, "<");
      }
      _validate(array2[i], size, dimNext);
    }
  } else {
    for (i = 0; i < len; i++) {
      if (Array.isArray(array2[i])) {
        throw new DimensionError(size.length + 1, size.length, ">");
      }
    }
  }
}
function validate(array2, size) {
  var isScalar = size.length === 0;
  if (isScalar) {
    if (Array.isArray(array2)) {
      throw new DimensionError(array2.length, 0);
    }
  } else {
    _validate(array2, size, 0);
  }
}
function validateIndexSourceSize(value, index) {
  var valueSize = value.isMatrix ? value._size : arraySize(value);
  var sourceSize = index._sourceSize;
  sourceSize.forEach((sourceDim, i) => {
    if (sourceDim !== null && sourceDim !== valueSize[i]) {
      throw new DimensionError(sourceDim, valueSize[i]);
    }
  });
}
function validateIndex(index, length) {
  if (index !== void 0) {
    if (!isNumber(index) || !isInteger(index)) {
      throw new TypeError("Index must be an integer (value: " + index + ")");
    }
    if (index < 0 || typeof length === "number" && index >= length) {
      throw new IndexError(index, length);
    }
  }
}
function isEmptyIndex(index) {
  for (var i = 0; i < index._dimensions.length; ++i) {
    var dimension = index._dimensions[i];
    if (dimension._data && isArray(dimension._data)) {
      if (dimension._size[0] === 0) {
        return true;
      }
    } else if (dimension.isRange) {
      if (dimension.start === dimension.end) {
        return true;
      }
    } else if (isString(dimension)) {
      if (dimension.length === 0) {
        return true;
      }
    }
  }
  return false;
}
function resize(array2, size, defaultValue) {
  if (!Array.isArray(size)) {
    throw new TypeError("Array expected");
  }
  if (size.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size.forEach(function(value) {
    if (!isNumber(value) || !isInteger(value) || value < 0) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size) + ")");
    }
  });
  if (isNumber(array2) || isBigNumber(array2)) {
    array2 = [array2];
  }
  var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
  _resize(array2, size, 0, _defaultValue);
  return array2;
}
function _resize(array2, size, dim, defaultValue) {
  var i;
  var elem;
  var oldLen = array2.length;
  var newLen = size[dim];
  var minLen = Math.min(oldLen, newLen);
  array2.length = newLen;
  if (dim < size.length - 1) {
    var dimNext = dim + 1;
    for (i = 0; i < minLen; i++) {
      elem = array2[i];
      if (!Array.isArray(elem)) {
        elem = [elem];
        array2[i] = elem;
      }
      _resize(elem, size, dimNext, defaultValue);
    }
    for (i = minLen; i < newLen; i++) {
      elem = [];
      array2[i] = elem;
      _resize(elem, size, dimNext, defaultValue);
    }
  } else {
    for (i = 0; i < minLen; i++) {
      while (Array.isArray(array2[i])) {
        array2[i] = array2[i][0];
      }
    }
    for (i = minLen; i < newLen; i++) {
      array2[i] = defaultValue;
    }
  }
}
function reshape(array2, sizes) {
  var flatArray = flatten(array2);
  var currentLength = flatArray.length;
  if (!Array.isArray(array2) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  sizes = processSizesWildcard(sizes, currentLength);
  var newLength = product(sizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, sizes);
  } catch (e3) {
    if (e3 instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e3;
  }
}
function processSizesWildcard(sizes, currentLength) {
  var newLength = product(sizes);
  var processedSizes = sizes.slice();
  var WILDCARD = -1;
  var wildCardIndex = sizes.indexOf(WILDCARD);
  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  var hasWildcard = wildCardIndex >= 0;
  var canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
    }
  }
  return processedSizes;
}
function product(array2) {
  return array2.reduce((prev, curr) => prev * curr, 1);
}
function _reshape(array2, sizes) {
  var tmpArray = array2;
  var tmpArray2;
  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
    var size = sizes[sizeIndex];
    tmpArray2 = [];
    var length = tmpArray.length / size;
    for (var i = 0; i < length; i++) {
      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
}
function squeeze(array2, size) {
  var s2 = size || arraySize(array2);
  while (Array.isArray(array2) && array2.length === 1) {
    array2 = array2[0];
    s2.shift();
  }
  var dims = s2.length;
  while (s2[dims - 1] === 1) {
    dims--;
  }
  if (dims < s2.length) {
    array2 = _squeeze(array2, dims, 0);
    s2.length = dims;
  }
  return array2;
}
function _squeeze(array2, dims, dim) {
  var i, ii;
  if (dim < dims) {
    var next = dim + 1;
    for (i = 0, ii = array2.length; i < ii; i++) {
      array2[i] = _squeeze(array2[i], dims, next);
    }
  } else {
    while (Array.isArray(array2)) {
      array2 = array2[0];
    }
  }
  return array2;
}
function unsqueeze(array2, dims, outer, size) {
  var s2 = size || arraySize(array2);
  if (outer) {
    for (var i = 0; i < outer; i++) {
      array2 = [array2];
      s2.unshift(1);
    }
  }
  array2 = _unsqueeze(array2, dims, 0);
  while (s2.length < dims) {
    s2.push(1);
  }
  return array2;
}
function _unsqueeze(array2, dims, dim) {
  var i, ii;
  if (Array.isArray(array2)) {
    var next = dim + 1;
    for (i = 0, ii = array2.length; i < ii; i++) {
      array2[i] = _unsqueeze(array2[i], dims, next);
    }
  } else {
    for (var d = dim; d < dims; d++) {
      array2 = [array2];
    }
  }
  return array2;
}
function flatten(array2) {
  if (!Array.isArray(array2)) {
    return array2;
  }
  var flat = [];
  array2.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);
    } else {
      flat.push(value);
    }
  });
  return flat;
}
function map(array2, callback) {
  return Array.prototype.map.call(array2, callback);
}
function forEach(array2, callback) {
  Array.prototype.forEach.call(array2, callback);
}
function filter(array2, callback) {
  if (arraySize(array2).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array2, callback);
}
function filterRegExp(array2, regexp) {
  if (arraySize(array2).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array2, (entry) => regexp.test(entry));
}
function join(array2, separator) {
  return Array.prototype.join.call(array2, separator);
}
function identify(a2) {
  if (!Array.isArray(a2)) {
    throw new TypeError("Array input expected");
  }
  if (a2.length === 0) {
    return a2;
  }
  var b = [];
  var count = 0;
  b[0] = {
    value: a2[0],
    identifier: 0
  };
  for (var i = 1; i < a2.length; i++) {
    if (a2[i] === a2[i - 1]) {
      count++;
    } else {
      count = 0;
    }
    b.push({
      value: a2[i],
      identifier: count
    });
  }
  return b;
}
function generalize(a2) {
  if (!Array.isArray(a2)) {
    throw new TypeError("Array input expected");
  }
  if (a2.length === 0) {
    return a2;
  }
  var b = [];
  for (var i = 0; i < a2.length; i++) {
    b.push(a2[i].value);
  }
  return b;
}
function getArrayDataType(array2, typeOf2) {
  var type;
  var length = 0;
  for (var i = 0; i < array2.length; i++) {
    var item = array2[i];
    var _isArray = Array.isArray(item);
    if (i === 0 && _isArray) {
      length = item.length;
    }
    if (_isArray && item.length !== length) {
      return void 0;
    }
    var itemType = _isArray ? getArrayDataType(item, typeOf2) : typeOf2(item);
    if (type === void 0) {
      type = itemType;
    } else if (type !== itemType) {
      return "mixed";
    } else {
    }
  }
  return type;
}
function contains2(array2, item) {
  return array2.indexOf(item) !== -1;
}
function concatRecursive(a2, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a2.length !== b.length) {
      throw new DimensionError(a2.length, b.length);
    }
    var c2 = [];
    for (var i = 0; i < a2.length; i++) {
      c2[i] = concatRecursive(a2[i], b[i], concatDim, dim + 1);
    }
    return c2;
  } else {
    return a2.concat(b);
  }
}
function concat() {
  var arrays = Array.prototype.slice.call(arguments, 0, -1);
  var concatDim = Array.prototype.slice.call(arguments, -1);
  if (arrays.length === 1) {
    return arrays[0];
  }
  if (arrays.length > 1) {
    return arrays.slice(1).reduce(function(A2, B2) {
      return concatRecursive(A2, B2, concatDim, 0);
    }, arrays[0]);
  } else {
    throw new Error("Wrong number of arguments in function concat");
  }
}
function broadcastSizes() {
  for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {
    sizes[_key] = arguments[_key];
  }
  var dimensions = sizes.map((s2) => s2.length);
  var N = Math.max(...dimensions);
  var sizeMax = new Array(N).fill(null);
  for (var i = 0; i < sizes.length; i++) {
    var size = sizes[i];
    var dim = dimensions[i];
    for (var j = 0; j < dim; j++) {
      var n = N - dim + j;
      if (size[j] > sizeMax[n]) {
        sizeMax[n] = size[j];
      }
    }
  }
  for (var _i = 0; _i < sizes.length; _i++) {
    checkBroadcastingRules(sizes[_i], sizeMax);
  }
  return sizeMax;
}
function checkBroadcastingRules(size, toSize) {
  var N = toSize.length;
  var dim = size.length;
  for (var j = 0; j < dim; j++) {
    var n = N - dim + j;
    if (size[j] < toSize[n] && size[j] > 1 || size[j] > toSize[n]) {
      throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size[j], " to size ").concat(toSize[n]));
    }
  }
}
function broadcastTo(array2, toSize) {
  var Asize = arraySize(array2);
  if (deepStrictEqual(Asize, toSize)) {
    return array2;
  }
  checkBroadcastingRules(Asize, toSize);
  var broadcastedSize = broadcastSizes(Asize, toSize);
  var N = broadcastedSize.length;
  var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];
  var A2 = clone2(array2);
  if (Asize.length < N) {
    A2 = reshape(A2, paddedSize);
    Asize = arraySize(A2);
  }
  for (var dim = 0; dim < N; dim++) {
    if (Asize[dim] < broadcastedSize[dim]) {
      A2 = stretch(A2, broadcastedSize[dim], dim);
      Asize = arraySize(A2);
    }
  }
  return A2;
}
function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
  return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
}
function clone2(array2) {
  return _extends([], array2);
}

// node_modules/mathjs/lib/esm/utils/factory.js
function factory(name310, dependencies310, create3, meta) {
  function assertAndCreate(scope) {
    var deps = pickShallow(scope, dependencies310.map(stripOptionalNotation));
    assertDependencies(name310, dependencies310, scope);
    return create3(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name310;
  assertAndCreate.dependencies = dependencies310.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function isFactory(obj) {
  return typeof obj === "function" && typeof obj.fn === "string" && Array.isArray(obj.dependencies);
}
function assertDependencies(name310, dependencies310, scope) {
  var allDefined = dependencies310.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
  if (!allDefined) {
    var missingDependencies = dependencies310.filter((dependency) => scope[dependency] === void 0);
    throw new Error('Cannot create function "'.concat(name310, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}

// node_modules/mathjs/lib/esm/utils/customs.js
function getSafeProperty(object, prop) {
  if (isPlainObject(object) && isSafeProperty(object, prop)) {
    return object[prop];
  }
  if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
}
function setSafeProperty(object, prop, value) {
  if (isPlainObject(object) && isSafeProperty(object, prop)) {
    object[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
}
function hasSafeProperty(object, prop) {
  return prop in object;
}
function isSafeProperty(object, prop) {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (hasOwnProperty(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
}
function getSafeMethod(object, method) {
  if (!isSafeMethod(object, method)) {
    throw new Error('No access to method "' + method + '"');
  }
  return object[method];
}
function isSafeMethod(object, method) {
  if (object === null || object === void 0 || typeof object[method] !== "function") {
    return false;
  }
  if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
    return false;
  }
  if (hasOwnProperty(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
}
function isPlainObject(object) {
  return typeof object === "object" && object && object.constructor === Object;
}
var safeNativeProperties = {
  length: true,
  name: true
};
var safeNativeMethods = {
  toString: true,
  valueOf: true,
  toLocaleString: true
};

// node_modules/mathjs/lib/esm/utils/map.js
var ObjectWrappingMap = class {
  constructor(object) {
    this.wrappedObject = object;
  }
  keys() {
    return Object.keys(this.wrappedObject);
  }
  get(key) {
    return getSafeProperty(this.wrappedObject, key);
  }
  set(key, value) {
    setSafeProperty(this.wrappedObject, key, value);
    return this;
  }
  has(key) {
    return hasSafeProperty(this.wrappedObject, key);
  }
};
function createEmptyMap() {
  return /* @__PURE__ */ new Map();
}
function createMap(mapOrObject) {
  if (!mapOrObject) {
    return createEmptyMap();
  }
  if (isMap(mapOrObject)) {
    return mapOrObject;
  }
  if (isObject(mapOrObject)) {
    return new ObjectWrappingMap(mapOrObject);
  }
  throw new Error("createMap can create maps from objects or Maps");
}
function toObject(map3) {
  if (map3 instanceof ObjectWrappingMap) {
    return map3.wrappedObject;
  }
  var object = {};
  for (var key of map3.keys()) {
    var value = map3.get(key);
    setSafeProperty(object, key, value);
  }
  return object;
}
function isMap(object) {
  if (!object) {
    return false;
  }
  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
}
function assign(map3) {
  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    objects[_key - 1] = arguments[_key];
  }
  for (var args of objects) {
    if (!args) {
      continue;
    }
    if (isMap(args)) {
      for (var key of args.keys()) {
        map3.set(key, args.get(key));
      }
    } else if (isObject(args)) {
      for (var _key2 of Object.keys(args)) {
        map3.set(_key2, args[_key2]);
      }
    }
  }
  return map3;
}

// node_modules/mathjs/lib/esm/core/function/typed.js
var _createTyped2 = function _createTyped() {
  _createTyped2 = import_typed_function.default.create;
  return import_typed_function.default;
};
var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
var createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
  var {
    BigNumber: BigNumber2,
    Complex: Complex3,
    DenseMatrix: DenseMatrix2,
    Fraction: Fraction3
  } = _ref;
  var typed3 = _createTyped2();
  typed3.clear();
  typed3.addTypes([
    {
      name: "number",
      test: isNumber
    },
    {
      name: "Complex",
      test: isComplex
    },
    {
      name: "BigNumber",
      test: isBigNumber
    },
    {
      name: "Fraction",
      test: isFraction
    },
    {
      name: "Unit",
      test: isUnit
    },
    // The following type matches a valid variable name, i.e., an alphanumeric
    // string starting with an alphabetic character. It is used (at least)
    // in the definition of the derivative() function, as the argument telling
    // what to differentiate over must (currently) be a variable.
    {
      name: "identifier",
      test: (s2) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s2)
    },
    {
      name: "string",
      test: isString
    },
    {
      name: "Chain",
      test: isChain
    },
    {
      name: "Array",
      test: isArray
    },
    {
      name: "Matrix",
      test: isMatrix
    },
    {
      name: "DenseMatrix",
      test: isDenseMatrix
    },
    {
      name: "SparseMatrix",
      test: isSparseMatrix
    },
    {
      name: "Range",
      test: isRange
    },
    {
      name: "Index",
      test: isIndex
    },
    {
      name: "boolean",
      test: isBoolean
    },
    {
      name: "ResultSet",
      test: isResultSet
    },
    {
      name: "Help",
      test: isHelp
    },
    {
      name: "function",
      test: isFunction
    },
    {
      name: "Date",
      test: isDate
    },
    {
      name: "RegExp",
      test: isRegExp
    },
    {
      name: "null",
      test: isNull
    },
    {
      name: "undefined",
      test: isUndefined
    },
    {
      name: "AccessorNode",
      test: isAccessorNode
    },
    {
      name: "ArrayNode",
      test: isArrayNode
    },
    {
      name: "AssignmentNode",
      test: isAssignmentNode
    },
    {
      name: "BlockNode",
      test: isBlockNode
    },
    {
      name: "ConditionalNode",
      test: isConditionalNode
    },
    {
      name: "ConstantNode",
      test: isConstantNode
    },
    {
      name: "FunctionNode",
      test: isFunctionNode
    },
    {
      name: "FunctionAssignmentNode",
      test: isFunctionAssignmentNode
    },
    {
      name: "IndexNode",
      test: isIndexNode
    },
    {
      name: "Node",
      test: isNode
    },
    {
      name: "ObjectNode",
      test: isObjectNode
    },
    {
      name: "OperatorNode",
      test: isOperatorNode
    },
    {
      name: "ParenthesisNode",
      test: isParenthesisNode
    },
    {
      name: "RangeNode",
      test: isRangeNode
    },
    {
      name: "RelationalNode",
      test: isRelationalNode
    },
    {
      name: "SymbolNode",
      test: isSymbolNode
    },
    {
      name: "Map",
      test: isMap
    },
    {
      name: "Object",
      test: isObject
    }
    // order 'Object' last, it matches on other classes too
  ]);
  typed3.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function convert(x2) {
      if (!BigNumber2) {
        throwNoBignumber(x2);
      }
      if (digits(x2) > 15) {
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x2 + "). Use function bignumber(x) to convert to BigNumber.");
      }
      return new BigNumber2(x2);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function convert(x2) {
      if (!Complex3) {
        throwNoComplex(x2);
      }
      return new Complex3(x2, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function convert(x2) {
      if (!Complex3) {
        throwNoComplex(x2);
      }
      return new Complex3(x2.toNumber(), 0);
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function convert(x2) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function convert(x2) {
      if (!Complex3) {
        throwNoComplex(x2);
      }
      return new Complex3(x2.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function convert(x2) {
      if (!Fraction3) {
        throwNoFraction(x2);
      }
      var f = new Fraction3(x2);
      if (f.valueOf() !== x2) {
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x2 + "). Use function fraction(x) to convert to Fraction.");
      }
      return f;
    }
  }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf()
    //  }
    // }, {
    from: "string",
    to: "number",
    convert: function convert(x2) {
      var n = Number(x2);
      if (isNaN(n)) {
        throw new Error('Cannot convert "' + x2 + '" to a number');
      }
      return n;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function convert(x2) {
      if (!BigNumber2) {
        throwNoBignumber(x2);
      }
      try {
        return new BigNumber2(x2);
      } catch (err) {
        throw new Error('Cannot convert "' + x2 + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function convert(x2) {
      if (!Fraction3) {
        throwNoFraction(x2);
      }
      try {
        return new Fraction3(x2);
      } catch (err) {
        throw new Error('Cannot convert "' + x2 + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function convert(x2) {
      if (!Complex3) {
        throwNoComplex(x2);
      }
      try {
        return new Complex3(x2);
      } catch (err) {
        throw new Error('Cannot convert "' + x2 + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function convert(x2) {
      return +x2;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function convert(x2) {
      if (!BigNumber2) {
        throwNoBignumber(x2);
      }
      return new BigNumber2(+x2);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function convert(x2) {
      if (!Fraction3) {
        throwNoFraction(x2);
      }
      return new Fraction3(+x2);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function convert(x2) {
      return String(x2);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function convert(array2) {
      if (!DenseMatrix2) {
        throwNoMatrix();
      }
      return new DenseMatrix2(array2);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function convert(matrix) {
      return matrix.valueOf();
    }
  }]);
  typed3.onMismatch = (name310, args, signatures) => {
    var usualError = typed3.createError(name310, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
    signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name310, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name310, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  typed3.onMismatch = (name310, args, signatures) => {
    var usualError = typed3.createError(name310, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
    signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name310, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name310, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  return typed3;
});
function throwNoBignumber(x2) {
  throw new Error("Cannot convert value ".concat(x2, " into a BigNumber: no class 'BigNumber' provided"));
}
function throwNoComplex(x2) {
  throw new Error("Cannot convert value ".concat(x2, " into a Complex number: no class 'Complex' provided"));
}
function throwNoMatrix() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function throwNoFraction(x2) {
  throw new Error("Cannot convert value ".concat(x2, " into a Fraction, no class 'Fraction' provided."));
}

// node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
var name = "ResultSet";
var dependencies2 = [];
var createResultSet = /* @__PURE__ */ factory(name, dependencies2, () => {
  function ResultSet(entries) {
    if (!(this instanceof ResultSet)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.entries = entries || [];
  }
  ResultSet.prototype.type = "ResultSet";
  ResultSet.prototype.isResultSet = true;
  ResultSet.prototype.valueOf = function() {
    return this.entries;
  };
  ResultSet.prototype.toString = function() {
    return "[" + this.entries.join(", ") + "]";
  };
  ResultSet.prototype.toJSON = function() {
    return {
      mathjs: "ResultSet",
      entries: this.entries
    };
  };
  ResultSet.fromJSON = function(json) {
    return new ResultSet(json.entries);
  };
  return ResultSet;
}, {
  isClass: true
});

// node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s < 0)
    x2.s = 1;
  return finalise(x2);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min4, max4) {
  var k2, x2 = this, Ctor = x2.constructor;
  min4 = new Ctor(min4);
  max4 = new Ctor(max4);
  if (!min4.s || !max4.s)
    return new Ctor(NaN);
  if (min4.gt(max4))
    throw Error(invalidArgument + max4);
  k2 = x2.cmp(min4);
  return k2 < 0 ? min4 : x2.cmp(max4) > 0 ? max4 : new Ctor(x2);
};
P.comparedTo = P.cmp = function(y2) {
  var i, j, xdL, ydL, x2 = this, xd = x2.d, yd = (y2 = new x2.constructor(y2)).d, xs = x2.s, ys = y2.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x2.e !== y2.e)
    return x2.e > y2.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.d)
    return new Ctor(NaN);
  if (!x2.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x2.e, x2.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x2 = cosine(Ctor, toLessThanHalfPi(Ctor, x2));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x2.neg() : x2, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e3, m, n, r, rep, s2, sd, t, t32, t3plusx, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero())
    return new Ctor(x2);
  external = false;
  s2 = x2.s * mathpow(x2.s * x2, 1 / 3);
  if (!s2 || Math.abs(s2) == 1 / 0) {
    n = digitsToString(x2.d);
    e3 = x2.e;
    if (s2 = (e3 - n.length + 1) % 3)
      n += s2 == 1 || s2 == -2 ? "0" : "00";
    s2 = mathpow(n, 1 / 3);
    e3 = mathfloor((e3 + 1) / 3) - (e3 % 3 == (e3 < 0 ? -1 : 2));
    if (s2 == 1 / 0) {
      n = "5e" + e3;
    } else {
      n = s2.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e3;
    }
    r = new Ctor(n);
    r.s = x2.s;
  } else {
    r = new Ctor(s2.toString());
  }
  sd = (e3 = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t32 = t.times(t).times(t);
    t3plusx = t32.plus(x2);
    r = divide(t3plusx.plus(x2).times(t), t3plusx.plus(t32), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e3 + 1, 0);
          if (t.times(t).times(t).eq(x2)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e3 + 1, 1);
          m = !r.times(r).times(r).eq(x2);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e3, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y2) {
  return divide(this, new this.constructor(y2));
};
P.dividedToIntegerBy = P.divToInt = function(y2) {
  var x2 = this, Ctor = x2.constructor;
  return finalise(divide(x2, new Ctor(y2), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y2) {
  return this.cmp(y2) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y2) {
  var k2 = this.cmp(y2);
  return k2 == 1 || k2 === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k2, n, pr, rm, len, x2 = this, Ctor = x2.constructor, one2 = new Ctor(1);
  if (!x2.isFinite())
    return new Ctor(x2.s ? 1 / 0 : NaN);
  if (x2.isZero())
    return one2;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x2.e, x2.sd()) + 4;
  Ctor.rounding = 1;
  len = x2.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k2)).toString();
  } else {
    k2 = 16;
    n = "2.3283064365386962890625e-10";
  }
  x2 = taylorSeries(Ctor, 1, x2.times(n), new Ctor(1), true);
  var cosh2_x, i = k2, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x2.times(x2);
    x2 = one2.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x2, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k2, pr, rm, len, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x2.e, x2.sd()) + 4;
  Ctor.rounding = 1;
  len = x2.d.length;
  if (len < 3) {
    x2 = taylorSeries(Ctor, 2, x2, x2, true);
  } else {
    k2 = 1.4 * Math.sqrt(len);
    k2 = k2 > 16 ? 16 : k2 | 0;
    x2 = x2.times(1 / tinyPow(5, k2));
    x2 = taylorSeries(Ctor, 2, x2, x2, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k2--; ) {
      sinh2_x = x2.times(x2);
      x2 = x2.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x2, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite())
    return new Ctor(x2.s);
  if (x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x2.sinh(), x2.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi2, x2 = this, Ctor = x2.constructor, k2 = x2.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k2 !== -1) {
    return k2 === 0 ? x2.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x2.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x2 = x2.asin();
  halfPi2 = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi2.minus(x2);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (x2.lte(1))
    return new Ctor(x2.eq(1) ? 0 : NaN);
  if (!x2.isFinite())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x2.e), x2.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x2 = x2.times(x2).minus(1).sqrt().plus(x2);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x2.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x2.e), x2.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x2 = x2.times(x2).plus(1).sqrt().plus(x2);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x2.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite())
    return new Ctor(NaN);
  if (x2.e >= 0)
    return new Ctor(x2.abs().eq(1) ? x2.s / 0 : x2.isZero() ? x2 : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x2.sd();
  if (Math.max(xsd, pr) < 2 * -x2.e - 1)
    return finalise(new Ctor(x2), pr, rm, true);
  Ctor.precision = wpr = xsd - x2.e;
  x2 = divide(x2.plus(1), new Ctor(1).minus(x2), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x2 = x2.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x2.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi2, k2, pr, rm, x2 = this, Ctor = x2.constructor;
  if (x2.isZero())
    return new Ctor(x2);
  k2 = x2.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k2 !== -1) {
    if (k2 === 0) {
      halfPi2 = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi2.s = x2.s;
      return halfPi2;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x2 = x2.div(new Ctor(1).minus(x2.times(x2)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x2.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k2, n, px, t, r, wpr, x2, x3 = this, Ctor = x3.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x3.isFinite()) {
    if (!x3.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x3.s;
      return r;
    }
  } else if (x3.isZero()) {
    return new Ctor(x3);
  } else if (x3.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x3.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k2 = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k2; i; --i)
    x3 = x3.div(x3.times(x3).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x3.times(x3);
  r = new Ctor(x3);
  px = x3;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i = j; r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k2)
    r = r.times(2 << k2 - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k2, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k2 = d[0]; k2 % 10 === 0; )
        k2 /= 10;
      inf = k2 !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k2 = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k2 + 1, k2 + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k2 += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y2) {
  var d, e3, i, j, k2, len, pr, rm, xd, xe, xLTy, yd, x2 = this, Ctor = x2.constructor;
  y2 = new Ctor(y2);
  if (!x2.d || !y2.d) {
    if (!x2.s || !y2.s)
      y2 = new Ctor(NaN);
    else if (x2.d)
      y2.s = -y2.s;
    else
      y2 = new Ctor(y2.d || x2.s !== y2.s ? x2 : NaN);
    return y2;
  }
  if (x2.s != y2.s) {
    y2.s = -y2.s;
    return x2.plus(y2);
  }
  xd = x2.d;
  yd = y2.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y2.s = -y2.s;
    else if (xd[0])
      y2 = new Ctor(x2);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y2, pr, rm) : y2;
  }
  e3 = mathfloor(y2.e / LOG_BASE);
  xe = mathfloor(x2.e / LOG_BASE);
  xd = xd.slice();
  k2 = xe - e3;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d = yd;
      e3 = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k2 > i) {
      k2 = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k2; i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y2.s = -y2.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k2; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e3;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y2.d = xd;
  y2.e = getBase10Exponent(xd, e3);
  return external ? finalise(y2, pr, rm) : y2;
};
P.modulo = P.mod = function(y2) {
  var q, x2 = this, Ctor = x2.constructor;
  y2 = new Ctor(y2);
  if (!x2.d || !y2.s || y2.d && !y2.d[0])
    return new Ctor(NaN);
  if (!y2.d || x2.d && !x2.d[0]) {
    return finalise(new Ctor(x2), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x2, y2.abs(), 0, 3, 1);
    q.s *= y2.s;
  } else {
    q = divide(x2, y2, 0, Ctor.modulo, 1);
  }
  q = q.times(y2);
  external = true;
  return x2.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s;
  return finalise(x2);
};
P.plus = P.add = function(y2) {
  var carry, d, e3, i, k2, len, pr, rm, xd, yd, x2 = this, Ctor = x2.constructor;
  y2 = new Ctor(y2);
  if (!x2.d || !y2.d) {
    if (!x2.s || !y2.s)
      y2 = new Ctor(NaN);
    else if (!x2.d)
      y2 = new Ctor(y2.d || x2.s === y2.s ? x2 : NaN);
    return y2;
  }
  if (x2.s != y2.s) {
    y2.s = -y2.s;
    return x2.minus(y2);
  }
  xd = x2.d;
  yd = y2.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y2 = new Ctor(x2);
    return external ? finalise(y2, pr, rm) : y2;
  }
  k2 = mathfloor(x2.e / LOG_BASE);
  e3 = mathfloor(y2.e / LOG_BASE);
  xd = xd.slice();
  i = k2 - e3;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e3 = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e3;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y2.d = xd;
  y2.e = getBase10Exponent(xd, e3);
  return external ? finalise(y2, pr, rm) : y2;
};
P.precision = P.sd = function(z) {
  var k2, x2 = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x2.d) {
    k2 = getPrecision(x2.d);
    if (z && x2.e + 1 > k2)
      k2 = x2.e + 1;
  } else {
    k2 = NaN;
  }
  return k2;
};
P.round = function() {
  var x2 = this, Ctor = x2.constructor;
  return finalise(new Ctor(x2), x2.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite())
    return new Ctor(NaN);
  if (x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x2.e, x2.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x2 = sine(Ctor, toLessThanHalfPi(Ctor, x2));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x2.neg() : x2, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x2 = this, d = x2.d, e3 = x2.e, s2 = x2.s, Ctor = x2.constructor;
  if (s2 !== 1 || !d || !d[0]) {
    return new Ctor(!s2 || s2 < 0 && (!d || d[0]) ? NaN : d ? x2 : 1 / 0);
  }
  external = false;
  s2 = Math.sqrt(+x2);
  if (s2 == 0 || s2 == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e3) % 2 == 0)
      n += "0";
    s2 = Math.sqrt(n);
    e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
    if (s2 == 1 / 0) {
      n = "5e" + e3;
    } else {
      n = s2.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e3;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s2.toString());
  }
  sd = (e3 = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x2, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e3 + 1, 0);
          if (t.times(t).eq(x2)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e3 + 1, 1);
          m = !r.times(r).eq(x2);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e3, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite())
    return new Ctor(NaN);
  if (x2.isZero())
    return new Ctor(x2);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x2 = x2.sin();
  x2.s = 1;
  x2 = divide(x2, new Ctor(1).minus(x2.times(x2)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x2.neg() : x2, pr, rm, true);
};
P.times = P.mul = function(y2) {
  var carry, e3, i, k2, r, rL, t, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y2 = new Ctor(y2)).d;
  y2.s *= x2.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y2.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y2.s / 0 : y2.s * 0);
  }
  e3 = mathfloor(x2.e / LOG_BASE) + mathfloor(y2.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k2 = xdL + i; k2 > i; ) {
      t = r[k2] + yd[i] * xd[k2 - i - 1] + carry;
      r[k2--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k2] = (r[k2] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e3;
  else
    r.shift();
  y2.d = r;
  y2.e = getBase10Exponent(r, e3);
  return external ? finalise(y2, Ctor.precision, Ctor.rounding) : y2;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0)
    return x2;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x2, dp + x2.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = finiteToString(x2, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = finalise(new Ctor(x2), dp + 1, rm);
    str = finiteToString(x2, true, dp + 1);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y2, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = finiteToString(x2);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y2 = finalise(new Ctor(x2), dp + x2.e + 1, rm);
    str = finiteToString(y2, false, dp + y2.e + 1);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e3, k2, n, n0, n16, pr, q, r, x2 = this, xd = x2.d, Ctor = x2.constructor;
  if (!xd)
    return new Ctor(x2);
  n16 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e3 = d.e = getPrecision(xd) - x2.e - 1;
  k2 = e3 % LOG_BASE;
  d.d[0] = mathpow(10, k2 < 0 ? LOG_BASE + k2 : k2);
  if (maxD == null) {
    maxD = e3 > 0 ? d : n16;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n16))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e3 > 0 ? d : n16 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e3 = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n16;
    n16 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n16));
  d0 = d0.plus(d2.times(d1));
  n0.s = n16.s = x2.s;
  r = divide(n16, d1, e3, 1).minus(x2).abs().cmp(divide(n0, d0, e3, 1).minus(x2).abs()) < 1 ? [n16, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y2, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (y2 == null) {
    if (!x2.d)
      return x2;
    y2 = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y2 = new Ctor(y2);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x2.d)
      return y2.s ? x2 : y2;
    if (!y2.d) {
      if (y2.s)
        y2.s = x2.s;
      return y2;
    }
  }
  if (y2.d[0]) {
    external = false;
    x2 = divide(x2, y2, 0, rm, 1).times(y2);
    external = true;
    finalise(x2);
  } else {
    y2.s = x2.s;
    x2 = y2;
  }
  return x2;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y2) {
  var e3, k2, pr, r, rm, s2, x2 = this, Ctor = x2.constructor, yn = +(y2 = new Ctor(y2));
  if (!x2.d || !y2.d || !x2.d[0] || !y2.d[0])
    return new Ctor(mathpow(+x2, yn));
  x2 = new Ctor(x2);
  if (x2.eq(1))
    return x2;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y2.eq(1))
    return finalise(x2, pr, rm);
  e3 = mathfloor(y2.e / LOG_BASE);
  if (e3 >= y2.d.length - 1 && (k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x2, k2, pr);
    return y2.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s2 = x2.s;
  if (s2 < 0) {
    if (e3 < y2.d.length - 1)
      return new Ctor(NaN);
    if ((y2.d[e3] & 1) == 0)
      s2 = 1;
    if (x2.e == 0 && x2.d[0] == 1 && x2.d.length == 1) {
      x2.s = s2;
      return x2;
    }
  }
  k2 = mathpow(+x2, yn);
  e3 = k2 == 0 || !isFinite(k2) ? mathfloor(yn * (Math.log("0." + digitsToString(x2.d)) / Math.LN10 + x2.e + 1)) : new Ctor(k2 + "").e;
  if (e3 > Ctor.maxE + 1 || e3 < Ctor.minE - 1)
    return new Ctor(e3 > 0 ? s2 / 0 : 0);
  external = false;
  Ctor.rounding = x2.s = 1;
  k2 = Math.min(12, (e3 + "").length);
  r = naturalExponential(y2.times(naturalLogarithm(x2, pr + k2)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e3 = pr + 10;
      r = finalise(naturalExponential(y2.times(naturalLogarithm(x2, e3 + k2)), e3), e3 + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s2;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    str = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = finalise(new Ctor(x2), sd, rm);
    str = finiteToString(x2, sd <= x2.e || x2.e <= Ctor.toExpNeg, sd);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x2), sd, rm);
};
P.toString = function() {
  var x2 = this, Ctor = x2.constructor, str = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x2 = this, Ctor = x2.constructor, str = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  return x2.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k2, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k2 = LOG_BASE - ws.length;
      if (k2)
        str += getZeroString(k2);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k2 = LOG_BASE - ws.length;
    if (k2)
      str += getZeroString(k2);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i, min4, max4) {
  if (i !== ~~i || i < min4 || i > max4) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k2, r, rd;
  for (k2 = d[0]; k2 >= 10; k2 /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k2 = mathpow(10, LOG_BASE - i);
  rd = d[di] % k2 | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k2 || rm > 3 && rd + 1 == k2 / 2) && (d[di + 1] / k2 / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k2 / 2 || rd == 0) && (d[di + 1] / k2 / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1e3 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k2 || !repeating && rm > 3 && rd + 1 == k2 / 2) && (d[di + 1] / k2 / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x2) {
  var k2, len, y2;
  if (x2.isZero())
    return x2;
  len = x2.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    y2 = (1 / tinyPow(4, k2)).toString();
  } else {
    k2 = 16;
    y2 = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k2;
  x2 = taylorSeries(Ctor, 1, x2.times(y2), new Ctor(1));
  for (var i = k2; i--; ) {
    var cos2x = x2.times(x2);
    x2 = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k2;
  return x2;
}
var divide = function() {
  function multiplyInteger(x2, k2, base) {
    var temp, carry = 0, i = x2.length;
    for (x2 = x2.slice(); i--; ) {
      temp = x2[i] * k2 + carry;
      x2[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x2.unshift(carry);
    return x2;
  }
  function compare(a2, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a2[i] != b[i]) {
          r = a2[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a2, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a2[aL] -= i;
      i = a2[aL] < b[aL] ? 1 : 0;
      a2[aL] = i * base + a2[aL] - b[aL];
    }
    for (; !a2[0] && a2.length > 1; )
      a2.shift();
  }
  return function(x2, y2, pr, rm, dp, base) {
    var cmp, e3, i, k2, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign4 = x2.s == y2.s ? 1 : -1, xd = x2.d, yd = y2.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x2.s || !y2.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign4 * 0 : sign4 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e3 = x2.e - y2.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e3 = mathfloor(x2.e / logBase) - mathfloor(y2.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign4);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e3--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x2.e - y2.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k2 = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k2) && sd--; i++) {
          t = k2 * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k2 = t % yd | 0;
        }
        more = k2 || i < xL;
      } else {
        k2 = base / (yd[0] + 1) | 0;
        if (k2 > 1) {
          yd = multiplyInteger(yd, k2, base);
          xd = multiplyInteger(xd, k2, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k2 = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k2 = rem0 / yd0 | 0;
            if (k2 > 1) {
              if (k2 >= base)
                k2 = base - 1;
              prod = multiplyInteger(yd, k2, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k2--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k2 == 0)
                cmp = k2 = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k2++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k2++;
            rem = [0];
          }
          qd[i++] = k2;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e3;
      inexact = more;
    } else {
      for (i = 1, k2 = qd[0]; k2 >= 10; k2 /= 10)
        i++;
      q.e = i + e3 * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x2, sd, rm, isTruncated) {
  var digits2, i, j, k2, rd, roundUp, w, xd, xdi, Ctor = x2.constructor;
  out:
    if (sd != null) {
      xd = x2.d;
      if (!xd)
        return x2;
      for (digits2 = 1, k2 = xd[0]; k2 >= 10; k2 /= 10)
        digits2++;
      i = sd - digits2;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k2 = xd.length;
        if (xdi >= k2) {
          if (isTruncated) {
            for (; k2++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits2 = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k2 = xd[xdi];
          for (digits2 = 1; k2 >= 10; k2 /= 10)
            digits2++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits2;
          rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x2.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x2.e = -sd || 0;
        } else {
          xd[0] = x2.e = 0;
        }
        return x2;
      }
      if (i == 0) {
        xd.length = xdi;
        k2 = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k2 = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k2 : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0]; j >= 10; j /= 10)
              i++;
            j = xd[0] += k2;
            for (k2 = 1; j >= 10; j /= 10)
              k2++;
            if (i != k2) {
              x2.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k2;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k2 = 1;
          }
        }
      }
      for (i = xd.length; xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x2.e > Ctor.maxE) {
      x2.d = null;
      x2.e = NaN;
    } else if (x2.e < Ctor.minE) {
      x2.e = 0;
      x2.d = [0];
    }
  }
  return x2;
}
function finiteToString(x2, isExp, sd) {
  if (!x2.isFinite())
    return nonFiniteToString(x2);
  var k2, e3 = x2.e, str = digitsToString(x2.d), len = str.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x2.e < 0 ? "e" : "e+") + x2.e;
  } else if (e3 < 0) {
    str = "0." + getZeroString(-e3 - 1) + str;
    if (sd && (k2 = sd - len) > 0)
      str += getZeroString(k2);
  } else if (e3 >= len) {
    str += getZeroString(e3 + 1 - len);
    if (sd && (k2 = sd - e3 - 1) > 0)
      str = str + "." + getZeroString(k2);
  } else {
    if ((k2 = e3 + 1) < len)
      str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e3 + 1 === len)
        str += ".";
      str += getZeroString(k2);
    }
  }
  return str;
}
function getBase10Exponent(digits2, e3) {
  var w = digits2[0];
  for (e3 *= LOG_BASE; w >= 10; w /= 10)
    e3++;
  return e3;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits2) {
  var w = digits2.length - 1, len = w * LOG_BASE + 1;
  w = digits2[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits2[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k2) {
  var zs = "";
  for (; k2--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x2, n, pr) {
  var isTruncated, r = new Ctor(1), k2 = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x2);
      if (truncate(r.d, k2))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x2 = x2.times(x2);
    truncate(x2.d, k2);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y2, x2 = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y2 = new Ctor(args[i]);
    if (!y2.s) {
      x2 = y2;
      break;
    } else if (x2[ltgt](y2)) {
      x2 = y2;
    }
  }
  return x2;
}
function naturalExponential(x2, sd) {
  var denominator, guard, j, pow3, sum3, t, wpr, rep = 0, i = 0, k2 = 0, Ctor = x2.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x2.d || !x2.d[0] || x2.e > 17) {
    return new Ctor(x2.d ? !x2.d[0] ? 1 : x2.s < 0 ? 0 : 1 / 0 : x2.s ? x2.s < 0 ? 0 : x2 : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x2.e > -2) {
    x2 = x2.times(t);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow3 = sum3 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow3 = finalise(pow3.times(x2), wpr, 1);
    denominator = denominator.times(++i);
    t = sum3.plus(divide(pow3, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
      j = k2;
      while (j--)
        sum3 = finalise(sum3.times(sum3), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow3 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum3, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum3;
      }
    }
    sum3 = t;
  }
}
function naturalLogarithm(y2, sd) {
  var c2, c0, denominator, e3, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x3 = y2, xd = x3.d, Ctor = x3.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x3.s < 0 || !xd || !xd[0] || !x3.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x3.s != 1 ? NaN : xd ? 0 : x3);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c2 = digitsToString(xd);
  c0 = c2.charAt(0);
  if (Math.abs(e3 = x3.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x3 = x3.times(y2);
      c2 = digitsToString(x3.d);
      c0 = c2.charAt(0);
      n++;
    }
    e3 = x3.e;
    if (c0 > 1) {
      x3 = new Ctor("0." + c2);
      e3++;
    } else {
      x3 = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
    x3 = naturalLogarithm(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x3, pr, rm, external = true) : x3;
  }
  x1 = x3;
  sum3 = numerator = x3 = divide(x3.minus(1), x3.plus(1), wpr, 1);
  x2 = finalise(x3.times(x3), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
      sum3 = sum3.times(2);
      if (e3 !== 0)
        sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
      sum3 = divide(sum3, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x3 = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x3.times(x3), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum3, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum3;
      }
    }
    sum3 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x2) {
  return String(x2.s * x2.s / 0);
}
function parseDecimal(x2, str) {
  var e3, i, len;
  if ((e3 = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e3 < 0)
      e3 = i;
    e3 += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e3 < 0) {
    e3 = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x2.e = e3 = e3 - i - 1;
    x2.d = [];
    i = (e3 + 1) % LOG_BASE;
    if (e3 < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x2.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x2.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x2.d.push(+str);
    if (external) {
      if (x2.e > x2.constructor.maxE) {
        x2.d = null;
        x2.e = NaN;
      } else if (x2.e < x2.constructor.minE) {
        x2.e = 0;
        x2.d = [0];
      }
    }
  } else {
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function parseOther(x2, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x2, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x2.s = NaN;
    x2.e = NaN;
    x2.d = null;
    return x2;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x2.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x2.s * 0);
  x2.e = getBase10Exponent(xd, xe);
  x2.d = xd;
  external = false;
  if (isFloat)
    x2 = divide(x2, divisor, len * 4);
  if (p)
    x2 = x2.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x2;
}
function sine(Ctor, x2) {
  var k2, len = x2.d.length;
  if (len < 3) {
    return x2.isZero() ? x2 : taylorSeries(Ctor, 2, x2, x2);
  }
  k2 = 1.4 * Math.sqrt(len);
  k2 = k2 > 16 ? 16 : k2 | 0;
  x2 = x2.times(1 / tinyPow(5, k2));
  x2 = taylorSeries(Ctor, 2, x2, x2);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k2--; ) {
    sin2_x = x2.times(x2);
    x2 = x2.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x2;
}
function taylorSeries(Ctor, n, x2, y2, isHyperbolic) {
  var j, t, u, x22, i = 1, pr = Ctor.precision, k2 = Math.ceil(pr / LOG_BASE);
  external = false;
  x22 = x2.times(x2);
  u = new Ctor(y2);
  for (; ; ) {
    t = divide(u.times(x22), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y2.plus(t) : y2.minus(t);
    y2 = divide(t.times(x22), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y2);
    if (t.d[k2] !== void 0) {
      for (j = k2; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y2;
    y2 = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k2 + 1;
  return t;
}
function tinyPow(b, e3) {
  var n = b;
  while (--e3)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x2) {
  var t, isNeg = x2.s < 0, pi4 = getPi(Ctor, Ctor.precision, 1), halfPi2 = pi4.times(0.5);
  x2 = x2.abs();
  if (x2.lte(halfPi2)) {
    quadrant = isNeg ? 4 : 1;
    return x2;
  }
  t = x2.divToInt(pi4);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x2 = x2.minus(t.times(pi4));
    if (x2.lte(halfPi2)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x2;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x2.minus(pi4).abs();
}
function toStringBinary(x2, baseOut, sd, rm) {
  var base, e3, i, k2, len, roundUp, str, xd, y2, Ctor = x2.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x2.isFinite()) {
    str = nonFiniteToString(x2);
  } else {
    str = finiteToString(x2);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y2 = new Ctor(1);
      y2.e = str.length - i;
      y2.d = convertBase(finiteToString(y2), 10, base);
      y2.e = y2.d.length;
    }
    xd = convertBase(str, 10, base);
    e3 = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e3--;
      } else {
        x2 = new Ctor(x2);
        x2.d = xd;
        x2.e = e3;
        x2 = divide(x2, y2, sd, rm, 0, base);
        xd = x2.d;
        e3 = x2.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k2 = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x2.s < 0 ? 3 : 2)) : i > k2 || i === k2 && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x2.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e3;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i = 0, str = ""; i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 1, str = "1."; i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e3 < 0 ? "p" : "p+") + e3;
      } else if (e3 < 0) {
        for (; ++e3; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e3 > len)
          for (e3 -= len; e3--; )
            str += "0";
        else if (e3 < len)
          str = str.slice(0, e3) + "." + str.slice(e3);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x2) {
  return new this(x2).abs();
}
function acos(x2) {
  return new this(x2).acos();
}
function acosh2(x2) {
  return new this(x2).acosh();
}
function add(x2, y2) {
  return new this(x2).plus(y2);
}
function asin(x2) {
  return new this(x2).asin();
}
function asinh2(x2) {
  return new this(x2).asinh();
}
function atan(x2) {
  return new this(x2).atan();
}
function atanh2(x2) {
  return new this(x2).atanh();
}
function atan2(y2, x2) {
  y2 = new this(y2);
  x2 = new this(x2);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y2.s || !x2.s) {
    r = new this(NaN);
  } else if (!y2.d && !x2.d) {
    r = getPi(this, wpr, 1).times(x2.s > 0 ? 0.25 : 0.75);
    r.s = y2.s;
  } else if (!x2.d || y2.isZero()) {
    r = x2.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y2.s;
  } else if (!y2.d || x2.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y2.s;
  } else if (x2.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y2, x2, wpr, 1));
    x2 = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y2.s < 0 ? r.minus(x2) : r.plus(x2);
  } else {
    r = this.atan(divide(y2, x2, wpr, 1));
  }
  return r;
}
function cbrt3(x2) {
  return new this(x2).cbrt();
}
function ceil(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 2);
}
function clamp(x2, min4, max4) {
  return new this(x2).clamp(min4, max4);
}
function config3(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x2) {
  return new this(x2).cos();
}
function cosh2(x2) {
  return new this(x2).cosh();
}
function clone3(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e3, i2, t, x2 = this;
    if (!(x2 instanceof Decimal2))
      return new Decimal2(v);
    x2.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x2.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x2.e = NaN;
          x2.d = null;
        } else if (v.e < Decimal2.minE) {
          x2.e = 0;
          x2.d = [0];
        } else {
          x2.e = v.e;
          x2.d = v.d.slice();
        }
      } else {
        x2.e = v.e;
        x2.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x2.s = 1 / v < 0 ? -1 : 1;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x2.s = -1;
      } else {
        x2.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e3 = 0, i2 = v; i2 >= 10; i2 /= 10)
          e3++;
        if (external) {
          if (e3 > Decimal2.maxE) {
            x2.e = NaN;
            x2.d = null;
          } else if (e3 < Decimal2.minE) {
            x2.e = 0;
            x2.d = [0];
          } else {
            x2.e = e3;
            x2.d = [v];
          }
        } else {
          x2.e = e3;
          x2.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x2.s = NaN;
        x2.e = NaN;
        x2.d = null;
        return;
      }
      return parseDecimal(x2, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x2.s = -1;
    } else {
      if (i2 === 43)
        v = v.slice(1);
      x2.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x2, v) : parseOther(x2, v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config3;
  Decimal2.clone = clone3;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh2;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh2;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh2;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt3;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh2;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log103;
  Decimal2.log2 = log23;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign2;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh2;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh2;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x2, y2) {
  return new this(x2).div(y2);
}
function exp(x2) {
  return new this(x2).exp();
}
function floor(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x2) {
  return new this(x2).ln();
}
function log(x2, y2) {
  return new this(x2).log(y2);
}
function log23(x2) {
  return new this(x2).log(2);
}
function log103(x2) {
  return new this(x2).log(10);
}
function max() {
  return maxOrMin(this, arguments, "lt");
}
function min() {
  return maxOrMin(this, arguments, "gt");
}
function mod(x2, y2) {
  return new this(x2).mod(y2);
}
function mul(x2, y2) {
  return new this(x2).mul(y2);
}
function pow(x2, y2) {
  return new this(x2).pow(y2);
}
function random(sd) {
  var d, e3, k2, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k2 = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k2; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k2));
    for (; i < k2; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k2 *= 4);
    for (; i < k2; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k2 / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k2 = rd[--i];
  sd %= LOG_BASE;
  if (k2 && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k2 / n | 0) * n;
  }
  for (; rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e3 = 0;
    rd = [0];
  } else {
    e3 = -1;
    for (; rd[0] === 0; e3 -= LOG_BASE)
      rd.shift();
    for (k2 = 1, n = rd[0]; n >= 10; n /= 10)
      k2++;
    if (k2 < LOG_BASE)
      e3 -= LOG_BASE - k2;
  }
  r.e = e3;
  r.d = rd;
  return r;
}
function round(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, this.rounding);
}
function sign2(x2) {
  x2 = new this(x2);
  return x2.d ? x2.d[0] ? x2.s : 0 * x2.s : x2.s || NaN;
}
function sin(x2) {
  return new this(x2).sin();
}
function sinh2(x2) {
  return new this(x2).sinh();
}
function sqrt(x2) {
  return new this(x2).sqrt();
}
function sub(x2, y2) {
  return new this(x2).sub(y2);
}
function sum() {
  var i = 0, args = arguments, x2 = new this(args[i]);
  external = false;
  for (; x2.s && ++i < args.length; )
    x2 = x2.plus(args[i]);
  external = true;
  return finalise(x2, this.precision, this.rounding);
}
function tan(x2) {
  return new this(x2).tan();
}
function tanh2(x2) {
  return new this(x2).tanh();
}
function trunc(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone3(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
var name2 = "BigNumber";
var dependencies3 = ["?on", "config"];
var createBigNumberClass = /* @__PURE__ */ factory(name2, dependencies3, (_ref) => {
  var {
    on,
    config: config4
  } = _ref;
  var BigNumber2 = decimal_default.clone({
    precision: config4.precision,
    modulo: decimal_default.EUCLID
  });
  BigNumber2.prototype = Object.create(BigNumber2.prototype);
  BigNumber2.prototype.type = "BigNumber";
  BigNumber2.prototype.isBigNumber = true;
  BigNumber2.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber2.fromJSON = function(json) {
    return new BigNumber2(json.value);
  };
  if (on) {
    on("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber2.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/complex/Complex.js
var import_complex = __toESM(require_complex(), 1);
var name3 = "Complex";
var dependencies4 = [];
var createComplexClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
  Object.defineProperty(import_complex.default, "name", {
    value: "Complex"
  });
  import_complex.default.prototype.constructor = import_complex.default;
  import_complex.default.prototype.type = "Complex";
  import_complex.default.prototype.isComplex = true;
  import_complex.default.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  import_complex.default.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  import_complex.default.prototype.format = function(options) {
    var str = "";
    var im = this.im;
    var re2 = this.re;
    var strRe = format(this.re, options);
    var strIm = format(this.im, options);
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon4 = Math.pow(10, -precision);
      if (Math.abs(re2 / im) < epsilon4) {
        re2 = 0;
      }
      if (Math.abs(im / re2) < epsilon4) {
        im = 0;
      }
    }
    if (im === 0) {
      str = strRe;
    } else if (re2 === 0) {
      if (im === 1) {
        str = "i";
      } else if (im === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im < 0) {
        if (im === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  import_complex.default.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg = arguments[0];
        if (typeof arg === "object") {
          return (0, import_complex.default)(arg);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi2 = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi2) && phi2.hasBase("ANGLE")) {
            phi2 = phi2.toNumber("rad");
          }
          if (isNumber(phi2)) {
            return new import_complex.default({
              r,
              phi: phi2
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
  import_complex.default.fromJSON = function(json) {
    return new import_complex.default(json);
  };
  import_complex.default.compare = function(a2, b) {
    if (a2.re > b.re) {
      return 1;
    }
    if (a2.re < b.re) {
      return -1;
    }
    if (a2.im > b.im) {
      return 1;
    }
    if (a2.im < b.im) {
      return -1;
    }
    return 0;
  };
  return import_complex.default;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/fraction/Fraction.js
var import_fraction = __toESM(require_fraction(), 1);
var name4 = "Fraction";
var dependencies5 = [];
var createFractionClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
  Object.defineProperty(import_fraction.default, "name", {
    value: "Fraction"
  });
  import_fraction.default.prototype.constructor = import_fraction.default;
  import_fraction.default.prototype.type = "Fraction";
  import_fraction.default.prototype.isFraction = true;
  import_fraction.default.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: this.s * this.n,
      d: this.d
    };
  };
  import_fraction.default.fromJSON = function(json) {
    return new import_fraction.default(json);
  };
  return import_fraction.default;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Range.js
var name5 = "Range";
var dependencies6 = [];
var createRangeClass = /* @__PURE__ */ factory(name5, dependencies6, () => {
  function Range(start2, end, step) {
    if (!(this instanceof Range)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    var hasStart = start2 !== null && start2 !== void 0;
    var hasEnd = end !== null && end !== void 0;
    var hasStep = step !== null && step !== void 0;
    if (hasStart) {
      if (isBigNumber(start2)) {
        start2 = start2.toNumber();
      } else if (typeof start2 !== "number") {
        throw new TypeError("Parameter start must be a number");
      }
    }
    if (hasEnd) {
      if (isBigNumber(end)) {
        end = end.toNumber();
      } else if (typeof end !== "number") {
        throw new TypeError("Parameter end must be a number");
      }
    }
    if (hasStep) {
      if (isBigNumber(step)) {
        step = step.toNumber();
      } else if (typeof step !== "number") {
        throw new TypeError("Parameter step must be a number");
      }
    }
    this.start = hasStart ? parseFloat(start2) : 0;
    this.end = hasEnd ? parseFloat(end) : 0;
    this.step = hasStep ? parseFloat(step) : 1;
  }
  Range.prototype.type = "Range";
  Range.prototype.isRange = true;
  Range.parse = function(str) {
    if (typeof str !== "string") {
      return null;
    }
    var args = str.split(":");
    var nums = args.map(function(arg) {
      return parseFloat(arg);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return new Range(nums[0], nums[1]);
      case 3:
        return new Range(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };
  Range.prototype.clone = function() {
    return new Range(this.start, this.end, this.step);
  };
  Range.prototype.size = function() {
    var len = 0;
    var start2 = this.start;
    var step = this.step;
    var end = this.end;
    var diff = end - start2;
    if (sign(step) === sign(diff)) {
      len = Math.ceil(diff / step);
    } else if (diff === 0) {
      len = 0;
    }
    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };
  Range.prototype.min = function() {
    var size = this.size()[0];
    if (size > 0) {
      if (this.step > 0) {
        return this.start;
      } else {
        return this.start + (size - 1) * this.step;
      }
    } else {
      return void 0;
    }
  };
  Range.prototype.max = function() {
    var size = this.size()[0];
    if (size > 0) {
      if (this.step > 0) {
        return this.start + (size - 1) * this.step;
      } else {
        return this.start;
      }
    } else {
      return void 0;
    }
  };
  Range.prototype.forEach = function(callback) {
    var x2 = this.start;
    var step = this.step;
    var end = this.end;
    var i = 0;
    if (step > 0) {
      while (x2 < end) {
        callback(x2, [i], this);
        x2 += step;
        i++;
      }
    } else if (step < 0) {
      while (x2 > end) {
        callback(x2, [i], this);
        x2 += step;
        i++;
      }
    }
  };
  Range.prototype.map = function(callback) {
    var array2 = [];
    this.forEach(function(value, index, obj) {
      array2[index[0]] = callback(value, index, obj);
    });
    return array2;
  };
  Range.prototype.toArray = function() {
    var array2 = [];
    this.forEach(function(value, index) {
      array2[index[0]] = value;
    });
    return array2;
  };
  Range.prototype.valueOf = function() {
    return this.toArray();
  };
  Range.prototype.format = function(options) {
    var str = format(this.start, options);
    if (this.step !== 1) {
      str += ":" + format(this.step, options);
    }
    str += ":" + format(this.end, options);
    return str;
  };
  Range.prototype.toString = function() {
    return this.format();
  };
  Range.prototype.toJSON = function() {
    return {
      mathjs: "Range",
      start: this.start,
      end: this.end,
      step: this.step
    };
  };
  Range.fromJSON = function(json) {
    return new Range(json.start, json.end, json.step);
  };
  return Range;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Matrix.js
var name6 = "Matrix";
var dependencies7 = [];
var createMatrixClass = /* @__PURE__ */ factory(name6, dependencies7, () => {
  function Matrix2() {
    if (!(this instanceof Matrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix2.prototype.type = "Matrix";
  Matrix2.prototype.isMatrix = true;
  Matrix2.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix2.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix2.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix2.prototype.subset = function(index, replacement, defaultValue) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix2.prototype.get = function(index) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix2.prototype.set = function(index, value, defaultValue) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix2.prototype.resize = function(size, defaultValue) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix2.prototype.reshape = function(size, defaultValue) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix2.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix2.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix2.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix2.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix2.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix2.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix2.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix2.prototype.format = function(options) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix2.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/utils/lruQueue.js
function lruQueue(limit) {
  var size = 0;
  var base = 1;
  var queue = /* @__PURE__ */ Object.create(null);
  var map3 = /* @__PURE__ */ Object.create(null);
  var index = 0;
  var del = function del2(id2) {
    var oldIndex = map3[id2];
    if (!oldIndex)
      return;
    delete queue[oldIndex];
    delete map3[id2];
    --size;
    if (base !== oldIndex)
      return;
    if (!size) {
      index = 0;
      base = 1;
      return;
    }
    while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
    }
  };
  limit = Math.abs(limit);
  return {
    hit: function hit(id2) {
      var oldIndex = map3[id2];
      var nuIndex = ++index;
      queue[nuIndex] = id2;
      map3[id2] = nuIndex;
      if (!oldIndex) {
        ++size;
        if (size <= limit)
          return void 0;
        id2 = queue[base];
        del(id2);
        return id2;
      }
      delete queue[oldIndex];
      if (base !== oldIndex)
        return void 0;
      while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
      }
      return void 0;
    },
    delete: del,
    clear: function clear() {
      size = index = 0;
      base = 1;
      queue = /* @__PURE__ */ Object.create(null);
      map3 = /* @__PURE__ */ Object.create(null);
    }
  };
}

// node_modules/mathjs/lib/esm/utils/function.js
function memoize(fn) {
  var {
    hasher: hasher2,
    limit
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  limit = limit == null ? Number.POSITIVE_INFINITY : limit;
  hasher2 = hasher2 == null ? JSON.stringify : hasher2;
  return function memoize2() {
    if (typeof memoize2.cache !== "object") {
      memoize2.cache = {
        values: /* @__PURE__ */ new Map(),
        lru: lruQueue(limit || Number.POSITIVE_INFINITY)
      };
    }
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    var hash = hasher2(args);
    if (memoize2.cache.values.has(hash)) {
      memoize2.cache.lru.hit(hash);
      return memoize2.cache.values.get(hash);
    }
    var newVal = fn.apply(fn, args);
    memoize2.cache.values.set(hash, newVal);
    memoize2.cache.values.delete(memoize2.cache.lru.hit(hash));
    return newVal;
  };
}
function maxArgumentCount(fn) {
  return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
    var count = (signature.match(/,/g) || []).length + 1;
    return Math.max(args, count);
  }, -1);
}

// node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
var name7 = "DenseMatrix";
var dependencies8 = ["Matrix"];
var createDenseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
  var {
    Matrix: Matrix2
  } = _ref;
  function DenseMatrix2(data, datatype) {
    if (!(this instanceof DenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone(data._data);
        this._size = clone(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix2.prototype = new Matrix2();
  DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  Object.defineProperty(DenseMatrix2, "name", {
    value: "DenseMatrix"
  });
  DenseMatrix2.prototype.constructor = DenseMatrix2;
  DenseMatrix2.prototype.type = "DenseMatrix";
  DenseMatrix2.prototype.isDenseMatrix = true;
  DenseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf);
  };
  DenseMatrix2.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix2.prototype.create = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.subset = function(index, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index);
      case 2:
      case 3:
        return _set(this, index, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix2.prototype.get = function(index) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    for (var x2 = 0; x2 < index.length; x2++) {
      validateIndex(index[x2], this._size[x2]);
    }
    var data = this._data;
    for (var i = 0, ii = index.length; i < ii; i++) {
      var indexI = index[i];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    return data;
  };
  DenseMatrix2.prototype.set = function(index, value, defaultValue) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length < this._size.length) {
      throw new DimensionError(index.length, this._size.length, "<");
    }
    var i, ii, indexI;
    var size = index.map(function(i2) {
      return i2 + 1;
    });
    _fit(this, size, defaultValue);
    var data = this._data;
    for (i = 0, ii = index.length - 1; i < ii; i++) {
      indexI = index[i];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index[index.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix, index) {
    if (!isIndex(index)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index.isScalar();
    if (isScalar) {
      return matrix.get(index.min());
    } else {
      var size = index.size();
      if (size.length !== matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      }
      var min4 = index.min();
      var max4 = index.max();
      for (var i = 0, ii = matrix._size.length; i < ii; i++) {
        validateIndex(min4[i], matrix._size[i]);
        validateIndex(max4[i], matrix._size[i]);
      }
      return new DenseMatrix2(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
    }
  }
  function _getSubmatrix(data, index, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index.dimension(dim);
    if (last) {
      return range2.map(function(i) {
        validateIndex(i, data.length);
        return data[i];
      }).valueOf();
    } else {
      return range2.map(function(i) {
        validateIndex(i, data.length);
        var child = data[i];
        return _getSubmatrix(child, index, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix, index, submatrix, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index.size();
    var isScalar = index.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix.set(index.min(), submatrix, defaultValue);
    } else {
      if (!deepStrictEqual(sSize, iSize)) {
        try {
          if (sSize.length === 0) {
            submatrix = broadcastTo([submatrix], iSize);
          } else {
            submatrix = broadcastTo(submatrix, iSize);
          }
          sSize = arraySize(submatrix);
        } catch (_unused) {
        }
      }
      if (iSize.length < matrix._size.length) {
        throw new DimensionError(iSize.length, matrix._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size = index.max().map(function(i2) {
        return i2 + 1;
      });
      _fit(matrix, size, defaultValue);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix._data, index, submatrix, dims, dim);
    }
    return matrix;
  }
  function _setSubmatrix(data, index, submatrix, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index.dimension(dim);
    if (last) {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix2.prototype.resize = function(size, defaultValue, copy3) {
    if (!isCollection(size)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy3 ? this.clone() : this;
    return _resize2(m, sizeArray, defaultValue);
  };
  function _resize2(matrix, size, defaultValue) {
    if (size.length === 0) {
      var v = matrix._data;
      while (isArray(v)) {
        v = v[0];
      }
      return v;
    }
    matrix._size = size.slice(0);
    matrix._data = resize(matrix._data, matrix._size, defaultValue);
    return matrix;
  }
  DenseMatrix2.prototype.reshape = function(size, copy3) {
    var m = copy3 ? this.clone() : this;
    m._data = reshape(m._data, size);
    var currentLength = m._size.reduce((length, size2) => length * size2);
    m._size = processSizesWildcard(size, currentLength);
    return m;
  };
  function _fit(matrix, size, defaultValue) {
    var newSize = matrix._size.slice(0);
    var changed = false;
    while (newSize.length < size.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i = 0, ii = size.length; i < ii; i++) {
      if (size[i] > newSize[i]) {
        newSize[i] = size[i];
        changed = true;
      }
    }
    if (changed) {
      _resize2(matrix, newSize, defaultValue);
    }
  }
  DenseMatrix2.prototype.clone = function() {
    var m = new DenseMatrix2({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix2.prototype.map = function(callback) {
    var me = this;
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index) {
      if (isArray(value)) {
        return value.map(function(child, i) {
          return recurse2(child, index.concat(i));
        });
      } else {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index);
        } else {
          return callback(value, index, me);
        }
      }
    };
    var data = recurse(this._data, []);
    var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.forEach = function(callback) {
    var me = this;
    var recurse = function recurse2(value, index) {
      if (isArray(value)) {
        value.forEach(function(child, i) {
          recurse2(child, index.concat(i));
        });
      } else {
        callback(value, index, me);
      }
    };
    recurse(this._data, []);
  };
  DenseMatrix2.prototype[Symbol.iterator] = function* () {
    var recurse = function* recurse2(value, index) {
      if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          yield* recurse2(value[i], index.concat(i));
        }
      } else {
        yield {
          value,
          index
        };
      }
    };
    yield* recurse(this._data, []);
  };
  DenseMatrix2.prototype.rows = function() {
    var result = [];
    var s2 = this.size();
    if (s2.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row of data) {
      result.push(new DenseMatrix2([row], this._datatype));
    }
    return result;
  };
  DenseMatrix2.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s2 = this.size();
    if (s2.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop2(i2) {
      var col = data.map((row) => [row[i2]]);
      result.push(new DenseMatrix2(col, _this._datatype));
    };
    for (var i = 0; i < s2[1]; i++) {
      _loop(i);
    }
    return result;
  };
  DenseMatrix2.prototype.toArray = function() {
    return clone(this._data);
  };
  DenseMatrix2.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix2.prototype.format = function(options) {
    return format3(this._data, options);
  };
  DenseMatrix2.prototype.toString = function() {
    return format3(this._data);
  };
  DenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix2.prototype.diagonal = function(k2) {
    if (k2) {
      if (isBigNumber(k2)) {
        k2 = k2.toNumber();
      }
      if (!isNumber(k2) || !isInteger(k2)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k2 = 0;
    }
    var kSuper = k2 > 0 ? k2 : 0;
    var kSub = k2 < 0 ? -k2 : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i = 0; i < n; i++) {
      data[i] = this._data[i + kSub][i + kSuper];
    }
    return new DenseMatrix2({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix2.diagonal = function(size, value, k2, defaultValue) {
    if (!isArray(size)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size = size.map(function(s2) {
      if (isBigNumber(s2)) {
        s2 = s2.toNumber();
      }
      if (!isNumber(s2) || !isInteger(s2) || s2 < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s2;
    });
    if (k2) {
      if (isBigNumber(k2)) {
        k2 = k2.toNumber();
      }
      if (!isNumber(k2) || !isInteger(k2)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k2 = 0;
    }
    var kSuper = k2 > 0 ? k2 : 0;
    var kSub = k2 < 0 ? -k2 : 0;
    var rows = size[0];
    var columns = size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i) {
        return value[i];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i) {
        return value.get([i]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    if (!defaultValue) {
      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size.length > 0) {
      data = resize(data, size, defaultValue);
      for (var d = 0; d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix2({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix2.fromJSON = function(json) {
    return new DenseMatrix2(json);
  };
  DenseMatrix2.prototype.swapRows = function(i, j) {
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix2._swapRows(i, j, this._data);
    return this;
  };
  DenseMatrix2._swapRows = function(i, j, data) {
    var vi = data[i];
    data[i] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    if (isMatrix(data)) {
      return preprocess(data.valueOf());
    }
    if (isArray(data)) {
      return data.map(preprocess);
    }
    return data;
  }
  return DenseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/function/utils/clone.js
var name8 = "clone";
var dependencies9 = ["typed"];
var createClone = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name8, {
    any: clone
  });
});

// node_modules/mathjs/lib/esm/utils/switch.js
function _switch(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i = 0; i < I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

// node_modules/mathjs/lib/esm/utils/collection.js
function containsCollections(array2) {
  for (var i = 0; i < array2.length; i++) {
    if (isCollection(array2[i])) {
      return true;
    }
  }
  return false;
}
function deepForEach(array2, callback) {
  if (isMatrix(array2)) {
    array2 = array2.valueOf();
  }
  for (var i = 0, ii = array2.length; i < ii; i++) {
    var value = array2[i];
    if (Array.isArray(value)) {
      deepForEach(value, callback);
    } else {
      callback(value);
    }
  }
}
function deepMap(array2, callback, skipZeros) {
  if (array2 && typeof array2.map === "function") {
    return array2.map(function(x2) {
      return deepMap(x2, callback, skipZeros);
    });
  } else {
    return callback(array2);
  }
}
function reduce(mat, dim, callback) {
  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || dim >= size.length) {
    throw new IndexError(dim, size.length);
  }
  if (isMatrix(mat)) {
    return mat.create(_reduce(mat.valueOf(), dim, callback));
  } else {
    return _reduce(mat, dim, callback);
  }
}
function _reduce(mat, dim, callback) {
  var i, ret, val, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      val = mat[0];
      for (i = 1; i < mat.length; i++) {
        val = callback(val, mat[i]);
      }
      return val;
    } else {
      tran = _switch(mat);
      ret = [];
      for (i = 0; i < tran.length; i++) {
        ret[i] = _reduce(tran[i], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i = 0; i < mat.length; i++) {
      ret[i] = _reduce(mat[i], dim - 1, callback);
    }
    return ret;
  }
}
function scatter(a2, j, w, x2, u, mark, cindex, f, inverse, update, value) {
  var avalues = a2._values;
  var aindex = a2._index;
  var aptr = a2._ptr;
  var k2, k0, k1, i;
  if (x2) {
    for (k0 = aptr[j], k1 = aptr[j + 1], k2 = k0; k2 < k1; k2++) {
      i = aindex[k2];
      if (w[i] !== mark) {
        w[i] = mark;
        cindex.push(i);
        if (update) {
          x2[i] = inverse ? f(avalues[k2], value) : f(value, avalues[k2]);
          u[i] = mark;
        } else {
          x2[i] = avalues[k2];
        }
      } else {
        x2[i] = inverse ? f(avalues[k2], x2[i]) : f(x2[i], avalues[k2]);
        u[i] = mark;
      }
    }
  } else {
    for (k0 = aptr[j], k1 = aptr[j + 1], k2 = k0; k2 < k1; k2++) {
      i = aindex[k2];
      if (w[i] !== mark) {
        w[i] = mark;
        cindex.push(i);
      } else {
        u[i] = mark;
      }
    }
  }
}

// node_modules/mathjs/lib/esm/function/utils/isInteger.js
var name9 = "isInteger";
var dependencies10 = ["typed"];
var createIsInteger = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name9, {
    number: isInteger,
    // TODO: what to do with isInteger(add(0.1, 0.2))  ?
    BigNumber: function BigNumber2(x2) {
      return x2.isInt();
    },
    Fraction: function Fraction3(x2) {
      return x2.d === 1 && isFinite(x2.n);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/plain/number/arithmetic.js
var n1 = "number";
var n2 = "number, number";
function absNumber(a2) {
  return Math.abs(a2);
}
absNumber.signature = n1;
function addNumber(a2, b) {
  return a2 + b;
}
addNumber.signature = n2;
function subtractNumber(a2, b) {
  return a2 - b;
}
subtractNumber.signature = n2;
function multiplyNumber(a2, b) {
  return a2 * b;
}
multiplyNumber.signature = n2;
function divideNumber(a2, b) {
  return a2 / b;
}
divideNumber.signature = n2;
function unaryMinusNumber(x2) {
  return -x2;
}
unaryMinusNumber.signature = n1;
function unaryPlusNumber(x2) {
  return x2;
}
unaryPlusNumber.signature = n1;
function cbrtNumber(x2) {
  return cbrt(x2);
}
cbrtNumber.signature = n1;
function cubeNumber(x2) {
  return x2 * x2 * x2;
}
cubeNumber.signature = n1;
function expNumber(x2) {
  return Math.exp(x2);
}
expNumber.signature = n1;
function expm1Number(x2) {
  return expm1(x2);
}
expm1Number.signature = n1;
function gcdNumber(a2, b) {
  if (!isInteger(a2) || !isInteger(b)) {
    throw new Error("Parameters in function gcd must be integer numbers");
  }
  var r;
  while (b !== 0) {
    r = a2 % b;
    a2 = b;
    b = r;
  }
  return a2 < 0 ? -a2 : a2;
}
gcdNumber.signature = n2;
function lcmNumber(a2, b) {
  if (!isInteger(a2) || !isInteger(b)) {
    throw new Error("Parameters in function lcm must be integer numbers");
  }
  if (a2 === 0 || b === 0) {
    return 0;
  }
  var t;
  var prod = a2 * b;
  while (b !== 0) {
    t = b;
    b = a2 % t;
    a2 = t;
  }
  return Math.abs(prod / a2);
}
lcmNumber.signature = n2;
function logNumber(x2, y2) {
  if (y2) {
    return Math.log(x2) / Math.log(y2);
  }
  return Math.log(x2);
}
function log10Number(x2) {
  return log10(x2);
}
log10Number.signature = n1;
function log2Number(x2) {
  return log2(x2);
}
log2Number.signature = n1;
function log1pNumber(x2) {
  return log1p(x2);
}
log1pNumber.signature = n1;
function modNumber(x2, y2) {
  return y2 === 0 ? x2 : x2 - y2 * Math.floor(x2 / y2);
}
modNumber.signature = n2;
function nthRootNumber(a2) {
  var root2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var inv = root2 < 0;
  if (inv) {
    root2 = -root2;
  }
  if (root2 === 0) {
    throw new Error("Root must be non-zero");
  }
  if (a2 < 0 && Math.abs(root2) % 2 !== 1) {
    throw new Error("Root must be odd when a is negative.");
  }
  if (a2 === 0) {
    return inv ? Infinity : 0;
  }
  if (!isFinite(a2)) {
    return inv ? 0 : a2;
  }
  var x2 = Math.pow(Math.abs(a2), 1 / root2);
  x2 = a2 < 0 ? -x2 : x2;
  return inv ? 1 / x2 : x2;
}
function signNumber(x2) {
  return sign(x2);
}
signNumber.signature = n1;
function sqrtNumber(x2) {
  return Math.sqrt(x2);
}
sqrtNumber.signature = n1;
function squareNumber(x2) {
  return x2 * x2;
}
squareNumber.signature = n1;
function xgcdNumber(a2, b) {
  var t;
  var q;
  var r;
  var x2 = 0;
  var lastx = 1;
  var y2 = 1;
  var lasty = 0;
  if (!isInteger(a2) || !isInteger(b)) {
    throw new Error("Parameters in function xgcd must be integer numbers");
  }
  while (b) {
    q = Math.floor(a2 / b);
    r = a2 - q * b;
    t = x2;
    x2 = lastx - q * x2;
    lastx = t;
    t = y2;
    y2 = lasty - q * y2;
    lasty = t;
    a2 = b;
    b = r;
  }
  var res;
  if (a2 < 0) {
    res = [-a2, -lastx, -lasty];
  } else {
    res = [a2, a2 ? lastx : 0, lasty];
  }
  return res;
}
xgcdNumber.signature = n2;
function powNumber(x2, y2) {
  if (x2 * x2 < 1 && y2 === Infinity || x2 * x2 > 1 && y2 === -Infinity) {
    return 0;
  }
  return Math.pow(x2, y2);
}
powNumber.signature = n2;
function roundNumber(value) {
  var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  }
  return parseFloat(toFixed(value, decimals));
}
function normNumber(x2) {
  return Math.abs(x2);
}
normNumber.signature = n1;

// node_modules/mathjs/lib/esm/plain/number/bitwise.js
var n12 = "number";
var n22 = "number, number";
function bitAndNumber(x2, y2) {
  if (!isInteger(x2) || !isInteger(y2)) {
    throw new Error("Integers expected in function bitAnd");
  }
  return x2 & y2;
}
bitAndNumber.signature = n22;
function bitNotNumber(x2) {
  if (!isInteger(x2)) {
    throw new Error("Integer expected in function bitNot");
  }
  return ~x2;
}
bitNotNumber.signature = n12;
function bitOrNumber(x2, y2) {
  if (!isInteger(x2) || !isInteger(y2)) {
    throw new Error("Integers expected in function bitOr");
  }
  return x2 | y2;
}
bitOrNumber.signature = n22;
function bitXorNumber(x2, y2) {
  if (!isInteger(x2) || !isInteger(y2)) {
    throw new Error("Integers expected in function bitXor");
  }
  return x2 ^ y2;
}
bitXorNumber.signature = n22;
function leftShiftNumber(x2, y2) {
  if (!isInteger(x2) || !isInteger(y2)) {
    throw new Error("Integers expected in function leftShift");
  }
  return x2 << y2;
}
leftShiftNumber.signature = n22;
function rightArithShiftNumber(x2, y2) {
  if (!isInteger(x2) || !isInteger(y2)) {
    throw new Error("Integers expected in function rightArithShift");
  }
  return x2 >> y2;
}
rightArithShiftNumber.signature = n22;
function rightLogShiftNumber(x2, y2) {
  if (!isInteger(x2) || !isInteger(y2)) {
    throw new Error("Integers expected in function rightLogShift");
  }
  return x2 >>> y2;
}
rightLogShiftNumber.signature = n22;

// node_modules/mathjs/lib/esm/utils/product.js
function product2(i, n) {
  if (n < i) {
    return 1;
  }
  if (n === i) {
    return n;
  }
  var half = n + i >> 1;
  return product2(i, half) * product2(half + 1, n);
}

// node_modules/mathjs/lib/esm/plain/number/combinations.js
function combinationsNumber(n, k2) {
  if (!isInteger(n) || n < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (!isInteger(k2) || k2 < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (k2 > n) {
    throw new TypeError("k must be less than or equal to n");
  }
  var nMinusk = n - k2;
  var answer = 1;
  var firstnumerator = k2 < nMinusk ? nMinusk + 1 : k2 + 1;
  var nextdivisor = 2;
  var lastdivisor = k2 < nMinusk ? k2 : nMinusk;
  for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
    answer *= nextnumerator;
    while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
      answer /= nextdivisor;
      ++nextdivisor;
    }
  }
  if (nextdivisor <= lastdivisor) {
    answer /= product2(nextdivisor, lastdivisor);
  }
  return answer;
}
combinationsNumber.signature = "number, number";

// node_modules/mathjs/lib/esm/plain/number/constants.js
var pi = Math.PI;
var tau = 2 * Math.PI;
var e = Math.E;
var phi = 1.618033988749895;

// node_modules/mathjs/lib/esm/plain/number/logical.js
var n13 = "number";
var n23 = "number, number";
function notNumber(x2) {
  return !x2;
}
notNumber.signature = n13;
function orNumber(x2, y2) {
  return !!(x2 || y2);
}
orNumber.signature = n23;
function xorNumber(x2, y2) {
  return !!x2 !== !!y2;
}
xorNumber.signature = n23;
function andNumber(x2, y2) {
  return !!(x2 && y2);
}
andNumber.signature = n23;

// node_modules/mathjs/lib/esm/plain/number/probability.js
function gammaNumber(n) {
  var x2;
  if (isInteger(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    return product2(1, n - 1);
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x2 = gammaP[0];
  for (var i = 1; i < gammaP.length; ++i) {
    x2 += gammaP[i] / (n + i);
  }
  var t = n + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x2;
}
gammaNumber.signature = "number";
var gammaG = 4.7421875;
var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
var lnSqrt2PI = 0.9189385332046728;
var lgammaG = 5;
var lgammaN = 7;
var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
function lgammaNumber(n) {
  if (n < 0)
    return NaN;
  if (n === 0)
    return Infinity;
  if (!isFinite(n))
    return n;
  if (n < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
  }
  n = n - 1;
  var base = n + lgammaG + 0.5;
  var sum3 = lgammaSeries[0];
  for (var i = lgammaN - 1; i >= 1; i--) {
    sum3 += lgammaSeries[i] / (n + i);
  }
  return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum3);
}
lgammaNumber.signature = "number";

// node_modules/mathjs/lib/esm/plain/number/trigonometry.js
var n14 = "number";
var n24 = "number, number";
function acosNumber(x2) {
  return Math.acos(x2);
}
acosNumber.signature = n14;
function acoshNumber(x2) {
  return acosh(x2);
}
acoshNumber.signature = n14;
function acotNumber(x2) {
  return Math.atan(1 / x2);
}
acotNumber.signature = n14;
function acothNumber(x2) {
  return isFinite(x2) ? (Math.log((x2 + 1) / x2) + Math.log(x2 / (x2 - 1))) / 2 : 0;
}
acothNumber.signature = n14;
function acscNumber(x2) {
  return Math.asin(1 / x2);
}
acscNumber.signature = n14;
function acschNumber(x2) {
  var xInv = 1 / x2;
  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
}
acschNumber.signature = n14;
function asecNumber(x2) {
  return Math.acos(1 / x2);
}
asecNumber.signature = n14;
function asechNumber(x2) {
  var xInv = 1 / x2;
  var ret = Math.sqrt(xInv * xInv - 1);
  return Math.log(ret + xInv);
}
asechNumber.signature = n14;
function asinNumber(x2) {
  return Math.asin(x2);
}
asinNumber.signature = n14;
function asinhNumber(x2) {
  return asinh(x2);
}
asinhNumber.signature = n14;
function atanNumber(x2) {
  return Math.atan(x2);
}
atanNumber.signature = n14;
function atan2Number(y2, x2) {
  return Math.atan2(y2, x2);
}
atan2Number.signature = n24;
function atanhNumber(x2) {
  return atanh(x2);
}
atanhNumber.signature = n14;
function cosNumber(x2) {
  return Math.cos(x2);
}
cosNumber.signature = n14;
function coshNumber(x2) {
  return cosh(x2);
}
coshNumber.signature = n14;
function cotNumber(x2) {
  return 1 / Math.tan(x2);
}
cotNumber.signature = n14;
function cothNumber(x2) {
  var e3 = Math.exp(2 * x2);
  return (e3 + 1) / (e3 - 1);
}
cothNumber.signature = n14;
function cscNumber(x2) {
  return 1 / Math.sin(x2);
}
cscNumber.signature = n14;
function cschNumber(x2) {
  if (x2 === 0) {
    return Number.POSITIVE_INFINITY;
  } else {
    return Math.abs(2 / (Math.exp(x2) - Math.exp(-x2))) * sign(x2);
  }
}
cschNumber.signature = n14;
function secNumber(x2) {
  return 1 / Math.cos(x2);
}
secNumber.signature = n14;
function sechNumber(x2) {
  return 2 / (Math.exp(x2) + Math.exp(-x2));
}
sechNumber.signature = n14;
function sinNumber(x2) {
  return Math.sin(x2);
}
sinNumber.signature = n14;
function sinhNumber(x2) {
  return sinh(x2);
}
sinhNumber.signature = n14;
function tanNumber(x2) {
  return Math.tan(x2);
}
tanNumber.signature = n14;
function tanhNumber(x2) {
  return tanh(x2);
}
tanhNumber.signature = n14;

// node_modules/mathjs/lib/esm/plain/number/utils.js
var n15 = "number";
function isIntegerNumber(x2) {
  return isInteger(x2);
}
isIntegerNumber.signature = n15;
function isNegativeNumber(x2) {
  return x2 < 0;
}
isNegativeNumber.signature = n15;
function isPositiveNumber(x2) {
  return x2 > 0;
}
isPositiveNumber.signature = n15;
function isZeroNumber(x2) {
  return x2 === 0;
}
isZeroNumber.signature = n15;
function isNaNNumber(x2) {
  return Number.isNaN(x2);
}
isNaNNumber.signature = n15;

// node_modules/mathjs/lib/esm/function/utils/isNegative.js
var name10 = "isNegative";
var dependencies11 = ["typed"];
var createIsNegative = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name10, {
    number: isNegativeNumber,
    BigNumber: function BigNumber2(x2) {
      return x2.isNeg() && !x2.isZero() && !x2.isNaN();
    },
    Fraction: function Fraction3(x2) {
      return x2.s < 0;
    },
    Unit: typed3.referToSelf((self2) => (x2) => typed3.find(self2, x2.valueType())(x2.value)),
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isNumeric.js
var name11 = "isNumeric";
var dependencies12 = ["typed"];
var createIsNumeric = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name11, {
    "number | BigNumber | Fraction | boolean": () => true,
    "Complex | Unit | string | null | undefined | Node": () => false,
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
var name12 = "hasNumericValue";
var dependencies13 = ["typed", "isNumeric"];
var createHasNumericValue = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
  var {
    typed: typed3,
    isNumeric
  } = _ref;
  return typed3(name12, {
    boolean: () => true,
    string: function string(x2) {
      return x2.trim().length > 0 && !isNaN(Number(x2));
    },
    any: function any(x2) {
      return isNumeric(x2);
    }
  });
});

// node_modules/mathjs/lib/esm/function/utils/isPositive.js
var name13 = "isPositive";
var dependencies14 = ["typed"];
var createIsPositive = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name13, {
    number: isPositiveNumber,
    BigNumber: function BigNumber2(x2) {
      return !x2.isNeg() && !x2.isZero() && !x2.isNaN();
    },
    Fraction: function Fraction3(x2) {
      return x2.s > 0 && x2.n > 0;
    },
    Unit: typed3.referToSelf((self2) => (x2) => typed3.find(self2, x2.valueType())(x2.value)),
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isZero.js
var name14 = "isZero";
var dependencies15 = ["typed"];
var createIsZero = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name14, {
    number: isZeroNumber,
    BigNumber: function BigNumber2(x2) {
      return x2.isZero();
    },
    Complex: function Complex3(x2) {
      return x2.re === 0 && x2.im === 0;
    },
    Fraction: function Fraction3(x2) {
      return x2.d === 1 && x2.n === 0;
    },
    Unit: typed3.referToSelf((self2) => (x2) => typed3.find(self2, x2.valueType())(x2.value)),
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isNaN.js
var name15 = "isNaN";
var dependencies16 = ["typed"];
var createIsNaN = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name15, {
    number: isNaNNumber,
    BigNumber: function BigNumber2(x2) {
      return x2.isNaN();
    },
    Fraction: function Fraction3(x2) {
      return false;
    },
    Complex: function Complex3(x2) {
      return x2.isNaN();
    },
    Unit: function Unit(x2) {
      return Number.isNaN(x2.value);
    },
    "Array | Matrix": function ArrayMatrix(x2) {
      return deepMap(x2, Number.isNaN);
    }
  });
});

// node_modules/mathjs/lib/esm/function/utils/typeOf.js
var name16 = "typeOf";
var dependencies17 = ["typed"];
var createTypeOf = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name16, {
    any: typeOf
  });
});

// node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
function nearlyEqual2(x2, y2, epsilon4) {
  if (epsilon4 === null || epsilon4 === void 0) {
    return x2.eq(y2);
  }
  if (x2.eq(y2)) {
    return true;
  }
  if (x2.isNaN() || y2.isNaN()) {
    return false;
  }
  if (x2.isFinite() && y2.isFinite()) {
    var diff = x2.minus(y2).abs();
    if (diff.isZero()) {
      return true;
    } else {
      var max4 = x2.constructor.max(x2.abs(), y2.abs());
      return diff.lte(max4.times(epsilon4));
    }
  }
  return false;
}

// node_modules/mathjs/lib/esm/utils/complex.js
function complexEquals(x2, y2, epsilon4) {
  return nearlyEqual(x2.re, y2.re, epsilon4) && nearlyEqual(x2.im, y2.im, epsilon4);
}

// node_modules/mathjs/lib/esm/function/relational/compareUnits.js
var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return {
    "Unit, Unit": typed3.referToSelf((self2) => (x2, y2) => {
      if (!x2.equalBase(y2)) {
        throw new Error("Cannot compare units with different base");
      }
      return typed3.find(self2, [x2.valueType(), y2.valueType()])(x2.value, y2.value);
    })
  };
});

// node_modules/mathjs/lib/esm/function/relational/equalScalar.js
var name17 = "equalScalar";
var dependencies18 = ["typed", "config"];
var createEqualScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
  var {
    typed: typed3,
    config: config4
  } = _ref;
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name17, {
    "boolean, boolean": function booleanBoolean(x2, y2) {
      return x2 === y2;
    },
    "number, number": function numberNumber(x2, y2) {
      return nearlyEqual(x2, y2, config4.epsilon);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.eq(y2) || nearlyEqual2(x2, y2, config4.epsilon);
    },
    "Fraction, Fraction": function FractionFraction(x2, y2) {
      return x2.equals(y2);
    },
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return complexEquals(x2, y2, config4.epsilon);
    }
  }, compareUnits);
});
var createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config4
  } = _ref2;
  return typed3(name17, {
    "number, number": function numberNumber(x2, y2) {
      return nearlyEqual(x2, y2, config4.epsilon);
    }
  });
});

// node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
var name18 = "SparseMatrix";
var dependencies19 = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
  var {
    typed: typed3,
    equalScalar,
    Matrix: Matrix2
  } = _ref;
  function SparseMatrix(data, datatype) {
    if (!(this instanceof SparseMatrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix._values = source._values ? clone(source._values) : void 0;
      matrix._index = clone(source._index);
      matrix._ptr = clone(source._ptr);
      matrix._size = clone(source._size);
      matrix._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix, data, datatype) {
    matrix._values = [];
    matrix._index = [];
    matrix._ptr = [];
    matrix._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar;
    var zero3 = 0;
    if (isString(datatype)) {
      eq = typed3.find(equalScalar, [datatype, datatype]) || equalScalar;
      zero3 = typed3.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix._ptr.push(matrix._index.length);
        for (var i = 0; i < rows; i++) {
          var row = data[i];
          if (isArray(row)) {
            if (j === 0 && columns < row.length) {
              columns = row.length;
            }
            if (j < row.length) {
              var v = row[j];
              if (!eq(v, zero3)) {
                matrix._values.push(v);
                matrix._index.push(i);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row, zero3)) {
              matrix._values.push(row);
              matrix._index.push(i);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix._ptr.push(matrix._index.length);
    matrix._size = [rows, columns];
  }
  SparseMatrix.prototype = new Matrix2();
  SparseMatrix.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix(data, datatype);
  };
  Object.defineProperty(SparseMatrix, "name", {
    value: "SparseMatrix"
  });
  SparseMatrix.prototype.constructor = SparseMatrix;
  SparseMatrix.prototype.type = "SparseMatrix";
  SparseMatrix.prototype.isSparseMatrix = true;
  SparseMatrix.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf);
  };
  SparseMatrix.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix.prototype.create = function(data, datatype) {
    return new SparseMatrix(data, datatype);
  };
  SparseMatrix.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix.prototype.subset = function(index, replacement, defaultValue) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index);
      case 2:
      case 3:
        return _setsubset(this, index, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix.get(idx.min());
    }
    var size = idx.size();
    if (size.length !== matrix._size.length) {
      throw new DimensionError(size.length, matrix._size.length);
    }
    var i, ii, k2, kk;
    var min4 = idx.min();
    var max4 = idx.max();
    for (i = 0, ii = matrix._size.length; i < ii; i++) {
      validateIndex(min4[i], matrix._size[i]);
      validateIndex(max4[i], matrix._size[i]);
    }
    var mvalues = matrix._values;
    var mindex = matrix._index;
    var mptr = matrix._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i2, r) {
      pv[i2] = r[0];
      w[i2] = true;
    });
    var values2 = mvalues ? [] : void 0;
    var index = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index.length);
      for (k2 = mptr[j], kk = mptr[j + 1]; k2 < kk; k2++) {
        i = mindex[k2];
        if (w[i] === true) {
          index.push(pv[i]);
          if (values2) {
            values2.push(mvalues[k2]);
          }
        }
      }
    });
    ptr.push(index.length);
    return new SparseMatrix({
      values: values2,
      index,
      ptr,
      size,
      datatype: matrix._datatype
    });
  }
  function _setsubset(matrix, index, submatrix, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index.size();
    var isScalar = index.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix.set(index.min(), submatrix, defaultValue);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      if (iSize.length === 1) {
        var range2 = index.dimension(0);
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
        });
      } else {
        var firstDimensionRange = index.dimension(0);
        var secondDimensionRange = index.dimension(1);
        firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
          validateIndex(firstDataIndex);
          secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
            validateIndex(secondDataIndex);
            matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
          });
        });
      }
    }
    return matrix;
  }
  SparseMatrix.prototype.get = function(index) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i = index[0];
    var j = index[1];
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[1]);
    var k2 = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    if (k2 < this._ptr[j + 1] && this._index[k2] === i) {
      return this._values[k2];
    }
    return 0;
  };
  SparseMatrix.prototype.set = function(index, v, defaultValue) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i = index[0];
    var j = index[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar;
    var zero3 = 0;
    if (isString(this._datatype)) {
      eq = typed3.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
      zero3 = typed3.convert(0, this._datatype);
    }
    if (i > rows - 1 || j > columns - 1) {
      _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i, rows);
    validateIndex(j, columns);
    var k2 = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    if (k2 < this._ptr[j + 1] && this._index[k2] === i) {
      if (!eq(v, zero3)) {
        this._values[k2] = v;
      } else {
        _remove(k2, j, this._values, this._index, this._ptr);
      }
    } else {
      if (!eq(v, zero3)) {
        _insert(k2, i, j, v, this._values, this._index, this._ptr);
      }
    }
    return this;
  };
  function _getValueIndex(i, top2, bottom2, index) {
    if (bottom2 - top2 === 0) {
      return bottom2;
    }
    for (var r = top2; r < bottom2; r++) {
      if (index[r] === i) {
        return r;
      }
    }
    return top2;
  }
  function _remove(k2, j, values2, index, ptr) {
    values2.splice(k2, 1);
    index.splice(k2, 1);
    for (var x2 = j + 1; x2 < ptr.length; x2++) {
      ptr[x2]--;
    }
  }
  function _insert(k2, i, j, v, values2, index, ptr) {
    values2.splice(k2, 0, v);
    index.splice(k2, 0, i);
    for (var x2 = j + 1; x2 < ptr.length; x2++) {
      ptr[x2]++;
    }
  }
  SparseMatrix.prototype.resize = function(size, defaultValue, copy3) {
    if (!isCollection(size)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
      }
    });
    var m = copy3 ? this.clone() : this;
    return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
  };
  function _resize2(matrix, rows, columns, defaultValue) {
    var value = defaultValue || 0;
    var eq = equalScalar;
    var zero3 = 0;
    if (isString(matrix._datatype)) {
      eq = typed3.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
      zero3 = typed3.convert(0, matrix._datatype);
      value = typed3.convert(value, matrix._datatype);
    }
    var ins = !eq(value, zero3);
    var r = matrix._size[0];
    var c2 = matrix._size[1];
    var i, j, k2;
    if (columns > c2) {
      for (j = c2; j < columns; j++) {
        matrix._ptr[j] = matrix._values.length;
        if (ins) {
          for (i = 0; i < r; i++) {
            matrix._values.push(value);
            matrix._index.push(i);
          }
        }
      }
      matrix._ptr[columns] = matrix._values.length;
    } else if (columns < c2) {
      matrix._ptr.splice(columns + 1, c2 - columns);
      matrix._values.splice(matrix._ptr[columns], matrix._values.length);
      matrix._index.splice(matrix._ptr[columns], matrix._index.length);
    }
    c2 = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0; j < c2; j++) {
          matrix._ptr[j] = matrix._ptr[j] + n;
          k2 = matrix._ptr[j + 1] + n;
          var p = 0;
          for (i = r; i < rows; i++, p++) {
            matrix._values.splice(k2 + p, 0, value);
            matrix._index.splice(k2 + p, 0, i);
            n++;
          }
        }
        matrix._ptr[c2] = matrix._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0; j < c2; j++) {
        matrix._ptr[j] = matrix._ptr[j] - d;
        var k0 = matrix._ptr[j];
        var k1 = matrix._ptr[j + 1] - d;
        for (k2 = k0; k2 < k1; k2++) {
          i = matrix._index[k2];
          if (i > rows - 1) {
            matrix._values.splice(k2, 1);
            matrix._index.splice(k2, 1);
            d++;
          }
        }
      }
      matrix._ptr[j] = matrix._values.length;
    }
    matrix._size[0] = rows;
    matrix._size[1] = columns;
    return matrix;
  }
  SparseMatrix.prototype.reshape = function(sizes, copy3) {
    if (!isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy3 ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i = 0; i < m._ptr.length; i++) {
      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
        colIndex.push(i);
      }
    }
    var values2 = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0; _i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h = 0; h < values2.length; h++) {
      var _i3 = rowIndex[h];
      var _j = colIndex[h];
      var v = values2[h];
      var k2 = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k2, _i3, _j, v, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix.prototype.clone = function() {
    var m = new SparseMatrix({
      values: this._values ? clone(this._values) : void 0,
      index: clone(this._index),
      ptr: clone(this._ptr),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var args = maxArgumentCount(callback);
    var invoke = function invoke2(v, i, j) {
      if (args === 1)
        return callback(v);
      if (args === 2)
        return callback(v, [i, j]);
      return callback(v, [i, j], me);
    };
    return _map3(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map3(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values2 = [];
    var index = [];
    var ptr = [];
    var eq = equalScalar;
    var zero3 = 0;
    if (isString(matrix._datatype)) {
      eq = typed3.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
      zero3 = typed3.convert(0, matrix._datatype);
    }
    var invoke = function invoke2(v, x2, y2) {
      v = callback(v, x2, y2);
      if (!eq(v, zero3)) {
        values2.push(v);
        index.push(x2);
      }
    };
    for (var j = minColumn; j <= maxColumn; j++) {
      ptr.push(values2.length);
      var k0 = matrix._ptr[j];
      var k1 = matrix._ptr[j + 1];
      if (skipZeros) {
        for (var k2 = k0; k2 < k1; k2++) {
          var i = matrix._index[k2];
          if (i >= minRow && i <= maxRow) {
            invoke(matrix._values[k2], i - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0; _k < k1; _k++) {
          var _i4 = matrix._index[_k];
          _values[_i4] = matrix._values[_k];
        }
        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values2.length);
    return new SparseMatrix({
      values: values2,
      index,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k2 = k0; k2 < k1; k2++) {
          var i = this._index[k2];
          callback(this._values[k2], [i, j], me);
        }
      } else {
        var values2 = {};
        for (var _k2 = k0; _k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values2[_i6] = this._values[_k2];
        }
        for (var _i7 = 0; _i7 < rows; _i7++) {
          var value = _i7 in values2 ? values2[_i7] : 0;
          callback(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k2 = k0; k2 < k1; k2++) {
        var i = this._index[k2];
        yield {
          value: this._values[k2],
          index: [i, j]
        };
      }
    }
  };
  SparseMatrix.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values2, index, ptr, size, copy3) {
    var rows = size[0];
    var columns = size[1];
    var a2 = [];
    var i, j;
    for (i = 0; i < rows; i++) {
      a2[i] = [];
      for (j = 0; j < columns; j++) {
        a2[i][j] = 0;
      }
    }
    for (j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k2 = k0; k2 < k1; k2++) {
        i = index[k2];
        a2[i][j] = values2 ? copy3 ? clone(values2[k2]) : values2[k2] : 1;
      }
    }
    return a2;
  }
  SparseMatrix.prototype.format = function(options) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k2 = k0; k2 < k1; k2++) {
        var i = this._index[k2];
        str += "\n    (" + format3(i, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k2], options) : "X");
      }
    }
    return str;
  };
  SparseMatrix.prototype.toString = function() {
    return format3(this.toArray());
  };
  SparseMatrix.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix.prototype.diagonal = function(k2) {
    if (k2) {
      if (isBigNumber(k2)) {
        k2 = k2.toNumber();
      }
      if (!isNumber(k2) || !isInteger(k2)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k2 = 0;
    }
    var kSuper = k2 > 0 ? k2 : 0;
    var kSub = k2 < 0 ? -k2 : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values2 = [];
    var index = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper; j < columns && values2.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x2 = k0; x2 < k1; x2++) {
        var i = this._index[x2];
        if (i === j - kSuper + kSub) {
          values2.push(this._values[x2]);
          index[values2.length - 1] = i - kSub;
          break;
        }
      }
    }
    ptr.push(values2.length);
    return new SparseMatrix({
      values: values2,
      index,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix.fromJSON = function(json) {
    return new SparseMatrix(json);
  };
  SparseMatrix.diagonal = function(size, value, k2, defaultValue, datatype) {
    if (!isArray(size)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size = size.map(function(s2) {
      if (isBigNumber(s2)) {
        s2 = s2.toNumber();
      }
      if (!isNumber(s2) || !isInteger(s2) || s2 < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s2;
    });
    if (k2) {
      if (isBigNumber(k2)) {
        k2 = k2.toNumber();
      }
      if (!isNumber(k2) || !isInteger(k2)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k2 = 0;
    }
    var eq = equalScalar;
    var zero3 = 0;
    if (isString(datatype)) {
      eq = typed3.find(equalScalar, [datatype, datatype]) || equalScalar;
      zero3 = typed3.convert(0, datatype);
    }
    var kSuper = k2 > 0 ? k2 : 0;
    var kSub = k2 < 0 ? -k2 : 0;
    var rows = size[0];
    var columns = size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    var values2 = [];
    var index = [];
    var ptr = [];
    for (var j = 0; j < columns; j++) {
      ptr.push(values2.length);
      var i = j - kSuper;
      if (i >= 0 && i < n) {
        var v = _value(i);
        if (!eq(v, zero3)) {
          index.push(i + kSub);
          values2.push(v);
        }
      }
    }
    ptr.push(values2.length);
    return new SparseMatrix({
      values: values2,
      index,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix.prototype.swapRows = function(i, j) {
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix._forEachRow = function(j, values2, index, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k2 = k0; k2 < k1; k2++) {
      callback(index[k2], values2[k2]);
    }
  };
  SparseMatrix._swapRows = function(x2, y2, columns, values2, index, ptr) {
    for (var j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx2 = _getValueIndex(x2, k0, k1, index);
      var ky2 = _getValueIndex(y2, k0, k1, index);
      if (kx2 < k1 && ky2 < k1 && index[kx2] === x2 && index[ky2] === y2) {
        if (values2) {
          var v = values2[kx2];
          values2[kx2] = values2[ky2];
          values2[ky2] = v;
        }
        continue;
      }
      if (kx2 < k1 && index[kx2] === x2 && (ky2 >= k1 || index[ky2] !== y2)) {
        var vx = values2 ? values2[kx2] : void 0;
        index.splice(ky2, 0, y2);
        if (values2) {
          values2.splice(ky2, 0, vx);
        }
        index.splice(ky2 <= kx2 ? kx2 + 1 : kx2, 1);
        if (values2) {
          values2.splice(ky2 <= kx2 ? kx2 + 1 : kx2, 1);
        }
        continue;
      }
      if (ky2 < k1 && index[ky2] === y2 && (kx2 >= k1 || index[kx2] !== x2)) {
        var vy = values2 ? values2[ky2] : void 0;
        index.splice(kx2, 0, x2);
        if (values2) {
          values2.splice(kx2, 0, vy);
        }
        index.splice(kx2 <= ky2 ? ky2 + 1 : ky2, 1);
        if (values2) {
          values2.splice(kx2 <= ky2 ? ky2 + 1 : ky2, 1);
        }
      }
    }
  };
  return SparseMatrix;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/number.js
var name19 = "number";
var dependencies20 = ["typed"];
function getNonDecimalNumberParts(input) {
  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (nonDecimalWithRadixMatch) {
    var radix = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[nonDecimalWithRadixMatch[1]];
    var integerPart = nonDecimalWithRadixMatch[2];
    var fractionalPart = nonDecimalWithRadixMatch[3];
    return {
      input,
      radix,
      integerPart,
      fractionalPart
    };
  } else {
    return null;
  }
}
function makeNumberFromNonDecimalParts(parts) {
  var n = parseInt(parts.integerPart, parts.radix);
  var f = 0;
  for (var i = 0; i < parts.fractionalPart.length; i++) {
    var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
    f += digitValue / Math.pow(parts.radix, i + 1);
  }
  var result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is no valid number');
  }
  return result;
}
var createNumber = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var number5 = typed3("number", {
    "": function _() {
      return 0;
    },
    number: function number6(x2) {
      return x2;
    },
    string: function string(x2) {
      if (x2 === "NaN")
        return NaN;
      var nonDecimalNumberParts = getNonDecimalNumberParts(x2);
      if (nonDecimalNumberParts) {
        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
      }
      var size = 0;
      var wordSizeSuffixMatch = x2.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        size = Number(wordSizeSuffixMatch[2]);
        x2 = wordSizeSuffixMatch[1];
      }
      var num = Number(x2);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x2 + '" is no valid number');
      }
      if (wordSizeSuffixMatch) {
        if (num > 2 ** size - 1) {
          throw new SyntaxError('String "'.concat(x2, '" is out of range'));
        }
        if (num >= 2 ** (size - 1)) {
          num = num - 2 ** size;
        }
      }
      return num;
    },
    BigNumber: function BigNumber2(x2) {
      return x2.toNumber();
    },
    Fraction: function Fraction3(x2) {
      return x2.valueOf();
    },
    Unit: typed3.referToSelf((self2) => (x2) => {
      var clone4 = x2.clone();
      clone4.value = self2(x2.value);
      return clone4;
    }),
    null: function _null(x2) {
      return 0;
    },
    "Unit, string | Unit": function UnitStringUnit(unit2, valuelessUnit) {
      return unit2.toNumber(valuelessUnit);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
  number5.fromJSON = function(json) {
    return parseFloat(json.value);
  };
  return number5;
});

// node_modules/mathjs/lib/esm/type/string.js
var name20 = "string";
var dependencies21 = ["typed"];
var createString = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name20, {
    "": function _() {
      return "";
    },
    number: format,
    null: function _null(x2) {
      return "null";
    },
    boolean: function boolean(x2) {
      return x2 + "";
    },
    string: function string(x2) {
      return x2;
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2)),
    any: function any(x2) {
      return String(x2);
    }
  });
});

// node_modules/mathjs/lib/esm/type/boolean.js
var name21 = "boolean";
var dependencies22 = ["typed"];
var createBoolean = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name21, {
    "": function _() {
      return false;
    },
    boolean: function boolean(x2) {
      return x2;
    },
    number: function number5(x2) {
      return !!x2;
    },
    null: function _null(x2) {
      return false;
    },
    BigNumber: function BigNumber2(x2) {
      return !x2.isZero();
    },
    string: function string(x2) {
      var lcase = x2.toLowerCase();
      if (lcase === "true") {
        return true;
      } else if (lcase === "false") {
        return false;
      }
      var num = Number(x2);
      if (x2 !== "" && !isNaN(num)) {
        return !!num;
      }
      throw new Error('Cannot convert "' + x2 + '" to a boolean');
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
var name22 = "bignumber";
var dependencies23 = ["typed", "BigNumber"];
var createBignumber = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
  var {
    typed: typed3,
    BigNumber: BigNumber2
  } = _ref;
  return typed3("bignumber", {
    "": function _() {
      return new BigNumber2(0);
    },
    number: function number5(x2) {
      return new BigNumber2(x2 + "");
    },
    string: function string(x2) {
      var wordSizeSuffixMatch = x2.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size = wordSizeSuffixMatch[2];
        var n = BigNumber2(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber2(2).pow(Number(size));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError('String "'.concat(x2, '" is out of range'));
        }
        var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber2(x2);
    },
    BigNumber: function BigNumber3(x2) {
      return x2;
    },
    Unit: typed3.referToSelf((self2) => (x2) => {
      var clone4 = x2.clone();
      clone4.value = self2(x2.value);
      return clone4;
    }),
    Fraction: function Fraction3(x2) {
      return new BigNumber2(x2.n).div(x2.d).times(x2.s);
    },
    null: function _null(x2) {
      return new BigNumber2(0);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/type/complex/function/complex.js
var name23 = "complex";
var dependencies24 = ["typed", "Complex"];
var createComplex = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
  var {
    typed: typed3,
    Complex: Complex3
  } = _ref;
  return typed3("complex", {
    "": function _() {
      return Complex3.ZERO;
    },
    number: function number5(x2) {
      return new Complex3(x2, 0);
    },
    "number, number": function numberNumber(re2, im) {
      return new Complex3(re2, im);
    },
    // TODO: this signature should be redundant
    "BigNumber, BigNumber": function BigNumberBigNumber(re2, im) {
      return new Complex3(re2.toNumber(), im.toNumber());
    },
    Fraction: function Fraction3(x2) {
      return new Complex3(x2.valueOf(), 0);
    },
    Complex: function Complex4(x2) {
      return x2.clone();
    },
    string: function string(x2) {
      return Complex3(x2);
    },
    null: function _null(x2) {
      return Complex3(0);
    },
    Object: function Object2(x2) {
      if ("re" in x2 && "im" in x2) {
        return new Complex3(x2.re, x2.im);
      }
      if ("r" in x2 && "phi" in x2 || "abs" in x2 && "arg" in x2) {
        return new Complex3(x2);
      }
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
var name24 = "fraction";
var dependencies25 = ["typed", "Fraction"];
var createFraction = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
  var {
    typed: typed3,
    Fraction: Fraction3
  } = _ref;
  return typed3("fraction", {
    number: function number5(x2) {
      if (!isFinite(x2) || isNaN(x2)) {
        throw new Error(x2 + " cannot be represented as a fraction");
      }
      return new Fraction3(x2);
    },
    string: function string(x2) {
      return new Fraction3(x2);
    },
    "number, number": function numberNumber(numerator, denominator) {
      return new Fraction3(numerator, denominator);
    },
    null: function _null(x2) {
      return new Fraction3(0);
    },
    BigNumber: function BigNumber2(x2) {
      return new Fraction3(x2.toString());
    },
    Fraction: function Fraction4(x2) {
      return x2;
    },
    Unit: typed3.referToSelf((self2) => (x2) => {
      var clone4 = x2.clone();
      clone4.value = self2(x2.value);
      return clone4;
    }),
    Object: function Object2(x2) {
      return new Fraction3(x2);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
var name25 = "matrix";
var dependencies26 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
  var {
    typed: typed3,
    Matrix: Matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix
  } = _ref;
  return typed3(name25, {
    "": function _() {
      return _create([]);
    },
    string: function string(format6) {
      return _create([], format6);
    },
    "string, string": function stringString(format6, datatype) {
      return _create([], format6, datatype);
    },
    Array: function Array2(data) {
      return _create(data);
    },
    Matrix: function Matrix3(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format6, datatype) {
    if (format6 === "dense" || format6 === "default" || format6 === void 0) {
      return new DenseMatrix2(data, datatype);
    }
    if (format6 === "sparse") {
      return new SparseMatrix(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format6) + ".");
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
var name26 = "matrixFromFunction";
var dependencies27 = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
  var {
    typed: typed3,
    matrix,
    isZero
  } = _ref;
  return typed3(name26, {
    "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size, fn, format6, datatype) {
      return _create(size, fn, format6, datatype);
    },
    "Array | Matrix, function, string": function ArrayMatrixFunctionString(size, fn, format6) {
      return _create(size, fn, format6);
    },
    "Matrix, function": function MatrixFunction(size, fn) {
      return _create(size, fn, "dense");
    },
    "Array, function": function ArrayFunction(size, fn) {
      return _create(size, fn, "dense").toArray();
    },
    "Array | Matrix, string, function": function ArrayMatrixStringFunction(size, format6, fn) {
      return _create(size, fn, format6);
    },
    "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size, format6, datatype, fn) {
      return _create(size, fn, format6, datatype);
    }
  });
  function _create(size, fn, format6, datatype) {
    var m;
    if (datatype !== void 0) {
      m = matrix(format6, datatype);
    } else {
      m = matrix(format6);
    }
    m.resize(size);
    m.forEach(function(_, index) {
      var val = fn(index);
      if (isZero(val))
        return;
      m.set(index, val);
    });
    return m;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
var name27 = "matrixFromRows";
var dependencies28 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
  var {
    typed: typed3,
    matrix,
    flatten: flatten2,
    size
  } = _ref;
  return typed3(name27, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one row is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var row of arr) {
      var rowLength = checkVectorTypeAndReturnLength(row);
      if (rowLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0));
      }
      result.push(flatten2(row));
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s2 = size(vec);
    if (s2.length === 1) {
      return s2[0];
    } else if (s2.length === 2) {
      if (s2[0] === 1) {
        return s2[1];
      } else if (s2[1] === 1) {
        return s2[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
var name28 = "matrixFromColumns";
var dependencies29 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
  var {
    typed: typed3,
    matrix,
    flatten: flatten2,
    size
  } = _ref;
  return typed3(name28, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one column is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var i = 0; i < N; i++) {
      result[i] = [];
    }
    for (var col of arr) {
      var colLength = checkVectorTypeAndReturnLength(col);
      if (colLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
      }
      var f = flatten2(col);
      for (var _i = 0; _i < N; _i++) {
        result[_i].push(f[_i]);
      }
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s2 = size(vec);
    if (s2.length === 1) {
      return s2[0];
    } else if (s2.length === 2) {
      if (s2[0] === 1) {
        return s2[1];
      } else if (s2[1] === 1) {
        return s2[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});

// node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
var name29 = "splitUnit";
var dependencies30 = ["typed"];
var createSplitUnit = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name29, {
    "Unit, Array": function UnitArray(unit2, parts) {
      return unit2.splitUnit(parts);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
var name30 = "unaryMinus";
var dependencies31 = ["typed"];
var createUnaryMinus = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name30, {
    number: unaryMinusNumber,
    "Complex | BigNumber | Fraction": (x2) => x2.neg(),
    Unit: typed3.referToSelf((self2) => (x2) => {
      var res = x2.clone();
      res.value = typed3.find(self2, res.valueType())(x2.value);
      return res;
    }),
    // deep map collection, skip zeros since unaryMinus(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2, true))
    // TODO: add support for string
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
var name31 = "unaryPlus";
var dependencies32 = ["typed", "config", "BigNumber"];
var createUnaryPlus = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    BigNumber: BigNumber2
  } = _ref;
  return typed3(name31, {
    number: unaryPlusNumber,
    Complex: function Complex3(x2) {
      return x2;
    },
    BigNumber: function BigNumber3(x2) {
      return x2;
    },
    Fraction: function Fraction3(x2) {
      return x2;
    },
    Unit: function Unit(x2) {
      return x2.clone();
    },
    // deep map collection, skip zeros since unaryPlus(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2, true)),
    "boolean | string": function booleanString(x2) {
      return config4.number === "BigNumber" ? new BigNumber2(+x2) : +x2;
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/abs.js
var name32 = "abs";
var dependencies33 = ["typed"];
var createAbs = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name32, {
    number: absNumber,
    "Complex | BigNumber | Fraction | Unit": (x2) => x2.abs(),
    // deep map collection, skip zeros since abs(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2, true))
  });
});

// node_modules/mathjs/lib/esm/function/matrix/apply.js
var name33 = "apply";
var dependencies34 = ["typed", "isInteger"];
var createApply = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
  var {
    typed: typed3,
    isInteger: isInteger2
  } = _ref;
  return typed3(name33, {
    "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
      if (!isInteger2(dim)) {
        throw new TypeError("Integer number expected for dimension");
      }
      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
      if (dim < 0 || dim >= size.length) {
        throw new IndexError(dim, size.length);
      }
      if (isMatrix(mat)) {
        return mat.create(_apply(mat.valueOf(), dim, callback));
      } else {
        return _apply(mat, dim, callback);
      }
    }
  });
});
function _apply(mat, dim, callback) {
  var i, ret, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      return callback(mat);
    } else {
      tran = _switch2(mat);
      ret = [];
      for (i = 0; i < tran.length; i++) {
        ret[i] = _apply(tran[i], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i = 0; i < mat.length; i++) {
      ret[i] = _apply(mat[i], dim - 1, callback);
    }
    return ret;
  }
}
function _switch2(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i = 0; i < I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

// node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
var name34 = "addScalar";
var dependencies35 = ["typed"];
var createAddScalar = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name34, {
    "number, number": addNumber,
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return x2.add(y2);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.plus(y2);
    },
    "Fraction, Fraction": function FractionFraction(x2, y2) {
      return x2.add(y2);
    },
    "Unit, Unit": typed3.referToSelf((self2) => (x2, y2) => {
      if (x2.value === null || x2.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y2.value === null || y2.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x2.equalBase(y2))
        throw new Error("Units do not match");
      var res = x2.clone();
      res.value = typed3.find(self2, [res.valueType(), y2.valueType()])(res.value, y2.value);
      res.fixPrefix = false;
      return res;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/subtractScalar.js
var name35 = "subtractScalar";
var dependencies36 = ["typed"];
var createSubtractScalar = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name35, {
    "number, number": subtractNumber,
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return x2.sub(y2);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.minus(y2);
    },
    "Fraction, Fraction": function FractionFraction(x2, y2) {
      return x2.sub(y2);
    },
    "Unit, Unit": typed3.referToSelf((self2) => (x2, y2) => {
      if (x2.value === null || x2.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y2.value === null || y2.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x2.equalBase(y2))
        throw new Error("Units do not match");
      var res = x2.clone();
      res.value = typed3.find(self2, [res.valueType(), y2.valueType()])(res.value, y2.value);
      res.fixPrefix = false;
      return res;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
var name36 = "cbrt";
var dependencies37 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
var createCbrt = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
  var {
    config: config4,
    typed: typed3,
    isNegative,
    unaryMinus,
    matrix,
    Complex: Complex3,
    BigNumber: BigNumber2,
    Fraction: Fraction3
  } = _ref;
  return typed3(name36, {
    number: cbrtNumber,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex
    Complex: _cbrtComplex,
    "Complex, boolean": _cbrtComplex,
    BigNumber: function BigNumber3(x2) {
      return x2.cbrt();
    },
    Unit: _cbrtUnit
  });
  function _cbrtComplex(x2, allRoots) {
    var arg3 = x2.arg() / 3;
    var abs3 = x2.abs();
    var principal = new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3).exp());
    if (allRoots) {
      var all2 = [principal, new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3 + Math.PI * 2 / 3).exp()), new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3 - Math.PI * 2 / 3).exp())];
      return config4.matrix === "Array" ? all2 : matrix(all2);
    } else {
      return principal;
    }
  }
  function _cbrtUnit(x2) {
    if (x2.value && isComplex(x2.value)) {
      var result = x2.clone();
      result.value = 1;
      result = result.pow(1 / 3);
      result.value = _cbrtComplex(x2.value);
      return result;
    } else {
      var negate = isNegative(x2.value);
      if (negate) {
        x2.value = unaryMinus(x2.value);
      }
      var third;
      if (isBigNumber(x2.value)) {
        third = new BigNumber2(1).div(3);
      } else if (isFraction(x2.value)) {
        third = new Fraction3(1, 3);
      } else {
        third = 1 / 3;
      }
      var _result = x2.pow(third);
      if (negate) {
        _result.value = unaryMinus(_result.value);
      }
      return _result;
    }
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js
var name37 = "matAlgo11xS0s";
var dependencies38 = ["typed", "equalScalar"];
var createMatAlgo11xS0s = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref;
  return function matAlgo11xS0s(s2, b, callback, inverse) {
    var avalues = s2._values;
    var aindex = s2._index;
    var aptr = s2._ptr;
    var asize = s2._size;
    var adt = s2._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
      b = typed3.convert(b, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k2 = k0; k2 < k1; k2++) {
        var i = aindex[k2];
        var v = inverse ? cf(b, avalues[k2]) : cf(avalues[k2], b);
        if (!eq(v, zero3)) {
          cindex.push(i);
          cvalues.push(v);
        }
      }
    }
    cptr[columns] = cindex.length;
    return s2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js
var name38 = "matAlgo12xSfs";
var dependencies39 = ["typed", "DenseMatrix"];
var createMatAlgo12xSfs = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
  var {
    typed: typed3,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo12xSfs(s2, b, callback, inverse) {
    var avalues = s2._values;
    var aindex = s2._index;
    var aptr = s2._ptr;
    var asize = s2._size;
    var adt = s2._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed3.convert(b, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x2 = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k2 = k0; k2 < k1; k2++) {
        var r = aindex[k2];
        x2[r] = avalues[k2];
        w[r] = mark;
      }
      for (var i = 0; i < rows; i++) {
        if (j === 0) {
          cdata[i] = [];
        }
        if (w[i] === mark) {
          cdata[i][j] = inverse ? cf(b, x2[i]) : cf(x2[i], b);
        } else {
          cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js
var name39 = "matAlgo14xDs";
var dependencies40 = ["typed"];
var createMatAlgo14xDs = /* @__PURE__ */ factory(name39, dependencies40, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return function matAlgo14xDs(a2, b, callback, inverse) {
    var adata = a2._data;
    var asize = a2._size;
    var adt = a2._datatype;
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed3.convert(b, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
    return a2.createDenseMatrix({
      data: cdata,
      size: clone(asize),
      datatype: dt
    });
  };
  function _iterate(f, level, s2, n, av, bv, inverse) {
    var cv = [];
    if (level === s2.length - 1) {
      for (var i = 0; i < n; i++) {
        cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s2, s2[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
var name40 = "ceil";
var dependencies41 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createCeilNumber = /* @__PURE__ */ factory(name40, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed3,
    config: config4,
    round: round2
  } = _ref;
  return typed3(name40, {
    number: function number5(x2) {
      if (nearlyEqual(x2, round2(x2), config4.epsilon)) {
        return round2(x2);
      } else {
        return Math.ceil(x2);
      }
    },
    "number, number": function numberNumber(x2, n) {
      if (nearlyEqual(x2, round2(x2, n), config4.epsilon)) {
        return round2(x2, n);
      } else {
        var [number5, exponent] = "".concat(x2, "e").split("e");
        var result = Math.ceil(Number("".concat(number5, "e").concat(Number(exponent) + n)));
        [number5, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number5, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createCeil = /* @__PURE__ */ factory(name40, dependencies41, (_ref2) => {
  var {
    typed: typed3,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var ceilNumber = createCeilNumber({
    typed: typed3,
    config: config4,
    round: round2
  });
  return typed3("ceil", {
    number: ceilNumber.signatures.number,
    "number,number": ceilNumber.signatures["number,number"],
    Complex: function Complex3(x2) {
      return x2.ceil();
    },
    "Complex, number": function ComplexNumber(x2, n) {
      return x2.ceil(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x2, n) {
      return x2.ceil(n.toNumber());
    },
    BigNumber: function BigNumber2(x2) {
      if (nearlyEqual2(x2, round2(x2), config4.epsilon)) {
        return round2(x2);
      } else {
        return x2.ceil();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, n) {
      if (nearlyEqual2(x2, round2(x2, n), config4.epsilon)) {
        return round2(x2, n);
      } else {
        return x2.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_CEIL);
      }
    },
    Fraction: function Fraction3(x2) {
      return x2.ceil();
    },
    "Fraction, number": function FractionNumber(x2, n) {
      return x2.ceil(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x2, n) {
      return x2.ceil(n.toNumber());
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => {
      return deepMap(x2, self2, true);
    }),
    "Array, number | BigNumber": typed3.referToSelf((self2) => (x2, n) => {
      return deepMap(x2, (i) => self2(i, n), true);
    }),
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo11xS0s(x2, y2, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo14xDs(x2, y2, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo14xDs(matrix(y2), x2, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0))
        return zeros2(y2.size(), y2.storage());
      if (y2.storage() === "dense") {
        return matAlgo14xDs(y2, x2, self2, true);
      }
      return matAlgo12xSfs(y2, x2, self2, true);
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/cube.js
var name41 = "cube";
var dependencies42 = ["typed"];
var createCube = /* @__PURE__ */ factory(name41, dependencies42, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name41, {
    number: cubeNumber,
    Complex: function Complex3(x2) {
      return x2.mul(x2).mul(x2);
    },
    BigNumber: function BigNumber2(x2) {
      return x2.times(x2).times(x2);
    },
    Fraction: function Fraction3(x2) {
      return x2.pow(3);
    },
    Unit: function Unit(x2) {
      return x2.pow(3);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/exp.js
var name42 = "exp";
var dependencies43 = ["typed"];
var createExp = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name42, {
    number: expNumber,
    Complex: function Complex3(x2) {
      return x2.exp();
    },
    BigNumber: function BigNumber2(x2) {
      return x2.exp();
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
var name43 = "expm1";
var dependencies44 = ["typed", "Complex"];
var createExpm1 = /* @__PURE__ */ factory(name43, dependencies44, (_ref) => {
  var {
    typed: typed3,
    Complex: _Complex
  } = _ref;
  return typed3(name43, {
    number: expm1Number,
    Complex: function Complex3(x2) {
      var r = Math.exp(x2.re);
      return new _Complex(r * Math.cos(x2.im) - 1, r * Math.sin(x2.im));
    },
    BigNumber: function BigNumber2(x2) {
      return x2.exp().minus(1);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/fix.js
var name44 = "fix";
var dependencies45 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
var createFixNumber = /* @__PURE__ */ factory(name44, ["typed", "ceil", "floor"], (_ref) => {
  var {
    typed: typed3,
    ceil: ceil2,
    floor: floor2
  } = _ref;
  return typed3(name44, {
    number: function number5(x2) {
      return x2 > 0 ? floor2(x2) : ceil2(x2);
    },
    "number, number": function numberNumber(x2, n) {
      return x2 > 0 ? floor2(x2, n) : ceil2(x2, n);
    }
  });
});
var createFix = /* @__PURE__ */ factory(name44, dependencies45, (_ref2) => {
  var {
    typed: typed3,
    Complex: _Complex,
    matrix,
    ceil: ceil2,
    floor: floor2,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var fixNumber = createFixNumber({
    typed: typed3,
    ceil: ceil2,
    floor: floor2
  });
  return typed3("fix", {
    number: fixNumber.signatures.number,
    "number, number | BigNumber": fixNumber.signatures["number,number"],
    Complex: function Complex3(x2) {
      return new _Complex(x2.re > 0 ? Math.floor(x2.re) : Math.ceil(x2.re), x2.im > 0 ? Math.floor(x2.im) : Math.ceil(x2.im));
    },
    "Complex, number": function ComplexNumber(x2, n) {
      return new _Complex(x2.re > 0 ? floor2(x2.re, n) : ceil2(x2.re, n), x2.im > 0 ? floor2(x2.im, n) : ceil2(x2.im, n));
    },
    "Complex, BigNumber": function ComplexBigNumber(x2, bn) {
      var n = bn.toNumber();
      return new _Complex(x2.re > 0 ? floor2(x2.re, n) : ceil2(x2.re, n), x2.im > 0 ? floor2(x2.im, n) : ceil2(x2.im, n));
    },
    BigNumber: function BigNumber2(x2) {
      return x2.isNegative() ? ceil2(x2) : floor2(x2);
    },
    "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x2, n) {
      return x2.isNegative() ? ceil2(x2, n) : floor2(x2, n);
    },
    Fraction: function Fraction3(x2) {
      return x2.s < 0 ? x2.ceil() : x2.floor();
    },
    "Fraction, number | BigNumber": function FractionNumberBigNumber(x2, n) {
      return x2.s < 0 ? ceil2(x2, n) : floor2(x2, n);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => {
      return deepMap(x2, self2, true);
    }),
    "Array | Matrix, number | BigNumber": typed3.referToSelf((self2) => (x2, n) => {
      return deepMap(x2, (i) => self2(i, n), true);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo14xDs(matrix(y2), x2, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0))
        return zeros2(y2.size(), y2.storage());
      if (y2.storage() === "dense") {
        return matAlgo14xDs(y2, x2, self2, true);
      }
      return matAlgo12xSfs(y2, x2, self2, true);
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/floor.js
var name45 = "floor";
var dependencies46 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createFloorNumber = /* @__PURE__ */ factory(name45, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed3,
    config: config4,
    round: round2
  } = _ref;
  return typed3(name45, {
    number: function number5(x2) {
      if (nearlyEqual(x2, round2(x2), config4.epsilon)) {
        return round2(x2);
      } else {
        return Math.floor(x2);
      }
    },
    "number, number": function numberNumber(x2, n) {
      if (nearlyEqual(x2, round2(x2, n), config4.epsilon)) {
        return round2(x2, n);
      } else {
        var [number5, exponent] = "".concat(x2, "e").split("e");
        var result = Math.floor(Number("".concat(number5, "e").concat(Number(exponent) + n)));
        [number5, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number5, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createFloor = /* @__PURE__ */ factory(name45, dependencies46, (_ref2) => {
  var {
    typed: typed3,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var floorNumber = createFloorNumber({
    typed: typed3,
    config: config4,
    round: round2
  });
  return typed3("floor", {
    number: floorNumber.signatures.number,
    "number,number": floorNumber.signatures["number,number"],
    Complex: function Complex3(x2) {
      return x2.floor();
    },
    "Complex, number": function ComplexNumber(x2, n) {
      return x2.floor(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x2, n) {
      return x2.floor(n.toNumber());
    },
    BigNumber: function BigNumber2(x2) {
      if (nearlyEqual2(x2, round2(x2), config4.epsilon)) {
        return round2(x2);
      } else {
        return x2.floor();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, n) {
      if (nearlyEqual2(x2, round2(x2, n), config4.epsilon)) {
        return round2(x2, n);
      } else {
        return x2.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_FLOOR);
      }
    },
    Fraction: function Fraction3(x2) {
      return x2.floor();
    },
    "Fraction, number": function FractionNumber(x2, n) {
      return x2.floor(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x2, n) {
      return x2.floor(n.toNumber());
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => {
      return deepMap(x2, self2, true);
    }),
    "Array, number | BigNumber": typed3.referToSelf((self2) => (x2, n) => {
      return deepMap(x2, (i) => self2(i, n), true);
    }),
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo11xS0s(x2, y2, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo14xDs(x2, y2, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo14xDs(matrix(y2), x2, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0))
        return zeros2(y2.size(), y2.storage());
      if (y2.storage() === "dense") {
        return matAlgo14xDs(y2, x2, self2, true);
      }
      return matAlgo12xSfs(y2, x2, self2, true);
    })
  });
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
var name46 = "matAlgo02xDS0";
var dependencies47 = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = /* @__PURE__ */ factory(name46, dependencies47, (_ref) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref;
  return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k2 = k0; k2 < k1; k2++) {
        var i = bindex[k2];
        var cij = inverse ? cf(bvalues[k2], adata[i][j]) : cf(adata[i][j], bvalues[k2]);
        if (!eq(cij, zero3)) {
          cindex.push(i);
          cvalues.push(cij);
        }
      }
    }
    cptr[columns] = cindex.length;
    return sparseMatrix.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js
var name47 = "matAlgo03xDSf";
var dependencies48 = ["typed"];
var createMatAlgo03xDSf = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      zero3 = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = [];
    for (var z = 0; z < rows; z++) {
      cdata[z] = [];
    }
    var x2 = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k2 = k0; k2 < k1; k2++) {
        var i = bindex[k2];
        x2[i] = inverse ? cf(bvalues[k2], adata[i][j]) : cf(adata[i][j], bvalues[k2]);
        w[i] = mark;
      }
      for (var y2 = 0; y2 < rows; y2++) {
        if (w[y2] === mark) {
          cdata[y2][j] = x2[y2];
        } else {
          cdata[y2][j] = inverse ? cf(zero3, adata[y2][j]) : cf(adata[y2][j], zero3);
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js
var name48 = "matAlgo05xSfSf";
var dependencies49 = ["typed", "equalScalar"];
var createMatAlgo05xSfSf = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref;
  return function matAlgo05xSfSf(a2, b, callback) {
    var avalues = a2._values;
    var aindex = a2._index;
    var aptr = a2._ptr;
    var asize = a2._size;
    var adt = a2._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = cvalues ? [] : void 0;
    var xb = cvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i, j, k2, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k2 = aptr[j], k1 = aptr[j + 1]; k2 < k1; k2++) {
        i = aindex[k2];
        cindex.push(i);
        wa[i] = mark;
        if (xa) {
          xa[i] = avalues[k2];
        }
      }
      for (k2 = bptr[j], k1 = bptr[j + 1]; k2 < k1; k2++) {
        i = bindex[k2];
        if (wa[i] !== mark) {
          cindex.push(i);
        }
        wb[i] = mark;
        if (xb) {
          xb[i] = bvalues[k2];
        }
      }
      if (cvalues) {
        k2 = cptr[j];
        while (k2 < cindex.length) {
          i = cindex[k2];
          var wai = wa[i];
          var wbi = wb[i];
          if (wai === mark || wbi === mark) {
            var va = wai === mark ? xa[i] : zero3;
            var vb = wbi === mark ? xb[i] : zero3;
            var vc = cf(va, vb);
            if (!eq(vc, zero3)) {
              cvalues.push(vc);
              k2++;
            } else {
              cindex.splice(k2, 1);
            }
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js
var name49 = "matAlgo13xDD";
var dependencies50 = ["typed"];
var createMatAlgo13xDD = /* @__PURE__ */ factory(name49, dependencies50, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return function matAlgo13xDD(a2, b, callback) {
    var adata = a2._data;
    var asize = a2._size;
    var adt = a2._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var csize = [];
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    for (var s2 = 0; s2 < asize.length; s2++) {
      if (asize[s2] !== bsize[s2]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      csize[s2] = asize[s2];
    }
    var dt;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    return a2.createDenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  function _iterate(f, level, s2, n, av, bv) {
    var cv = [];
    if (level === s2.length - 1) {
      for (var i = 0; i < n; i++) {
        cv[i] = f(av[i], bv[i]);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s2, s2[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js
var name50 = "broadcast";
var dependancies = ["concat"];
var createBroadcast = /* @__PURE__ */ factory(name50, dependancies, (_ref) => {
  var {
    concat: concat2
  } = _ref;
  return function(A2, B2) {
    var N = Math.max(A2._size.length, B2._size.length);
    if (A2._size.length === B2._size.length) {
      if (A2._size.every((dim2, i) => dim2 === B2._size[i])) {
        return [A2, B2];
      }
    }
    var sizeA = _padLeft(A2._size, N, 0);
    var sizeB = _padLeft(B2._size, N, 0);
    var sizeMax = [];
    for (var dim = 0; dim < N; dim++) {
      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);
    }
    checkBroadcastingRules(sizeA, sizeMax);
    checkBroadcastingRules(sizeB, sizeMax);
    var AA = A2.clone();
    var BB = B2.clone();
    if (AA._size.length < N) {
      AA.reshape(_padLeft(AA._size, N, 1));
    } else if (BB._size.length < N) {
      BB.reshape(_padLeft(BB._size, N, 1));
    }
    for (var _dim = 0; _dim < N; _dim++) {
      if (AA._size[_dim] < sizeMax[_dim]) {
        AA = _stretch(AA, sizeMax[_dim], _dim);
      }
      if (BB._size[_dim] < sizeMax[_dim]) {
        BB = _stretch(BB, sizeMax[_dim], _dim);
      }
    }
    return [AA, BB];
  };
  function _padLeft(shape, N, filler) {
    return [...Array(N - shape.length).fill(filler), ...shape];
  }
  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {
    return concat2(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js
var name51 = "matrixAlgorithmSuite";
var dependencies51 = ["typed", "matrix", "concat"];
var createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name51, dependencies51, (_ref) => {
  var {
    typed: typed3,
    matrix,
    concat: concat2
  } = _ref;
  var matAlgo13xDD = createMatAlgo13xDD({
    typed: typed3
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var broadcast = createBroadcast({
    concat: concat2
  });
  return function matrixAlgorithmSuite(options) {
    var elop = options.elop;
    var SD = options.SD || options.DS;
    var matrixSignatures;
    if (elop) {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": (x2, y2) => matAlgo13xDD(...broadcast(x2, y2), elop),
        "Array, Array": (x2, y2) => matAlgo13xDD(...broadcast(matrix(x2), matrix(y2)), elop).valueOf(),
        "Array, DenseMatrix": (x2, y2) => matAlgo13xDD(...broadcast(matrix(x2), y2), elop),
        "DenseMatrix, Array": (x2, y2) => matAlgo13xDD(...broadcast(x2, matrix(y2)), elop)
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = (x2, y2) => options.SS(...broadcast(x2, y2), elop, false);
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = (x2, y2) => options.DS(...broadcast(x2, y2), elop, false);
        matrixSignatures["Array, SparseMatrix"] = (x2, y2) => options.DS(...broadcast(matrix(x2), y2), elop, false);
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = (x2, y2) => SD(...broadcast(y2, x2), elop, true);
        matrixSignatures["SparseMatrix, Array"] = (x2, y2) => SD(...broadcast(matrix(y2), x2), elop, true);
      }
    } else {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
          return matAlgo13xDD(...broadcast(x2, y2), self2);
        }),
        "Array, Array": typed3.referToSelf((self2) => (x2, y2) => {
          return matAlgo13xDD(...broadcast(matrix(x2), matrix(y2)), self2).valueOf();
        }),
        "Array, DenseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
          return matAlgo13xDD(...broadcast(matrix(x2), y2), self2);
        }),
        "DenseMatrix, Array": typed3.referToSelf((self2) => (x2, y2) => {
          return matAlgo13xDD(...broadcast(x2, matrix(y2)), self2);
        })
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = typed3.referToSelf((self2) => (x2, y2) => {
          return options.SS(...broadcast(x2, y2), self2, false);
        });
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = typed3.referToSelf((self2) => (x2, y2) => {
          return options.DS(...broadcast(x2, y2), self2, false);
        });
        matrixSignatures["Array, SparseMatrix"] = typed3.referToSelf((self2) => (x2, y2) => {
          return options.DS(...broadcast(matrix(x2), y2), self2, false);
        });
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = typed3.referToSelf((self2) => (x2, y2) => {
          return SD(...broadcast(y2, x2), self2, true);
        });
        matrixSignatures["SparseMatrix, Array"] = typed3.referToSelf((self2) => (x2, y2) => {
          return SD(...broadcast(matrix(y2), x2), self2, true);
        });
      }
    }
    var scalar = options.scalar || "any";
    var Ds = options.Ds || options.Ss;
    if (Ds) {
      if (elop) {
        matrixSignatures["DenseMatrix," + scalar] = (x2, y2) => matAlgo14xDs(x2, y2, elop, false);
        matrixSignatures[scalar + ", DenseMatrix"] = (x2, y2) => matAlgo14xDs(y2, x2, elop, true);
        matrixSignatures["Array," + scalar] = (x2, y2) => matAlgo14xDs(matrix(x2), y2, elop, false).valueOf();
        matrixSignatures[scalar + ", Array"] = (x2, y2) => matAlgo14xDs(matrix(y2), x2, elop, true).valueOf();
      } else {
        matrixSignatures["DenseMatrix," + scalar] = typed3.referToSelf((self2) => (x2, y2) => {
          return matAlgo14xDs(x2, y2, self2, false);
        });
        matrixSignatures[scalar + ", DenseMatrix"] = typed3.referToSelf((self2) => (x2, y2) => {
          return matAlgo14xDs(y2, x2, self2, true);
        });
        matrixSignatures["Array," + scalar] = typed3.referToSelf((self2) => (x2, y2) => {
          return matAlgo14xDs(matrix(x2), y2, self2, false).valueOf();
        });
        matrixSignatures[scalar + ", Array"] = typed3.referToSelf((self2) => (x2, y2) => {
          return matAlgo14xDs(matrix(y2), x2, self2, true).valueOf();
        });
      }
    }
    var sS = options.sS !== void 0 ? options.sS : options.Ss;
    if (elop) {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = (x2, y2) => options.Ss(x2, y2, elop, false);
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = (x2, y2) => sS(y2, x2, elop, true);
      }
    } else {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = typed3.referToSelf((self2) => (x2, y2) => {
          return options.Ss(x2, y2, self2, false);
        });
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = typed3.referToSelf((self2) => (x2, y2) => {
          return sS(y2, x2, self2, true);
        });
      }
    }
    if (elop && elop.signatures) {
      extend(matrixSignatures, elop.signatures);
    }
    return matrixSignatures;
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/mod.js
var name52 = "mod";
var dependencies52 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createMod = /* @__PURE__ */ factory(name52, dependencies52, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var floor2 = createFloor({
    typed: typed3,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed3,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name52, {
    "number, number": _modNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      if (y2.isNeg()) {
        throw new Error("Cannot calculate mod for a negative divisor");
      }
      return y2.isZero() ? x2 : x2.mod(y2);
    },
    "Fraction, Fraction": function FractionFraction(x2, y2) {
      if (y2.compare(0) < 0) {
        throw new Error("Cannot calculate mod for a negative divisor");
      }
      return x2.compare(0) >= 0 ? x2.mod(y2) : x2.mod(y2).add(y2).mod(y2);
    }
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
  function _modNumber(x2, y2) {
    return y2 === 0 ? x2 : x2 - y2 * floor2(x2 / y2);
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
var name53 = "matAlgo01xDSid";
var dependencies53 = ["typed"];
var createMatAlgo01xDSid = /* @__PURE__ */ factory(name53, dependencies53, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
    var cf = dt ? typed3.find(callback, [dt, dt]) : callback;
    var i, j;
    var cdata = [];
    for (i = 0; i < rows; i++) {
      cdata[i] = [];
    }
    var x2 = [];
    var w = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k2 = k0; k2 < k1; k2++) {
        i = bindex[k2];
        x2[i] = inverse ? cf(bvalues[k2], adata[i][j]) : cf(adata[i][j], bvalues[k2]);
        w[i] = mark;
      }
      for (i = 0; i < rows; i++) {
        if (w[i] === mark) {
          cdata[i][j] = x2[i];
        } else {
          cdata[i][j] = adata[i][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
var name54 = "matAlgo04xSidSid";
var dependencies54 = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = /* @__PURE__ */ factory(name54, dependencies54, (_ref) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref;
  return function matAlgo04xSidSid(a2, b, callback) {
    var avalues = a2._values;
    var aindex = a2._index;
    var aptr = a2._ptr;
    var asize = a2._size;
    var adt = a2._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = avalues && bvalues ? [] : void 0;
    var xb = avalues && bvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i, j, k2, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k2 = k0; k2 < k1; k2++) {
        i = aindex[k2];
        cindex.push(i);
        wa[i] = mark;
        if (xa) {
          xa[i] = avalues[k2];
        }
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k2 = k0; k2 < k1; k2++) {
        i = bindex[k2];
        if (wa[i] === mark) {
          if (xa) {
            var v = cf(xa[i], bvalues[k2]);
            if (!eq(v, zero3)) {
              xa[i] = v;
            } else {
              wa[i] = null;
            }
          }
        } else {
          cindex.push(i);
          wb[i] = mark;
          if (xb) {
            xb[i] = bvalues[k2];
          }
        }
      }
      if (xa && xb) {
        k2 = cptr[j];
        while (k2 < cindex.length) {
          i = cindex[k2];
          if (wa[i] === mark) {
            cvalues[k2] = xa[i];
            k2++;
          } else if (wb[i] === mark) {
            cvalues[k2] = xb[i];
            k2++;
          } else {
            cindex.splice(k2, 1);
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
var name55 = "matAlgo10xSids";
var dependencies55 = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = /* @__PURE__ */ factory(name55, dependencies55, (_ref) => {
  var {
    typed: typed3,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo10xSids(s2, b, callback, inverse) {
    var avalues = s2._values;
    var aindex = s2._index;
    var aptr = s2._ptr;
    var asize = s2._size;
    var adt = s2._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed3.convert(b, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x2 = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k2 = k0; k2 < k1; k2++) {
        var r = aindex[k2];
        x2[r] = avalues[k2];
        w[r] = mark;
      }
      for (var i = 0; i < rows; i++) {
        if (j === 0) {
          cdata[i] = [];
        }
        if (w[i] === mark) {
          cdata[i][j] = inverse ? cf(b, x2[i]) : cf(x2[i], b);
        } else {
          cdata[i][j] = b;
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/error/ArgumentsError.js
function ArgumentsError(fn, count, min4, max4) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.fn = fn;
  this.count = count;
  this.min = min4;
  this.max = max4;
  this.message = "Wrong number of arguments in function " + fn + " (" + count + " provided, " + min4 + (max4 !== void 0 && max4 !== null ? "-" + max4 : "") + " expected)";
  this.stack = new Error().stack;
}
ArgumentsError.prototype = new Error();
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = "ArgumentsError";
ArgumentsError.prototype.isArgumentsError = true;

// node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
var name56 = "gcd";
var dependencies56 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"];
var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
function is1d(array2) {
  return !array2.some((element) => Array.isArray(element));
}
var createGcd = /* @__PURE__ */ factory(name56, dependencies56, (_ref) => {
  var {
    typed: typed3,
    matrix,
    config: config4,
    round: round2,
    equalScalar,
    zeros: zeros2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var mod2 = createMod({
    typed: typed3,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  });
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed3,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name56, {
    "number, number": _gcdNumber,
    "BigNumber, BigNumber": _gcdBigNumber,
    "Fraction, Fraction": (x2, y2) => x2.gcd(y2)
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }), {
    [gcdManyTypesSignature]: typed3.referToSelf((self2) => (a2, b, args) => {
      var res = self2(a2, b);
      for (var i = 0; i < args.length; i++) {
        res = self2(res, args[i]);
      }
      return res;
    }),
    Array: typed3.referToSelf((self2) => (array2) => {
      if (array2.length === 1 && Array.isArray(array2[0]) && is1d(array2[0])) {
        return self2(...array2[0]);
      }
      if (is1d(array2)) {
        return self2(...array2);
      }
      throw new ArgumentsError("gcd() supports only 1d matrices!");
    }),
    Matrix: typed3.referToSelf((self2) => (matrix2) => {
      return self2(matrix2.toArray());
    })
  });
  function _gcdNumber(a2, b) {
    if (!isInteger(a2) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = mod2(a2, b);
      a2 = b;
      b = r;
    }
    return a2 < 0 ? -a2 : a2;
  }
  function _gcdBigNumber(a2, b) {
    if (!a2.isInt() || !b.isInt()) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var zero3 = new BigNumber2(0);
    while (!b.isZero()) {
      var r = mod2(a2, b);
      a2 = b;
      b = r;
    }
    return a2.lt(zero3) ? a2.neg() : a2;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
var name57 = "matAlgo06xS0S0";
var dependencies57 = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = /* @__PURE__ */ factory(name57, dependencies57, (_ref) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref;
  return function matAlgo06xS0S0(a2, b, callback) {
    var avalues = a2._values;
    var asize = a2._size;
    var adt = a2._datatype;
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x2 = cvalues ? [] : void 0;
    var w = [];
    var u = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      scatter(a2, j, w, x2, u, mark, cindex, cf);
      scatter(b, j, w, x2, u, mark, cindex, cf);
      if (x2) {
        var k2 = cptr[j];
        while (k2 < cindex.length) {
          var i = cindex[k2];
          if (u[i] === mark) {
            var v = x2[i];
            if (!eq(v, zero3)) {
              cvalues.push(v);
              k2++;
            } else {
              cindex.splice(k2, 1);
            }
          } else {
            cindex.splice(k2, 1);
          }
        }
      } else {
        var p = cptr[j];
        while (p < cindex.length) {
          var r = cindex[p];
          if (u[r] !== mark) {
            cindex.splice(p, 1);
          } else {
            p++;
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
var name58 = "lcm";
var dependencies58 = ["typed", "matrix", "equalScalar", "concat"];
var createLcm = /* @__PURE__ */ factory(name58, dependencies58, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed3,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
  var lcmManySignature = {};
  lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed3.referToSelf((self2) => (a2, b, args) => {
    var res = self2(a2, b);
    for (var i = 0; i < args.length; i++) {
      res = self2(res, args[i]);
    }
    return res;
  });
  return typed3(name58, {
    "number, number": lcmNumber,
    "BigNumber, BigNumber": _lcmBigNumber,
    "Fraction, Fraction": (x2, y2) => x2.lcm(y2)
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }), lcmManySignature);
  function _lcmBigNumber(a2, b) {
    if (!a2.isInt() || !b.isInt()) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a2.isZero()) {
      return a2;
    }
    if (b.isZero()) {
      return b;
    }
    var prod = a2.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a2.mod(t);
      a2 = t;
    }
    return prod.div(a2).abs();
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/log10.js
var name59 = "log10";
var dependencies59 = ["typed", "config", "Complex"];
var createLog10 = /* @__PURE__ */ factory(name59, dependencies59, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: _Complex
  } = _ref;
  return typed3(name59, {
    number: function number5(x2) {
      if (x2 >= 0 || config4.predictable) {
        return log10Number(x2);
      } else {
        return new _Complex(x2, 0).log().div(Math.LN10);
      }
    },
    Complex: function Complex3(x2) {
      return new _Complex(x2).log().div(Math.LN10);
    },
    BigNumber: function BigNumber2(x2) {
      if (!x2.isNegative() || config4.predictable) {
        return x2.log();
      } else {
        return new _Complex(x2.toNumber(), 0).log().div(Math.LN10);
      }
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log2.js
var name60 = "log2";
var dependencies60 = ["typed", "config", "Complex"];
var createLog2 = /* @__PURE__ */ factory(name60, dependencies60, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3
  } = _ref;
  return typed3(name60, {
    number: function number5(x2) {
      if (x2 >= 0 || config4.predictable) {
        return log2Number(x2);
      } else {
        return _log2Complex(new Complex3(x2, 0));
      }
    },
    Complex: _log2Complex,
    BigNumber: function BigNumber2(x2) {
      if (!x2.isNegative() || config4.predictable) {
        return x2.log(2);
      } else {
        return _log2Complex(new Complex3(x2.toNumber(), 0));
      }
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
  function _log2Complex(x2) {
    var newX = Math.sqrt(x2.re * x2.re + x2.im * x2.im);
    return new Complex3(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x2.im, x2.re) / Math.LN2);
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
var name61 = "multiplyScalar";
var dependencies61 = ["typed"];
var createMultiplyScalar = /* @__PURE__ */ factory(name61, dependencies61, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return x2.mul(y2);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.times(y2);
    },
    "Fraction, Fraction": function FractionFraction(x2, y2) {
      return x2.mul(y2);
    },
    "number | Fraction | BigNumber | Complex, Unit": (x2, y2) => y2.multiply(x2),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (x2, y2) => x2.multiply(y2)
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
var name62 = "multiply";
var dependencies62 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = /* @__PURE__ */ factory(name62, dependencies62, (_ref) => {
  var {
    typed: typed3,
    matrix,
    addScalar,
    multiplyScalar,
    equalScalar,
    dot
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a2, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot(a2, b);
  }
  function _multiplyVectorMatrix(a2, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a2, b);
  }
  function _multiplyVectorDenseMatrix(a2, b) {
    var adata = a2._data;
    var asize = a2._size;
    var adt = a2._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed3.find(addScalar, [dt, dt]);
      mf = typed3.find(multiplyScalar, [dt, dt]);
    }
    var c2 = [];
    for (var j = 0; j < bcolumns; j++) {
      var sum3 = mf(adata[0], bdata[0][j]);
      for (var i = 1; i < alength; i++) {
        sum3 = af(sum3, mf(adata[i], bdata[i][j]));
      }
      c2[j] = sum3;
    }
    return a2.createDenseMatrix({
      data: c2,
      size: [bcolumns],
      datatype: dt
    });
  }
  var _multiplyMatrixVector = typed3("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed3("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a2, b) {
    var adata = a2._data;
    var asize = a2._size;
    var adt = a2._datatype;
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed3.find(addScalar, [dt, dt]);
      mf = typed3.find(multiplyScalar, [dt, dt]);
    }
    var c2 = [];
    for (var i = 0; i < arows; i++) {
      var row = adata[i];
      var sum3 = mf(row[0], bdata[0]);
      for (var j = 1; j < acolumns; j++) {
        sum3 = af(sum3, mf(row[j], bdata[j]));
      }
      c2[i] = sum3;
    }
    return a2.createDenseMatrix({
      data: c2,
      size: [arows],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a2, b) {
    var adata = a2._data;
    var asize = a2._size;
    var adt = a2._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed3.find(addScalar, [dt, dt]);
      mf = typed3.find(multiplyScalar, [dt, dt]);
    }
    var c2 = [];
    for (var i = 0; i < arows; i++) {
      var row = adata[i];
      c2[i] = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum3 = mf(row[0], bdata[0][j]);
        for (var x2 = 1; x2 < acolumns; x2++) {
          sum3 = af(sum3, mf(row[x2], bdata[x2][j]));
        }
        c2[i][j] = sum3;
      }
    }
    return a2.createDenseMatrix({
      data: c2,
      size: [arows, bcolumns],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a2, b) {
    var adata = a2._data;
    var asize = a2._size;
    var adt = a2._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero3 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed3.find(addScalar, [dt, dt]);
      mf = typed3.find(multiplyScalar, [dt, dt]);
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c2 = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last = 0;
        for (var i = 0; i < arows; i++) {
          var mark = i + 1;
          var cij = void 0;
          for (var kb = kb0; kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last !== mark) {
              cij = mf(adata[i][ib], bvalues[kb]);
              last = mark;
            } else {
              cij = af(cij, mf(adata[i][ib], bvalues[kb]));
            }
          }
          if (last === mark && !eq(cij, zero3)) {
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c2;
  }
  function _multiplySparseMatrixVector(a2, b) {
    var avalues = a2._values;
    var aindex = a2._index;
    var aptr = a2._ptr;
    var adt = a2._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a2._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero3 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed3.find(addScalar, [dt, dt]);
      mf = typed3.find(multiplyScalar, [dt, dt]);
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
    }
    var x2 = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0; ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero3)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka2 = ka0; ka2 < ka1; ka2++) {
          var ia = aindex[ka2];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x2[ia] = mf(vbi, avalues[ka2]);
          } else {
            x2[ia] = af(x2[ia], mf(vbi, avalues[ka2]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p = 0; p < p1; p++) {
      var ic = cindex[p];
      cvalues[p] = x2[ic];
    }
    cptr[1] = cindex.length;
    return a2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: dt
    });
  }
  function _multiplySparseMatrixDenseMatrix(a2, b) {
    var avalues = a2._values;
    var aindex = a2._index;
    var aptr = a2._ptr;
    var adt = a2._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a2._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero3 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed3.find(addScalar, [dt, dt]);
      mf = typed3.find(multiplyScalar, [dt, dt]);
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c2 = a2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x2 = [];
    var w = [];
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0; ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero3)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka2 = ka0; ka2 < ka1; ka2++) {
            var ia = aindex[ka2];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x2[ia] = mf(vbij, avalues[ka2]);
            } else {
              x2[ia] = af(x2[ia], mf(vbij, avalues[ka2]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x2[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c2;
  }
  function _multiplySparseMatrixSparseMatrix(a2, b) {
    var avalues = a2._values;
    var aindex = a2._index;
    var aptr = a2._ptr;
    var adt = a2._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype;
    var arows = a2._size[0];
    var bcolumns = b._size[1];
    var values2 = avalues && bvalues;
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed3.find(addScalar, [dt, dt]);
      mf = typed3.find(multiplyScalar, [dt, dt]);
    }
    var cvalues = values2 ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var c2 = a2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x2 = values2 ? [] : void 0;
    var w = [];
    var ka2, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        ib = bindex[kb];
        if (values2) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka2 = ka0; ka2 < ka1; ka2++) {
            ia = aindex[ka2];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x2[ia] = mf(bvalues[kb], avalues[ka2]);
            } else {
              x2[ia] = af(x2[ia], mf(bvalues[kb], avalues[ka2]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka2 = ka0; ka2 < ka1; ka2++) {
            ia = aindex[ka2];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values2) {
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x2[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c2;
  }
  return typed3(name62, multiplyScalar, {
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": typed3.referTo("Matrix, Matrix", (selfMM) => (x2, y2) => {
      _validateMatrixDimensions(arraySize(x2), arraySize(y2));
      var m = selfMM(matrix(x2), matrix(y2));
      return isMatrix(m) ? m.valueOf() : m;
    }),
    "Matrix, Matrix": function MatrixMatrix(x2, y2) {
      var xsize = x2.size();
      var ysize = y2.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x2, y2, xsize[0]);
        }
        return _multiplyVectorMatrix(x2, y2);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x2, y2);
      }
      return _multiplyMatrixMatrix(x2, y2);
    },
    "Matrix, Array": typed3.referTo("Matrix,Matrix", (selfMM) => (x2, y2) => selfMM(x2, matrix(y2))),
    "Array, Matrix": typed3.referToSelf((self2) => (x2, y2) => {
      return self2(matrix(x2, y2.storage()), y2);
    }),
    "SparseMatrix, any": function SparseMatrixAny(x2, y2) {
      return matAlgo11xS0s(x2, y2, multiplyScalar, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x2, y2) {
      return matAlgo14xDs(x2, y2, multiplyScalar, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x2, y2) {
      return matAlgo11xS0s(y2, x2, multiplyScalar, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x2, y2) {
      return matAlgo14xDs(y2, x2, multiplyScalar, true);
    },
    "Array, any": function ArrayAny(x2, y2) {
      return matAlgo14xDs(matrix(x2), y2, multiplyScalar, false).valueOf();
    },
    "any, Array": function anyArray(x2, y2) {
      return matAlgo14xDs(matrix(y2), x2, multiplyScalar, true).valueOf();
    },
    "any, any": multiplyScalar,
    "any, any, ...any": typed3.referToSelf((self2) => (x2, y2, rest) => {
      var result = self2(x2, y2);
      for (var i = 0; i < rest.length; i++) {
        result = self2(result, rest[i]);
      }
      return result;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
var name63 = "nthRoot";
var dependencies63 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
var createNthRoot = /* @__PURE__ */ factory(name63, dependencies63, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    BigNumber: _BigNumber,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed3,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  function complexErr() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return typed3(name63, {
    number: nthRootNumber,
    "number, number": nthRootNumber,
    BigNumber: (x2) => _bigNthRoot(x2, new _BigNumber(2)),
    "BigNumber, BigNumber": _bigNthRoot,
    Complex: complexErr,
    "Complex, number": complexErr,
    Array: typed3.referTo("DenseMatrix,number", (selfDn) => (x2) => selfDn(matrix(x2), 2).valueOf()),
    DenseMatrix: typed3.referTo("DenseMatrix,number", (selfDn) => (x2) => selfDn(x2, 2)),
    SparseMatrix: typed3.referTo("SparseMatrix,number", (selfSn) => (x2) => selfSn(x2, 2)),
    "SparseMatrix, SparseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (y2.density() === 1) {
        return matAlgo06xS0S0(x2, y2, self2);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "DenseMatrix, SparseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (y2.density() === 1) {
        return matAlgo01xDSid(x2, y2, self2, false);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "Array, SparseMatrix": typed3.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x2, y2) => selfDS(matrix(x2), y2)),
    "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (y2.density() === 1) {
        return matAlgo11xS0s(y2, x2, self2, true);
      } else {
        throw new Error("Root must be non-zero");
      }
    })
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: false
  }));
  function _bigNthRoot(a2, root2) {
    var precision = _BigNumber.precision;
    var Big = _BigNumber.clone({
      precision: precision + 2
    });
    var zero3 = new _BigNumber(0);
    var one2 = new Big(1);
    var inv = root2.isNegative();
    if (inv) {
      root2 = root2.neg();
    }
    if (root2.isZero()) {
      throw new Error("Root must be non-zero");
    }
    if (a2.isNegative() && !root2.abs().mod(2).equals(1)) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a2.isZero()) {
      return inv ? new Big(Infinity) : 0;
    }
    if (!a2.isFinite()) {
      return inv ? zero3 : a2;
    }
    var x2 = a2.abs().pow(one2.div(root2));
    x2 = a2.isNeg() ? x2.neg() : x2;
    return new _BigNumber((inv ? one2.div(x2) : x2).toPrecision(precision));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/sign.js
var name64 = "sign";
var dependencies64 = ["typed", "BigNumber", "Fraction", "complex"];
var createSign = /* @__PURE__ */ factory(name64, dependencies64, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber,
    complex,
    Fraction: _Fraction
  } = _ref;
  return typed3(name64, {
    number: signNumber,
    Complex: function Complex3(x2) {
      return x2.im === 0 ? complex(signNumber(x2.re)) : x2.sign();
    },
    BigNumber: function BigNumber2(x2) {
      return new _BigNumber(x2.cmp(0));
    },
    Fraction: function Fraction3(x2) {
      return new _Fraction(x2.s, 1);
    },
    // deep map collection, skip zeros since sign(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2, true)),
    Unit: typed3.referToSelf((self2) => (x2) => {
      if (!x2._isDerived() && x2.units[0].unit.offset !== 0) {
        throw new TypeError("sign is ambiguous for units with offset");
      }
      return typed3.find(self2, x2.valueType())(x2.value);
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
var name65 = "sqrt";
var dependencies65 = ["config", "typed", "Complex"];
var createSqrt = /* @__PURE__ */ factory(name65, dependencies65, (_ref) => {
  var {
    config: config4,
    typed: typed3,
    Complex: Complex3
  } = _ref;
  return typed3("sqrt", {
    number: _sqrtNumber,
    Complex: function Complex4(x2) {
      return x2.sqrt();
    },
    BigNumber: function BigNumber2(x2) {
      if (!x2.isNegative() || config4.predictable) {
        return x2.sqrt();
      } else {
        return _sqrtNumber(x2.toNumber());
      }
    },
    Unit: function Unit(x2) {
      return x2.pow(0.5);
    }
  });
  function _sqrtNumber(x2) {
    if (isNaN(x2)) {
      return NaN;
    } else if (x2 >= 0 || config4.predictable) {
      return Math.sqrt(x2);
    } else {
      return new Complex3(x2, 0).sqrt();
    }
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/square.js
var name66 = "square";
var dependencies66 = ["typed"];
var createSquare = /* @__PURE__ */ factory(name66, dependencies66, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name66, {
    number: squareNumber,
    Complex: function Complex3(x2) {
      return x2.mul(x2);
    },
    BigNumber: function BigNumber2(x2) {
      return x2.times(x2);
    },
    Fraction: function Fraction3(x2) {
      return x2.mul(x2);
    },
    Unit: function Unit(x2) {
      return x2.pow(2);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
var name67 = "subtract";
var dependencies67 = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"];
var createSubtract = /* @__PURE__ */ factory(name67, dependencies67, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    subtractScalar,
    unaryMinus,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed3,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name67, {
    "any, any": subtractScalar
  }, matrixAlgorithmSuite({
    elop: subtractScalar,
    SS: matAlgo05xSfSf,
    DS: matAlgo01xDSid,
    SD: matAlgo03xDSf,
    Ss: matAlgo12xSfs,
    sS: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
var name68 = "xgcd";
var dependencies68 = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = /* @__PURE__ */ factory(name68, dependencies68, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    BigNumber: BigNumber2
  } = _ref;
  return typed3(name68, {
    "number, number": function numberNumber(a2, b) {
      var res = xgcdNumber(a2, b);
      return config4.matrix === "Array" ? res : matrix(res);
    },
    "BigNumber, BigNumber": _xgcdBigNumber
    // TODO: implement support for Fraction
  });
  function _xgcdBigNumber(a2, b) {
    var t;
    var q;
    var r;
    var zero3 = new BigNumber2(0);
    var one2 = new BigNumber2(1);
    var x2 = zero3;
    var lastx = one2;
    var y2 = one2;
    var lasty = zero3;
    if (!a2.isInt() || !b.isInt()) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (!b.isZero()) {
      q = a2.div(b).floor();
      r = a2.mod(b);
      t = x2;
      x2 = lastx.minus(q.times(x2));
      lastx = t;
      t = y2;
      y2 = lasty.minus(q.times(y2));
      lasty = t;
      a2 = b;
      b = r;
    }
    var res;
    if (a2.lt(zero3)) {
      res = [a2.neg(), lastx.neg(), lasty.neg()];
    } else {
      res = [a2, !a2.isZero() ? lastx : 0, lasty];
    }
    return config4.matrix === "Array" ? res : matrix(res);
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
var name69 = "invmod";
var dependencies69 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
var createInvmod = /* @__PURE__ */ factory(name69, dependencies69, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    BigNumber: BigNumber2,
    xgcd,
    equal,
    smaller,
    mod: mod2,
    add: add2,
    isInteger: isInteger2
  } = _ref;
  return typed3(name69, {
    "number, number": invmod,
    "BigNumber, BigNumber": invmod
  });
  function invmod(a2, b) {
    if (!isInteger2(a2) || !isInteger2(b))
      throw new Error("Parameters in function invmod must be integer numbers");
    a2 = mod2(a2, b);
    if (equal(b, 0))
      throw new Error("Divisor must be non zero");
    var res = xgcd(a2, b);
    res = res.valueOf();
    var [gcd, inv] = res;
    if (!equal(gcd, BigNumber2(1)))
      return NaN;
    inv = mod2(inv, b);
    if (smaller(inv, BigNumber2(0)))
      inv = add2(inv, b);
    return inv;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
var name70 = "matAlgo09xS0Sf";
var dependencies70 = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = /* @__PURE__ */ factory(name70, dependencies70, (_ref) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref;
  return function matAlgo09xS0Sf(a2, b, callback) {
    var avalues = a2._values;
    var aindex = a2._index;
    var aptr = a2._ptr;
    var asize = a2._size;
    var adt = a2._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x2 = cvalues ? [] : void 0;
    var w = [];
    var i, j, k2, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      if (x2) {
        for (k0 = bptr[j], k1 = bptr[j + 1], k2 = k0; k2 < k1; k2++) {
          i = bindex[k2];
          w[i] = mark;
          x2[i] = bvalues[k2];
        }
      }
      for (k0 = aptr[j], k1 = aptr[j + 1], k2 = k0; k2 < k1; k2++) {
        i = aindex[k2];
        if (x2) {
          var vb = w[i] === mark ? x2[i] : zero3;
          var vc = cf(avalues[k2], vb);
          if (!eq(vc, zero3)) {
            cindex.push(i);
            cvalues.push(vc);
          }
        } else {
          cindex.push(i);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
var name71 = "dotMultiply";
var dependencies71 = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
var createDotMultiply = /* @__PURE__ */ factory(name71, dependencies71, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    multiplyScalar,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed3,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name71, matrixAlgorithmSuite({
    elop: multiplyScalar,
    SS: matAlgo09xS0Sf,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});

// node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
function bitAndBigNumber(x2, y2) {
  if (x2.isFinite() && !x2.isInteger() || y2.isFinite() && !y2.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber2 = x2.constructor;
  if (x2.isNaN() || y2.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x2.isZero() || y2.eq(-1) || x2.eq(y2)) {
    return x2;
  }
  if (y2.isZero() || x2.eq(-1)) {
    return y2;
  }
  if (!x2.isFinite() || !y2.isFinite()) {
    if (!x2.isFinite() && !y2.isFinite()) {
      if (x2.isNegative() === y2.isNegative()) {
        return x2;
      }
      return new BigNumber2(0);
    }
    if (!x2.isFinite()) {
      if (y2.isNegative()) {
        return x2;
      }
      if (x2.isNegative()) {
        return new BigNumber2(0);
      }
      return y2;
    }
    if (!y2.isFinite()) {
      if (x2.isNegative()) {
        return y2;
      }
      if (y2.isNegative()) {
        return new BigNumber2(0);
      }
      return x2;
    }
  }
  return bitwise(x2, y2, function(a2, b) {
    return a2 & b;
  });
}
function bitNotBigNumber(x2) {
  if (x2.isFinite() && !x2.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber2 = x2.constructor;
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  var result = x2.plus(new BigNumber2(1));
  result.s = -result.s || null;
  BigNumber2.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x2, y2) {
  if (x2.isFinite() && !x2.isInteger() || y2.isFinite() && !y2.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber2 = x2.constructor;
  if (x2.isNaN() || y2.isNaN()) {
    return new BigNumber2(NaN);
  }
  var negOne = new BigNumber2(-1);
  if (x2.isZero() || y2.eq(negOne) || x2.eq(y2)) {
    return y2;
  }
  if (y2.isZero() || x2.eq(negOne)) {
    return x2;
  }
  if (!x2.isFinite() || !y2.isFinite()) {
    if (!x2.isFinite() && !x2.isNegative() && y2.isNegative() || x2.isNegative() && !y2.isNegative() && !y2.isFinite()) {
      return negOne;
    }
    if (x2.isNegative() && y2.isNegative()) {
      return x2.isFinite() ? x2 : y2;
    }
    return x2.isFinite() ? y2 : x2;
  }
  return bitwise(x2, y2, function(a2, b) {
    return a2 | b;
  });
}
function bitwise(x2, y2, func) {
  var BigNumber2 = x2.constructor;
  var xBits, yBits;
  var xSign = +(x2.s < 0);
  var ySign = +(y2.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x2));
    for (var i = 0; i < xBits.length; ++i) {
      xBits[i] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x2);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y2));
    for (var _i = 0; _i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y2);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber2(expFuncVal ^ 1);
  var twoPower = new BigNumber2(1);
  var two = new BigNumber2(2);
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber2.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x2) {
  var a2 = x2.d;
  var r = a2[0] + "";
  for (var i = 1; i < a2.length; ++i) {
    var s2 = a2[i] + "";
    for (var z = 7 - s2.length; z--; ) {
      s2 = "0" + s2;
    }
    r += s2;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x2.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0; _i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0; _j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor(x2, y2) {
  if (x2.isFinite() && !x2.isInteger() || y2.isFinite() && !y2.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber2 = x2.constructor;
  if (x2.isNaN() || y2.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x2.isZero()) {
    return y2;
  }
  if (y2.isZero()) {
    return x2;
  }
  if (x2.eq(y2)) {
    return new BigNumber2(0);
  }
  var negOne = new BigNumber2(-1);
  if (x2.eq(negOne)) {
    return bitNotBigNumber(y2);
  }
  if (y2.eq(negOne)) {
    return bitNotBigNumber(x2);
  }
  if (!x2.isFinite() || !y2.isFinite()) {
    if (!x2.isFinite() && !y2.isFinite()) {
      return negOne;
    }
    return new BigNumber2(x2.isNegative() === y2.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x2, y2, function(a2, b) {
    return a2 ^ b;
  });
}
function leftShiftBigNumber(x2, y2) {
  if (x2.isFinite() && !x2.isInteger() || y2.isFinite() && !y2.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber2 = x2.constructor;
  if (x2.isNaN() || y2.isNaN() || y2.isNegative() && !y2.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x2.isZero() || y2.isZero()) {
    return x2;
  }
  if (!x2.isFinite() && !y2.isFinite()) {
    return new BigNumber2(NaN);
  }
  if (y2.lt(55)) {
    return x2.times(Math.pow(2, y2.toNumber()) + "");
  }
  return x2.times(new BigNumber2(2).pow(y2));
}
function rightArithShiftBigNumber(x2, y2) {
  if (x2.isFinite() && !x2.isInteger() || y2.isFinite() && !y2.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber2 = x2.constructor;
  if (x2.isNaN() || y2.isNaN() || y2.isNegative() && !y2.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x2.isZero() || y2.isZero()) {
    return x2;
  }
  if (!y2.isFinite()) {
    if (x2.isNegative()) {
      return new BigNumber2(-1);
    }
    if (!x2.isFinite()) {
      return new BigNumber2(NaN);
    }
    return new BigNumber2(0);
  }
  if (y2.lt(55)) {
    return x2.div(Math.pow(2, y2.toNumber()) + "").floor();
  }
  return x2.div(new BigNumber2(2).pow(y2)).floor();
}

// node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
var name72 = "bitAnd";
var dependencies72 = ["typed", "matrix", "equalScalar", "concat"];
var createBitAnd = /* @__PURE__ */ factory(name72, dependencies72, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed3,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name72, {
    "number, number": bitAndNumber,
    "BigNumber, BigNumber": bitAndBigNumber
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
var name73 = "bitNot";
var dependencies73 = ["typed"];
var createBitNot = /* @__PURE__ */ factory(name73, dependencies73, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name73, {
    number: bitNotNumber,
    BigNumber: bitNotBigNumber,
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
var name74 = "bitOr";
var dependencies74 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOr = /* @__PURE__ */ factory(name74, dependencies74, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed3,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name74, {
    "number, number": bitOrNumber,
    "BigNumber, BigNumber": bitOrBigNumber
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js
var name75 = "matAlgo07xSSf";
var dependencies75 = ["typed", "DenseMatrix"];
var createMatAlgo07xSSf = /* @__PURE__ */ factory(name75, dependencies75, (_ref) => {
  var {
    typed: typed3,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo07xSSf(a2, b, callback) {
    var asize = a2._size;
    var adt = a2._datatype;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      zero3 = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var i, j;
    var cdata = [];
    for (i = 0; i < rows; i++) {
      cdata[i] = [];
    }
    var xa = [];
    var xb = [];
    var wa = [];
    var wb = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      _scatter(a2, j, wa, xa, mark);
      _scatter(b, j, wb, xb, mark);
      for (i = 0; i < rows; i++) {
        var va = wa[i] === mark ? xa[i] : zero3;
        var vb = wb[i] === mark ? xb[i] : zero3;
        cdata[i][j] = cf(va, vb);
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
  function _scatter(m, j, w, x2, mark) {
    var values2 = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var k2 = ptr[j], k1 = ptr[j + 1]; k2 < k1; k2++) {
      var i = index[k2];
      w[i] = mark;
      x2[i] = values2[k2];
    }
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
var name76 = "bitXor";
var dependencies76 = ["typed", "matrix", "DenseMatrix", "concat"];
var createBitXor = /* @__PURE__ */ factory(name76, dependencies76, (_ref) => {
  var {
    typed: typed3,
    matrix,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name76, {
    "number, number": bitXorNumber,
    "BigNumber, BigNumber": bitXor
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/complex/arg.js
var name77 = "arg";
var dependencies77 = ["typed"];
var createArg = /* @__PURE__ */ factory(name77, dependencies77, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name77, {
    number: function number5(x2) {
      return Math.atan2(0, x2);
    },
    BigNumber: function BigNumber2(x2) {
      return x2.constructor.atan2(0, x2);
    },
    Complex: function Complex3(x2) {
      return x2.arg();
    },
    // TODO: implement BigNumber support for function arg
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/complex/conj.js
var name78 = "conj";
var dependencies78 = ["typed"];
var createConj = /* @__PURE__ */ factory(name78, dependencies78, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name78, {
    "number | BigNumber | Fraction": (x2) => x2,
    Complex: (x2) => x2.conjugate(),
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/complex/im.js
var name79 = "im";
var dependencies79 = ["typed"];
var createIm = /* @__PURE__ */ factory(name79, dependencies79, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name79, {
    number: () => 0,
    "BigNumber | Fraction": (x2) => x2.mul(0),
    Complex: (x2) => x2.im,
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/complex/re.js
var name80 = "re";
var dependencies80 = ["typed"];
var createRe = /* @__PURE__ */ factory(name80, dependencies80, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name80, {
    "number | BigNumber | Fraction": (x2) => x2,
    Complex: (x2) => x2.re,
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/logical/not.js
var name81 = "not";
var dependencies81 = ["typed"];
var createNot = /* @__PURE__ */ factory(name81, dependencies81, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name81, {
    "null | undefined": () => true,
    number: notNumber,
    Complex: function Complex3(x2) {
      return x2.re === 0 && x2.im === 0;
    },
    BigNumber: function BigNumber2(x2) {
      return x2.isZero() || x2.isNaN();
    },
    Unit: typed3.referToSelf((self2) => (x2) => typed3.find(self2, x2.valueType())(x2.value)),
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/logical/or.js
var name82 = "or";
var dependencies82 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOr = /* @__PURE__ */ factory(name82, dependencies82, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name82, {
    "number, number": orNumber,
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return x2.re !== 0 || x2.im !== 0 || y2.re !== 0 || y2.im !== 0;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return !x2.isZero() && !x2.isNaN() || !y2.isZero() && !y2.isNaN();
    },
    "Unit, Unit": typed3.referToSelf((self2) => (x2, y2) => self2(x2.value || 0, y2.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/logical/xor.js
var name83 = "xor";
var dependencies83 = ["typed", "matrix", "DenseMatrix", "concat"];
var createXor = /* @__PURE__ */ factory(name83, dependencies83, (_ref) => {
  var {
    typed: typed3,
    matrix,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name83, {
    "number, number": xorNumber,
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return (x2.re !== 0 || x2.im !== 0) !== (y2.re !== 0 || y2.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return (!x2.isZero() && !x2.isNaN()) !== (!y2.isZero() && !y2.isNaN());
    },
    "Unit, Unit": typed3.referToSelf((self2) => (x2, y2) => self2(x2.value || 0, y2.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/matrix/concat.js
var name84 = "concat";
var dependencies84 = ["typed", "matrix", "isInteger"];
var createConcat = /* @__PURE__ */ factory(name84, dependencies84, (_ref) => {
  var {
    typed: typed3,
    matrix,
    isInteger: isInteger2
  } = _ref;
  return typed3(name84, {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
      var i;
      var len = args.length;
      var dim = -1;
      var prevDim;
      var asMatrix = false;
      var matrices = [];
      for (i = 0; i < len; i++) {
        var arg = args[i];
        if (isMatrix(arg)) {
          asMatrix = true;
        }
        if (isNumber(arg) || isBigNumber(arg)) {
          if (i !== len - 1) {
            throw new Error("Dimension must be specified as last argument");
          }
          prevDim = dim;
          dim = arg.valueOf();
          if (!isInteger2(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          if (dim < 0 || i > 0 && dim > prevDim) {
            throw new IndexError(dim, prevDim + 1);
          }
        } else {
          var m = clone(arg).valueOf();
          var size = arraySize(m);
          matrices[i] = m;
          prevDim = dim;
          dim = size.length - 1;
          if (i > 0 && dim !== prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }
      if (matrices.length === 0) {
        throw new SyntaxError("At least one matrix expected");
      }
      var res = matrices.shift();
      while (matrices.length) {
        res = concat(res, matrices.shift(), dim);
      }
      return asMatrix ? matrix(res) : res;
    },
    "...string": function string(args) {
      return args.join("");
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/column.js
var name85 = "column";
var dependencies85 = ["typed", "Index", "matrix", "range"];
var createColumn = /* @__PURE__ */ factory(name85, dependencies85, (_ref) => {
  var {
    typed: typed3,
    Index,
    matrix,
    range: range2
  } = _ref;
  return typed3(name85, {
    "Matrix, number": _column,
    "Array, number": function ArrayNumber(value, column) {
      return _column(matrix(clone(value)), column).valueOf();
    }
  });
  function _column(value, column) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(column, value.size()[1]);
    var rowRange = range2(0, value.size()[0]);
    var index = new Index(rowRange, column);
    var result = value.subset(index);
    return isMatrix(result) ? result : matrix([[result]]);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/count.js
var name86 = "count";
var dependencies86 = ["typed", "size", "prod"];
var createCount = /* @__PURE__ */ factory(name86, dependencies86, (_ref) => {
  var {
    typed: typed3,
    size,
    prod
  } = _ref;
  return typed3(name86, {
    string: function string(x2) {
      return x2.length;
    },
    "Matrix | Array": function MatrixArray(x2) {
      return prod(size(x2));
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/cross.js
var name87 = "cross";
var dependencies87 = ["typed", "matrix", "subtract", "multiply"];
var createCross = /* @__PURE__ */ factory(name87, dependencies87, (_ref) => {
  var {
    typed: typed3,
    matrix,
    subtract,
    multiply
  } = _ref;
  return typed3(name87, {
    "Matrix, Matrix": function MatrixMatrix(x2, y2) {
      return matrix(_cross(x2.toArray(), y2.toArray()));
    },
    "Matrix, Array": function MatrixArray(x2, y2) {
      return matrix(_cross(x2.toArray(), y2));
    },
    "Array, Matrix": function ArrayMatrix(x2, y2) {
      return matrix(_cross(x2, y2.toArray()));
    },
    "Array, Array": _cross
  });
  function _cross(x2, y2) {
    var highestDimension = Math.max(arraySize(x2).length, arraySize(y2).length);
    x2 = squeeze(x2);
    y2 = squeeze(y2);
    var xSize = arraySize(x2);
    var ySize = arraySize(y2);
    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
      throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
    }
    var product3 = [subtract(multiply(x2[1], y2[2]), multiply(x2[2], y2[1])), subtract(multiply(x2[2], y2[0]), multiply(x2[0], y2[2])), subtract(multiply(x2[0], y2[1]), multiply(x2[1], y2[0]))];
    if (highestDimension > 1) {
      return [product3];
    } else {
      return product3;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/diag.js
var name88 = "diag";
var dependencies88 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = /* @__PURE__ */ factory(name88, dependencies88, (_ref) => {
  var {
    typed: typed3,
    matrix,
    DenseMatrix: DenseMatrix2,
    SparseMatrix
  } = _ref;
  return typed3(name88, {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
    Array: function Array2(x2) {
      return _diag(x2, 0, arraySize(x2), null);
    },
    "Array, number": function ArrayNumber(x2, k2) {
      return _diag(x2, k2, arraySize(x2), null);
    },
    "Array, BigNumber": function ArrayBigNumber(x2, k2) {
      return _diag(x2, k2.toNumber(), arraySize(x2), null);
    },
    "Array, string": function ArrayString(x2, format6) {
      return _diag(x2, 0, arraySize(x2), format6);
    },
    "Array, number, string": function ArrayNumberString(x2, k2, format6) {
      return _diag(x2, k2, arraySize(x2), format6);
    },
    "Array, BigNumber, string": function ArrayBigNumberString(x2, k2, format6) {
      return _diag(x2, k2.toNumber(), arraySize(x2), format6);
    },
    Matrix: function Matrix2(x2) {
      return _diag(x2, 0, x2.size(), x2.storage());
    },
    "Matrix, number": function MatrixNumber(x2, k2) {
      return _diag(x2, k2, x2.size(), x2.storage());
    },
    "Matrix, BigNumber": function MatrixBigNumber(x2, k2) {
      return _diag(x2, k2.toNumber(), x2.size(), x2.storage());
    },
    "Matrix, string": function MatrixString(x2, format6) {
      return _diag(x2, 0, x2.size(), format6);
    },
    "Matrix, number, string": function MatrixNumberString(x2, k2, format6) {
      return _diag(x2, k2, x2.size(), format6);
    },
    "Matrix, BigNumber, string": function MatrixBigNumberString(x2, k2, format6) {
      return _diag(x2, k2.toNumber(), x2.size(), format6);
    }
  });
  function _diag(x2, k2, size, format6) {
    if (!isInteger(k2)) {
      throw new TypeError("Second parameter in function diag must be an integer");
    }
    var kSuper = k2 > 0 ? k2 : 0;
    var kSub = k2 < 0 ? -k2 : 0;
    switch (size.length) {
      case 1:
        return _createDiagonalMatrix(x2, k2, format6, size[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x2, k2, format6, size, kSub, kSuper);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function _createDiagonalMatrix(x2, k2, format6, l, kSub, kSuper) {
    var ms = [l + kSub, l + kSuper];
    if (format6 && format6 !== "sparse" && format6 !== "dense") {
      throw new TypeError("Unknown matrix type ".concat(format6, '"'));
    }
    var m = format6 === "sparse" ? SparseMatrix.diagonal(ms, x2, k2) : DenseMatrix2.diagonal(ms, x2, k2);
    return format6 !== null ? m : m.valueOf();
  }
  function _getDiagonal(x2, k2, format6, s2, kSub, kSuper) {
    if (isMatrix(x2)) {
      var dm = x2.diagonal(k2);
      if (format6 !== null) {
        if (format6 !== dm.storage()) {
          return matrix(dm, format6);
        }
        return dm;
      }
      return dm.valueOf();
    }
    var n = Math.min(s2[0] - kSub, s2[1] - kSuper);
    var vector = [];
    for (var i = 0; i < n; i++) {
      vector[i] = x2[i + kSub][i + kSuper];
    }
    return format6 !== null ? matrix(vector) : vector;
  }
});

// node_modules/mathjs/lib/esm/utils/applyCallback.js
var import_typed_function2 = __toESM(require_typed_function(), 1);
function applyCallback(callback, value, index, array2, mappingFnName) {
  if (import_typed_function2.default.isTypedFunction(callback)) {
    var args3 = [value, index, array2];
    var signature3 = import_typed_function2.default.resolve(callback, args3);
    if (signature3) {
      return tryWithArgs(signature3.implementation, args3);
    }
    var args2 = [value, index];
    var signature2 = import_typed_function2.default.resolve(callback, args2);
    if (signature2) {
      return tryWithArgs(signature2.implementation, args2);
    }
    var args1 = [value];
    var signature1 = import_typed_function2.default.resolve(callback, args1);
    if (signature1) {
      return tryWithArgs(signature1.implementation, args1);
    }
    return tryWithArgs(callback, args3);
  } else {
    return callback(value, index, array2);
  }
  function tryWithArgs(signature, args) {
    try {
      return signature.apply(signature, args);
    } catch (err) {
      var _err$data;
      if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === "wrongType") {
        var argsDesc = [];
        argsDesc.push("value: ".concat(typeOf(value)));
        if (args.length >= 2) {
          argsDesc.push("index: ".concat(typeOf(index)));
        }
        if (args.length >= 3) {
          argsDesc.push("array: ".concat(typeOf(array2)));
        }
        throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callback.name, "(").concat(argsDesc.join(", "), ") at index ").concat(JSON.stringify(index)));
      } else {
        throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callback.name, ": ").concat(err.message));
      }
    }
  }
}

// node_modules/mathjs/lib/esm/function/matrix/filter.js
var name89 = "filter";
var dependencies89 = ["typed"];
var createFilter = /* @__PURE__ */ factory(name89, dependencies89, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("filter", {
    "Array, function": _filterCallback,
    "Matrix, function": function MatrixFunction(x2, test) {
      return x2.create(_filterCallback(x2.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x2, test) {
      return x2.create(filterRegExp(x2.toArray(), test));
    }
  });
});
function _filterCallback(x2, callback) {
  return filter(x2, function(value, index, array2) {
    return applyCallback(callback, value, [index], array2, "filter");
  });
}

// node_modules/mathjs/lib/esm/function/matrix/flatten.js
var name90 = "flatten";
var dependencies90 = ["typed", "matrix"];
var createFlatten = /* @__PURE__ */ factory(name90, dependencies90, (_ref) => {
  var {
    typed: typed3,
    matrix
  } = _ref;
  return typed3(name90, {
    Array: function Array2(x2) {
      return flatten(x2);
    },
    Matrix: function Matrix2(x2) {
      var flat = flatten(x2.toArray());
      return matrix(flat);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/forEach.js
var name91 = "forEach";
var dependencies91 = ["typed"];
var createForEach = /* @__PURE__ */ factory(name91, dependencies91, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name91, {
    "Array, function": _forEach,
    "Matrix, function": function MatrixFunction(x2, callback) {
      x2.forEach(callback);
    }
  });
});
function _forEach(array2, callback) {
  var recurse = function recurse2(value, index) {
    if (Array.isArray(value)) {
      forEach(value, function(child, i) {
        recurse2(child, index.concat(i));
      });
    } else {
      return applyCallback(callback, value, index, array2, "forEach");
    }
  };
  recurse(array2, []);
}

// node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
var name92 = "getMatrixDataType";
var dependencies92 = ["typed"];
var createGetMatrixDataType = /* @__PURE__ */ factory(name92, dependencies92, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name92, {
    Array: function Array2(x2) {
      return getArrayDataType(x2, typeOf);
    },
    Matrix: function Matrix2(x2) {
      return x2.getDataType();
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/identity.js
var name93 = "identity";
var dependencies93 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = /* @__PURE__ */ factory(name93, dependencies93, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix
  } = _ref;
  return typed3(name93, {
    "": function _() {
      return config4.matrix === "Matrix" ? matrix([]) : [];
    },
    string: function string(format6) {
      return matrix(format6);
    },
    "number | BigNumber": function numberBigNumber(rows) {
      return _identity(rows, rows, config4.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function numberBigNumberString(rows, format6) {
      return _identity(rows, rows, format6);
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
      return _identity(rows, cols, config4.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format6) {
      return _identity(rows, cols, format6);
    },
    Array: function Array2(size) {
      return _identityVector(size);
    },
    "Array, string": function ArrayString(size, format6) {
      return _identityVector(size, format6);
    },
    Matrix: function Matrix2(size) {
      return _identityVector(size.valueOf(), size.storage());
    },
    "Matrix, string": function MatrixString(size, format6) {
      return _identityVector(size.valueOf(), format6);
    }
  });
  function _identityVector(size, format6) {
    switch (size.length) {
      case 0:
        return format6 ? matrix(format6) : [];
      case 1:
        return _identity(size[0], size[0], format6);
      case 2:
        return _identity(size[0], size[1], format6);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format6) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
    if (isBigNumber(rows))
      rows = rows.toNumber();
    if (isBigNumber(cols))
      cols = cols.toNumber();
    if (!isInteger(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one2 = Big ? new BigNumber2(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size = [rows, cols];
    if (format6) {
      if (format6 === "sparse") {
        return SparseMatrix.diagonal(size, one2, 0, defaultValue);
      }
      if (format6 === "dense") {
        return DenseMatrix2.diagonal(size, one2, 0, defaultValue);
      }
      throw new TypeError('Unknown matrix type "'.concat(format6, '"'));
    }
    var res = resize([], size, defaultValue);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one2;
    }
    return res;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/kron.js
var name94 = "kron";
var dependencies94 = ["typed", "matrix", "multiplyScalar"];
var createKron = /* @__PURE__ */ factory(name94, dependencies94, (_ref) => {
  var {
    typed: typed3,
    matrix,
    multiplyScalar
  } = _ref;
  return typed3(name94, {
    "Matrix, Matrix": function MatrixMatrix(x2, y2) {
      return matrix(_kron(x2.toArray(), y2.toArray()));
    },
    "Matrix, Array": function MatrixArray(x2, y2) {
      return matrix(_kron(x2.toArray(), y2));
    },
    "Array, Matrix": function ArrayMatrix(x2, y2) {
      return matrix(_kron(x2, y2.toArray()));
    },
    "Array, Array": _kron
  });
  function _kron(a2, b) {
    if (arraySize(a2).length === 1) {
      a2 = [a2];
    }
    if (arraySize(b).length === 1) {
      b = [b];
    }
    if (arraySize(a2).length > 2 || arraySize(b).length > 2) {
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a2.length) + ", y = " + JSON.stringify(b.length) + ")");
    }
    var t = [];
    var r = [];
    return a2.map(function(a3) {
      return b.map(function(b2) {
        r = [];
        t.push(r);
        return a3.map(function(y2) {
          return b2.map(function(x2) {
            return r.push(multiplyScalar(y2, x2));
          });
        });
      });
    }) && t;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/map.js
var name95 = "map";
var dependencies95 = ["typed"];
var createMap2 = /* @__PURE__ */ factory(name95, dependencies95, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name95, {
    "Array, function": _map,
    "Matrix, function": function MatrixFunction(x2, callback) {
      return x2.map(callback);
    }
  });
});
function _map(array2, callback) {
  var recurse = function recurse2(value, index) {
    if (Array.isArray(value)) {
      return value.map(function(child, i) {
        return recurse2(child, index.concat(i));
      });
    } else {
      return applyCallback(callback, value, index, array2, "map");
    }
  };
  return recurse(array2, []);
}

// node_modules/mathjs/lib/esm/function/matrix/diff.js
var name96 = "diff";
var dependencies96 = ["typed", "matrix", "subtract", "number"];
var createDiff = /* @__PURE__ */ factory(name96, dependencies96, (_ref) => {
  var {
    typed: typed3,
    matrix,
    subtract,
    number: number5
  } = _ref;
  return typed3(name96, {
    "Array | Matrix": function ArrayMatrix(arr) {
      if (isMatrix(arr)) {
        return matrix(_diff(arr.toArray()));
      } else {
        return _diff(arr);
      }
    },
    "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
      if (!isInteger(dim))
        throw new RangeError("Dimension must be a whole number");
      if (isMatrix(arr)) {
        return matrix(_recursive(arr.toArray(), dim));
      } else {
        return _recursive(arr, dim);
      }
    },
    "Array, BigNumber": typed3.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number5(dim))),
    "Matrix, BigNumber": typed3.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number5(dim)))
  });
  function _recursive(arr, dim) {
    if (isMatrix(arr)) {
      arr = arr.toArray();
    }
    if (!Array.isArray(arr)) {
      throw RangeError("Array/Matrix does not have that many dimensions");
    }
    if (dim > 0) {
      var result = [];
      arr.forEach((element) => {
        result.push(_recursive(element, dim - 1));
      });
      return result;
    } else if (dim === 0) {
      return _diff(arr);
    } else {
      throw RangeError("Cannot have negative dimension");
    }
  }
  function _diff(arr) {
    var result = [];
    var size = arr.length;
    for (var i = 1; i < size; i++) {
      result.push(_ElementDiff(arr[i - 1], arr[i]));
    }
    return result;
  }
  function _ElementDiff(obj1, obj2) {
    if (isMatrix(obj1))
      obj1 = obj1.toArray();
    if (isMatrix(obj2))
      obj2 = obj2.toArray();
    var obj1IsArray = Array.isArray(obj1);
    var obj2IsArray = Array.isArray(obj2);
    if (obj1IsArray && obj2IsArray) {
      return _ArrayDiff(obj1, obj2);
    }
    if (!obj1IsArray && !obj2IsArray) {
      return subtract(obj2, obj1);
    }
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function _ArrayDiff(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      throw RangeError("Not all sub-arrays have the same length");
    }
    var result = [];
    var size = arr1.length;
    for (var i = 0; i < size; i++) {
      result.push(_ElementDiff(arr1[i], arr2[i]));
    }
    return result;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ones.js
var name97 = "ones";
var dependencies97 = ["typed", "config", "matrix", "BigNumber"];
var createOnes = /* @__PURE__ */ factory(name97, dependencies97, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    BigNumber: BigNumber2
  } = _ref;
  return typed3("ones", {
    "": function _() {
      return config4.matrix === "Array" ? _ones([]) : _ones([], "default");
    },
    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function numberBigNumberString(size) {
      var last = size[size.length - 1];
      if (typeof last === "string") {
        var format6 = size.pop();
        return _ones(size, format6);
      } else if (config4.matrix === "Array") {
        return _ones(size);
      } else {
        return _ones(size, "default");
      }
    },
    Array: _ones,
    Matrix: function Matrix2(size) {
      var format6 = size.storage();
      return _ones(size.valueOf(), format6);
    },
    "Array | Matrix, string": function ArrayMatrixString(size, format6) {
      return _ones(size.valueOf(), format6);
    }
  });
  function _ones(size, format6) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
    _validate2(size);
    if (format6) {
      var m = matrix(format6);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function(value, index, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size) {
    size.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function ones must be positive integers");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/utils/noop.js
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}

// node_modules/mathjs/lib/esm/function/matrix/range.js
var name98 = "range";
var dependencies98 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
var createRange = /* @__PURE__ */ factory(name98, dependencies98, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    bignumber,
    smaller,
    smallerEq,
    larger,
    largerEq,
    add: add2,
    isPositive
  } = _ref;
  return typed3(name98, {
    // TODO: simplify signatures when typed-function supports default values and optional arguments
    // TODO: a number or boolean should not be converted to string here
    string: _strRange,
    "string, boolean": _strRange,
    "number, number": function numberNumber(start2, end) {
      return _out(_range(start2, end, 1, false));
    },
    "number, number, number": function numberNumberNumber(start2, end, step) {
      return _out(_range(start2, end, step, false));
    },
    "number, number, boolean": function numberNumberBoolean(start2, end, includeEnd) {
      return _out(_range(start2, end, 1, includeEnd));
    },
    "number, number, number, boolean": function numberNumberNumberBoolean(start2, end, step, includeEnd) {
      return _out(_range(start2, end, step, includeEnd));
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(start2, end) {
      var BigNumber2 = start2.constructor;
      return _out(_range(start2, end, new BigNumber2(1), false));
    },
    "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start2, end, step) {
      return _out(_range(start2, end, step, false));
    },
    "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start2, end, includeEnd) {
      var BigNumber2 = start2.constructor;
      return _out(_range(start2, end, new BigNumber2(1), includeEnd));
    },
    "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start2, end, step, includeEnd) {
      return _out(_range(start2, end, step, includeEnd));
    },
    "Unit, Unit, Unit": function UnitUnitUnit(start2, end, step) {
      return _out(_range(start2, end, step, false));
    },
    "Unit, Unit, Unit, boolean": function UnitUnitUnitBoolean(start2, end, step, includeEnd) {
      return _out(_range(start2, end, step, includeEnd));
    }
  });
  function _out(arr) {
    if (config4.matrix === "Matrix") {
      return matrix ? matrix(arr) : noMatrix();
    }
    return arr;
  }
  function _strRange(str, includeEnd) {
    var r = _parse(str);
    if (!r) {
      throw new SyntaxError('String "' + str + '" is no valid range');
    }
    if (config4.number === "BigNumber") {
      if (bignumber === void 0) {
        noBignumber();
      }
      return _out(_range(bignumber(r.start), bignumber(r.end), bignumber(r.step)), includeEnd);
    } else {
      return _out(_range(r.start, r.end, r.step, includeEnd));
    }
  }
  function _range(start2, end, step, includeEnd) {
    var array2 = [];
    var ongoing = isPositive(step) ? includeEnd ? smallerEq : smaller : includeEnd ? largerEq : larger;
    var x2 = start2;
    while (ongoing(x2, end)) {
      array2.push(x2);
      x2 = add2(x2, step);
    }
    return array2;
  }
  function _parse(str) {
    var args = str.split(":");
    var nums = args.map(function(arg) {
      return Number(arg);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };
      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };
      default:
        return null;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/reshape.js
var name99 = "reshape";
var dependencies99 = ["typed", "isInteger", "matrix"];
var createReshape = /* @__PURE__ */ factory(name99, dependencies99, (_ref) => {
  var {
    typed: typed3,
    isInteger: isInteger2
  } = _ref;
  return typed3(name99, {
    "Matrix, Array": function MatrixArray(x2, sizes) {
      return x2.reshape(sizes, true);
    },
    "Array, Array": function ArrayArray(x2, sizes) {
      sizes.forEach(function(size) {
        if (!isInteger2(size)) {
          throw new TypeError("Invalid size for dimension: " + size);
        }
      });
      return reshape(x2, sizes);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/resize.js
var name100 = "resize";
var dependencies100 = ["config", "matrix"];
var createResize = /* @__PURE__ */ factory(name100, dependencies100, (_ref) => {
  var {
    config: config4,
    matrix
  } = _ref;
  return function resize2(x2, size, defaultValue) {
    if (arguments.length !== 2 && arguments.length !== 3) {
      throw new ArgumentsError("resize", arguments.length, 2, 3);
    }
    if (isMatrix(size)) {
      size = size.valueOf();
    }
    if (isBigNumber(size[0])) {
      size = size.map(function(value) {
        return !isBigNumber(value) ? value : value.toNumber();
      });
    }
    if (isMatrix(x2)) {
      return x2.resize(size, defaultValue, true);
    }
    if (typeof x2 === "string") {
      return _resizeString(x2, size, defaultValue);
    }
    var asMatrix = Array.isArray(x2) ? false : config4.matrix !== "Array";
    if (size.length === 0) {
      while (Array.isArray(x2)) {
        x2 = x2[0];
      }
      return clone(x2);
    } else {
      if (!Array.isArray(x2)) {
        x2 = [x2];
      }
      x2 = clone(x2);
      var res = resize(x2, size, defaultValue);
      return asMatrix ? matrix(res) : res;
    }
  };
  function _resizeString(str, size, defaultChar) {
    if (defaultChar !== void 0) {
      if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultChar = " ";
    }
    if (size.length !== 1) {
      throw new DimensionError(size.length, 1);
    }
    var len = size[0];
    if (typeof len !== "number" || !isInteger(len)) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size) + ")");
    }
    if (str.length > len) {
      return str.substring(0, len);
    } else if (str.length < len) {
      var res = str;
      for (var i = 0, ii = len - str.length; i < ii; i++) {
        res += defaultChar;
      }
      return res;
    } else {
      return str;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotate.js
var name101 = "rotate";
var dependencies101 = ["typed", "multiply", "rotationMatrix"];
var createRotate = /* @__PURE__ */ factory(name101, dependencies101, (_ref) => {
  var {
    typed: typed3,
    multiply,
    rotationMatrix
  } = _ref;
  return typed3(name101, {
    "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      var matrixRes = multiply(rotationMatrix(theta), w);
      return matrixRes.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      return multiply(rotationMatrix(theta), w);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      var matrixRes = multiply(rotationMatrix(theta, v), w);
      return matrixRes;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      return multiply(rotationMatrix(theta, v), w);
    }
  });
  function _validateSize(v, expectedSize) {
    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
    if (actualSize.length > 2) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize.length === 2 && actualSize[1] !== 1) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize[0] !== expectedSize) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
var name102 = "rotationMatrix";
var dependencies102 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
var createRotationMatrix = /* @__PURE__ */ factory(name102, dependencies102, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    multiplyScalar,
    addScalar,
    unaryMinus,
    norm,
    BigNumber: BigNumber2,
    matrix,
    DenseMatrix: DenseMatrix2,
    SparseMatrix,
    cos: cos3,
    sin: sin3
  } = _ref;
  return typed3(name102, {
    "": function _() {
      return config4.matrix === "Matrix" ? matrix([]) : [];
    },
    string: function string(format6) {
      return matrix(format6);
    },
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
      return _rotationMatrix2x2(theta, config4.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format6) {
      return _rotationMatrix2x2(theta, format6);
    },
    "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
      var matrixV = matrix(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, void 0);
    },
    "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
      _validateVector(v);
      var storageType = v.storage() || (config4.matrix === "Matrix" ? "dense" : void 0);
      return _rotationMatrix3x3(theta, v, storageType);
    },
    "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format6) {
      var matrixV = matrix(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, format6);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format6) {
      _validateVector(v);
      return _rotationMatrix3x3(theta, v, format6);
    }
  });
  function _rotationMatrix2x2(theta, format6) {
    var Big = isBigNumber(theta);
    var minusOne = Big ? new BigNumber2(-1) : -1;
    var cosTheta = cos3(theta);
    var sinTheta = sin3(theta);
    var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];
    return _convertToFormat(data, format6);
  }
  function _validateVector(v) {
    var size = v.size();
    if (size.length < 1 || size[0] !== 3) {
      throw new RangeError("Vector must be of dimensions 1x3");
    }
  }
  function _mul(array2) {
    return array2.reduce((p, curr) => multiplyScalar(p, curr));
  }
  function _convertToFormat(data, format6) {
    if (format6) {
      if (format6 === "sparse") {
        return new SparseMatrix(data);
      }
      if (format6 === "dense") {
        return new DenseMatrix2(data);
      }
      throw new TypeError('Unknown matrix type "'.concat(format6, '"'));
    }
    return data;
  }
  function _rotationMatrix3x3(theta, v, format6) {
    var normV = norm(v);
    if (normV === 0) {
      throw new RangeError("Rotation around zero vector");
    }
    var Big = isBigNumber(theta) ? BigNumber2 : null;
    var one2 = Big ? new Big(1) : 1;
    var minusOne = Big ? new Big(-1) : -1;
    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
    var c2 = cos3(theta);
    var oneMinusC = addScalar(one2, unaryMinus(c2));
    var s2 = sin3(theta);
    var r11 = addScalar(c2, _mul([vx, vx, oneMinusC]));
    var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s2]));
    var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s2]));
    var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s2]));
    var r22 = addScalar(c2, _mul([vy, vy, oneMinusC]));
    var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s2]));
    var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s2]));
    var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s2]));
    var r33 = addScalar(c2, _mul([vz, vz, oneMinusC]));
    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
    return _convertToFormat(data, format6);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/row.js
var name103 = "row";
var dependencies103 = ["typed", "Index", "matrix", "range"];
var createRow = /* @__PURE__ */ factory(name103, dependencies103, (_ref) => {
  var {
    typed: typed3,
    Index,
    matrix,
    range: range2
  } = _ref;
  return typed3(name103, {
    "Matrix, number": _row,
    "Array, number": function ArrayNumber(value, row) {
      return _row(matrix(clone(value)), row).valueOf();
    }
  });
  function _row(value, row) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(row, value.size()[0]);
    var columnRange = range2(0, value.size()[1]);
    var index = new Index(row, columnRange);
    var result = value.subset(index);
    return isMatrix(result) ? result : matrix([[result]]);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/size.js
var name104 = "size";
var dependencies104 = ["typed", "config", "?matrix"];
var createSize = /* @__PURE__ */ factory(name104, dependencies104, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix
  } = _ref;
  return typed3(name104, {
    Matrix: function Matrix2(x2) {
      return x2.create(x2.size());
    },
    Array: arraySize,
    string: function string(x2) {
      return config4.matrix === "Array" ? [x2.length] : matrix([x2.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x2) {
      return config4.matrix === "Array" ? [] : matrix ? matrix([]) : noMatrix();
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/squeeze.js
var name105 = "squeeze";
var dependencies105 = ["typed", "matrix"];
var createSqueeze = /* @__PURE__ */ factory(name105, dependencies105, (_ref) => {
  var {
    typed: typed3,
    matrix
  } = _ref;
  return typed3(name105, {
    Array: function Array2(x2) {
      return squeeze(clone(x2));
    },
    Matrix: function Matrix2(x2) {
      var res = squeeze(x2.toArray());
      return Array.isArray(res) ? matrix(res) : res;
    },
    any: function any(x2) {
      return clone(x2);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/subset.js
var name106 = "subset";
var dependencies106 = ["typed", "matrix", "zeros", "add"];
var createSubset = /* @__PURE__ */ factory(name106, dependencies106, (_ref) => {
  var {
    typed: typed3,
    matrix,
    zeros: zeros2,
    add: add2
  } = _ref;
  return typed3(name106, {
    // get subset
    "Matrix, Index": function MatrixIndex(value, index) {
      if (isEmptyIndex(index)) {
        return matrix();
      }
      validateIndexSourceSize(value, index);
      return value.subset(index);
    },
    "Array, Index": typed3.referTo("Matrix, Index", function(subsetRef) {
      return function(value, index) {
        var subsetResult = subsetRef(matrix(value), index);
        return index.isScalar() ? subsetResult : subsetResult.valueOf();
      };
    }),
    "Object, Index": _getObjectProperty,
    "string, Index": _getSubstring,
    // set subset
    "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index, replacement, defaultValue) {
      if (isEmptyIndex(index)) {
        return value;
      }
      validateIndexSourceSize(value, index);
      return value.clone().subset(index, _broadcastReplacement(replacement, index), defaultValue);
    },
    "Array, Index, any, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index, replacement, defaultValue) {
        var subsetResult = subsetRef(matrix(value), index, replacement, defaultValue);
        return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
      };
    }),
    "Array, Index, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index, replacement) {
        return subsetRef(matrix(value), index, replacement, void 0).valueOf();
      };
    }),
    "Matrix, Index, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index, replacement) {
        return subsetRef(value, index, replacement, void 0);
      };
    }),
    "string, Index, string": _setSubstring,
    "string, Index, string, string": _setSubstring,
    "Object, Index, any": _setObjectProperty
  });
  function _broadcastReplacement(replacement, index) {
    if (typeof replacement === "string") {
      throw new Error("can't boradcast a string");
    }
    if (index._isScalar) {
      return replacement;
    }
    var indexSize = index.size();
    if (indexSize.every((d) => d > 0)) {
      try {
        return add2(replacement, zeros2(indexSize));
      } catch (error) {
        return replacement;
      }
    } else {
      return replacement;
    }
  }
});
function _getSubstring(str, index) {
  if (!isIndex(index)) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index)) {
    return "";
  }
  validateIndexSourceSize(Array.from(str), index);
  if (index.size().length !== 1) {
    throw new DimensionError(index.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index.min()[0], strLen);
  validateIndex(index.max()[0], strLen);
  var range2 = index.dimension(0);
  var substr = "";
  range2.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
}
function _setSubstring(str, index, replacement, defaultValue) {
  if (!index || index.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index)) {
    return str;
  }
  validateIndexSourceSize(Array.from(str), index);
  if (index.size().length !== 1) {
    throw new DimensionError(index.size().length, 1);
  }
  if (defaultValue !== void 0) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range2 = index.dimension(0);
  var len = range2.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range2.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index.min()[0]);
  validateIndex(index.max()[0]);
  var chars = [];
  for (var i = 0; i < strLen; i++) {
    chars[i] = str.charAt(i);
  }
  range2.forEach(function(v, i2) {
    chars[v] = replacement.charAt(i2[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index) {
  if (isEmptyIndex(index)) {
    return void 0;
  }
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }
  var key = index.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index, replacement) {
  if (isEmptyIndex(index)) {
    return object;
  }
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }
  var key = index.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}

// node_modules/mathjs/lib/esm/function/matrix/transpose.js
var name107 = "transpose";
var dependencies107 = ["typed", "matrix"];
var createTranspose = /* @__PURE__ */ factory(name107, dependencies107, (_ref) => {
  var {
    typed: typed3,
    matrix
  } = _ref;
  return typed3(name107, {
    Array: (x2) => transposeMatrix(matrix(x2)).valueOf(),
    Matrix: transposeMatrix,
    any: clone
    // scalars
  });
  function transposeMatrix(x2) {
    var size = x2.size();
    var c2;
    switch (size.length) {
      case 1:
        c2 = x2.clone();
        break;
      case 2:
        {
          var rows = size[0];
          var columns = size[1];
          if (columns === 0) {
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size) + ")");
          }
          switch (x2.storage()) {
            case "dense":
              c2 = _denseTranspose(x2, rows, columns);
              break;
            case "sparse":
              c2 = _sparseTranspose(x2, rows, columns);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(size) + ")");
    }
    return c2;
  }
  function _denseTranspose(m, rows, columns) {
    var data = m._data;
    var transposed = [];
    var transposedRow;
    for (var j = 0; j < columns; j++) {
      transposedRow = transposed[j] = [];
      for (var i = 0; i < rows; i++) {
        transposedRow[i] = clone(data[i][j]);
      }
    }
    return m.createDenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
  function _sparseTranspose(m, rows, columns) {
    var values2 = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var cvalues = values2 ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var w = [];
    for (var x2 = 0; x2 < rows; x2++) {
      w[x2] = 0;
    }
    var p, l, j;
    for (p = 0, l = index.length; p < l; p++) {
      w[index[p]]++;
    }
    var sum3 = 0;
    for (var i = 0; i < rows; i++) {
      cptr.push(sum3);
      sum3 += w[i];
      w[i] = cptr[i];
    }
    cptr.push(sum3);
    for (j = 0; j < columns; j++) {
      for (var k0 = ptr[j], k1 = ptr[j + 1], k2 = k0; k2 < k1; k2++) {
        var q = w[index[k2]]++;
        cindex[q] = j;
        if (values2) {
          cvalues[q] = clone(values2[k2]);
        }
      }
    }
    return m.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
var name108 = "ctranspose";
var dependencies108 = ["typed", "transpose", "conj"];
var createCtranspose = /* @__PURE__ */ factory(name108, dependencies108, (_ref) => {
  var {
    typed: typed3,
    transpose,
    conj
  } = _ref;
  return typed3(name108, {
    any: function any(x2) {
      return conj(transpose(x2));
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/zeros.js
var name109 = "zeros";
var dependencies109 = ["typed", "config", "matrix", "BigNumber"];
var createZeros = /* @__PURE__ */ factory(name109, dependencies109, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    BigNumber: BigNumber2
  } = _ref;
  return typed3(name109, {
    "": function _() {
      return config4.matrix === "Array" ? _zeros([]) : _zeros([], "default");
    },
    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function numberBigNumberString(size) {
      var last = size[size.length - 1];
      if (typeof last === "string") {
        var format6 = size.pop();
        return _zeros(size, format6);
      } else if (config4.matrix === "Array") {
        return _zeros(size);
      } else {
        return _zeros(size, "default");
      }
    },
    Array: _zeros,
    Matrix: function Matrix2(size) {
      var format6 = size.storage();
      return _zeros(size.valueOf(), format6);
    },
    "Array | Matrix, string": function ArrayMatrixString(size, format6) {
      return _zeros(size.valueOf(), format6);
    }
  });
  function _zeros(size, format6) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
    _validate2(size);
    if (format6) {
      var m = matrix(format6);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function(value, index, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size) {
    size.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function zeros must be positive integers");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/fft.js
var name110 = "fft";
var dependencies110 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
var createFft = /* @__PURE__ */ factory(name110, dependencies110, (_ref) => {
  var {
    typed: typed3,
    matrix,
    addScalar,
    multiplyScalar,
    divideScalar,
    exp: exp2,
    tau: tau4,
    i: I,
    dotDivide,
    conj,
    pow: pow3,
    ceil: ceil2,
    log2: log24
  } = _ref;
  return typed3(name110, {
    Array: _ndFft,
    Matrix: function Matrix2(matrix2) {
      return matrix2.create(_ndFft(matrix2.toArray()));
    }
  });
  function _ndFft(arr) {
    var size = arraySize(arr);
    if (size.length === 1)
      return _fft(arr, size[0]);
    return _1dFft(arr.map((slice2) => _ndFft(slice2, size.slice(1))), 0);
  }
  function _1dFft(arr, dim) {
    var size = arraySize(arr);
    if (dim !== 0)
      return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));
    if (size.length === 1)
      return _fft(arr);
    function _transpose(arr2) {
      var size2 = arraySize(arr2);
      return new Array(size2[1]).fill(0).map((_, j) => new Array(size2[0]).fill(0).map((_2, i) => arr2[i][j]));
    }
    return _transpose(_1dFft(_transpose(arr), 1));
  }
  function _czt(arr) {
    var n = arr.length;
    var w = exp2(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau4)), n));
    var chirp = [];
    for (var i = 1 - n; i < n; i++) {
      chirp.push(pow3(w, divideScalar(pow3(i, 2), 2)));
    }
    var N2 = pow3(2, ceil2(log24(n + n - 1)));
    var xp = [...new Array(n).fill(0).map((_, i2) => multiplyScalar(arr[i2], chirp[n - 1 + i2])), ...new Array(N2 - n).fill(0)];
    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i2) => divideScalar(1, chirp[i2])), ...new Array(N2 - (n + n - 1)).fill(0)];
    var fftXp = _fft(xp);
    var fftIchirp = _fft(ichirp);
    var fftProduct = new Array(N2).fill(0).map((_, i2) => multiplyScalar(fftXp[i2], fftIchirp[i2]));
    var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);
    var ret = [];
    for (var _i = n - 1; _i < n + n - 1; _i++) {
      ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));
    }
    return ret;
  }
  function _fft(arr) {
    var len = arr.length;
    if (len === 1)
      return [arr[0]];
    if (len % 2 === 0) {
      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];
      for (var k2 = 0; k2 < len / 2; k2++) {
        var p = ret[k2];
        var q = multiplyScalar(ret[k2 + len / 2], exp2(multiplyScalar(multiplyScalar(tau4, I), divideScalar(-k2, len))));
        ret[k2] = addScalar(p, q);
        ret[k2 + len / 2] = addScalar(p, multiplyScalar(-1, q));
      }
      return ret;
    } else {
      return _czt(arr);
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ifft.js
var name111 = "ifft";
var dependencies111 = ["typed", "fft", "dotDivide", "conj"];
var createIfft = /* @__PURE__ */ factory(name111, dependencies111, (_ref) => {
  var {
    typed: typed3,
    fft,
    dotDivide,
    conj
  } = _ref;
  return typed3(name111, {
    "Array | Matrix": function ArrayMatrix(arr) {
      var size = isMatrix(arr) ? arr.size() : arraySize(arr);
      return dotDivide(conj(fft(conj(arr))), size.reduce((acc, curr) => acc * curr, 1));
    }
  });
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t)
    return t;
  var e3 = t[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t, r || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e3, r, t) {
  return (r = toPropertyKey(r)) in e3 ? Object.defineProperty(e3, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r] = t, e3;
}

// node_modules/mathjs/lib/esm/function/numeric/solveODE.js
function ownKeys(e3, r) {
  var t = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e3);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e3) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e3, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e3;
}
var name112 = "solveODE";
var dependencies112 = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"];
var createSolveODE = /* @__PURE__ */ factory(name112, dependencies112, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    max: max4,
    map: map3,
    abs: abs3,
    isPositive,
    isNegative,
    larger,
    smaller,
    matrix,
    bignumber,
    unaryMinus
  } = _ref;
  function _rk(butcherTableau) {
    return function(f, tspan, y0, options) {
      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
      if (wrongTSpan) {
        throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
      }
      var t03 = tspan[0];
      var tf = tspan[1];
      var isForwards = larger(tf, t03);
      var firstStep = options.firstStep;
      if (firstStep !== void 0 && !isPositive(firstStep)) {
        throw new Error('"firstStep" must be positive');
      }
      var maxStep = options.maxStep;
      if (maxStep !== void 0 && !isPositive(maxStep)) {
        throw new Error('"maxStep" must be positive');
      }
      var minStep = options.minStep;
      if (minStep && isNegative(minStep)) {
        throw new Error('"minStep" must be positive or zero');
      }
      var timeVars = [t03, tf, firstStep, minStep, maxStep].filter((x2) => x2 !== void 0);
      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
        throw new Error('Inconsistent type of "t" dependant variables');
      }
      var steps = 1;
      var tol = options.tol ? options.tol : 1e-4;
      var minDelta = options.minDelta ? options.minDelta : 0.2;
      var maxDelta = options.maxDelta ? options.maxDelta : 5;
      var maxIter = options.maxIter ? options.maxIter : 1e4;
      var hasBigNumbers = [t03, tf, ...y0, maxStep, minStep].some(isBigNumber);
      var [a2, c2, b, bp] = hasBigNumbers ? [bignumber(butcherTableau.a), bignumber(butcherTableau.c), bignumber(butcherTableau.b), bignumber(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];
      var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide2(subtract(tf, t03), steps);
      var t = [t03];
      var y2 = [y0];
      var deltaB = subtract(b, bp);
      var n = 0;
      var iter = 0;
      var ongoing = _createOngoing(isForwards);
      var trimStep = _createTrimStep(isForwards);
      while (ongoing(t[n], tf)) {
        var k2 = [];
        h = trimStep(t[n], tf, h);
        k2.push(f(t[n], y2[n]));
        for (var i = 1; i < c2.length; ++i) {
          k2.push(f(add2(t[n], multiply(c2[i], h)), add2(y2[n], multiply(h, a2[i], k2))));
        }
        var TE = max4(abs3(map3(multiply(deltaB, k2), (X) => isUnit(X) ? X.value : X)));
        if (TE < tol && tol / TE > 1 / 4) {
          t.push(add2(t[n], h));
          y2.push(add2(y2[n], multiply(h, b, k2)));
          n++;
        }
        var delta = 0.84 * (tol / TE) ** (1 / 5);
        if (smaller(delta, minDelta)) {
          delta = minDelta;
        } else if (larger(delta, maxDelta)) {
          delta = maxDelta;
        }
        delta = hasBigNumbers ? bignumber(delta) : delta;
        h = multiply(h, delta);
        if (maxStep && larger(abs3(h), maxStep)) {
          h = isForwards ? maxStep : unaryMinus(maxStep);
        } else if (minStep && smaller(abs3(h), minStep)) {
          h = isForwards ? minStep : unaryMinus(minStep);
        }
        iter++;
        if (iter > maxIter) {
          throw new Error("Maximum number of iterations reached, try changing options");
        }
      }
      return {
        t,
        y: y2
      };
    };
  }
  function _rk23(f, tspan, y0, options) {
    var a2 = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
    var c2 = [null, 1 / 2, 3 / 4, 1];
    var b = [2 / 9, 1 / 3, 4 / 9, 0];
    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
    var butcherTableau = {
      a: a2,
      c: c2,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options);
  }
  function _rk45(f, tspan, y0, options) {
    var a2 = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
    var c2 = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
    var butcherTableau = {
      a: a2,
      c: c2,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options);
  }
  function _solveODE(f, tspan, y0, opt) {
    var method = opt.method ? opt.method : "RK45";
    var methods = {
      RK23: _rk23,
      RK45: _rk45
    };
    if (method.toUpperCase() in methods) {
      var methodOptions = _objectSpread({}, opt);
      delete methodOptions.method;
      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
    } else {
      var methodsWithQuotes = Object.keys(methods).map((x2) => '"'.concat(x2, '"'));
      var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(", "), " and ").concat(methodsWithQuotes.slice(-1));
      throw new Error('Unavailable method "'.concat(method, '". Available methods are ').concat(availableMethodsString));
    }
  }
  function _createOngoing(isForwards) {
    return isForwards ? smaller : larger;
  }
  function _createTrimStep(isForwards) {
    var outOfBounds = isForwards ? larger : smaller;
    return function(t, tf, h) {
      var next = add2(t, h);
      return outOfBounds(next, tf) ? subtract(tf, t) : h;
    };
  }
  function isNumOrBig(x2) {
    return isBigNumber(x2) || isNumber(x2);
  }
  function _matrixSolveODE(f, T, y0, options) {
    var sol = _solveODE(f, T.toArray(), y0.toArray(), options);
    return {
      t: matrix(sol.t),
      y: matrix(sol.y)
    };
  }
  return typed3("solveODE", {
    "function, Array, Array, Object": _solveODE,
    "function, Matrix, Matrix, Object": _matrixSolveODE,
    "function, Array, Array": (f, T, y0) => _solveODE(f, T, y0, {}),
    "function, Matrix, Matrix": (f, T, y0) => _matrixSolveODE(f, T, y0, {}),
    "function, Array, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T, [y0], {});
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T.toArray(), [y0], {});
      return {
        t: matrix(sol.t),
        y: matrix(sol.y.map((Y) => Y[0]))
      };
    },
    "function, Array, number | BigNumber | Unit, Object": (f, T, y0, options) => {
      var sol = _solveODE(f, T, [y0], options);
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit, Object": (f, T, y0, options) => {
      var sol = _solveODE(f, T.toArray(), [y0], options);
      return {
        t: matrix(sol.t),
        y: matrix(sol.y.map((Y) => Y[0]))
      };
    }
  });
});

// node_modules/mathjs/lib/esm/function/special/erf.js
var name113 = "erf";
var dependencies113 = ["typed"];
var createErf = /* @__PURE__ */ factory(name113, dependencies113, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("name", {
    number: function number5(x2) {
      var y2 = Math.abs(x2);
      if (y2 >= MAX_NUM) {
        return sign(x2);
      }
      if (y2 <= THRESH) {
        return sign(x2) * erf1(y2);
      }
      if (y2 <= 4) {
        return sign(x2) * (1 - erfc2(y2));
      }
      return sign(x2) * (1 - erfc3(y2));
    },
    "Array | Matrix": typed3.referToSelf((self2) => (n) => deepMap(n, self2))
    // TODO: For complex numbers, use the approximation for the Faddeeva function
    //  from "More Efficient Computation of the Complex Error Function" (AMS)
  });
  function erf1(y2) {
    var ysq = y2 * y2;
    var xnum = P2[0][4] * ysq;
    var xden = ysq;
    var i;
    for (i = 0; i < 3; i += 1) {
      xnum = (xnum + P2[0][i]) * ysq;
      xden = (xden + Q[0][i]) * ysq;
    }
    return y2 * (xnum + P2[0][3]) / (xden + Q[0][3]);
  }
  function erfc2(y2) {
    var xnum = P2[1][8] * y2;
    var xden = y2;
    var i;
    for (i = 0; i < 7; i += 1) {
      xnum = (xnum + P2[1][i]) * y2;
      xden = (xden + Q[1][i]) * y2;
    }
    var result = (xnum + P2[1][7]) / (xden + Q[1][7]);
    var ysq = parseInt(y2 * 16) / 16;
    var del = (y2 - ysq) * (y2 + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
  function erfc3(y2) {
    var ysq = 1 / (y2 * y2);
    var xnum = P2[2][5] * ysq;
    var xden = ysq;
    var i;
    for (i = 0; i < 4; i += 1) {
      xnum = (xnum + P2[2][i]) * ysq;
      xden = (xden + Q[2][i]) * ysq;
    }
    var result = ysq * (xnum + P2[2][4]) / (xden + Q[2][4]);
    result = (SQRPI - result) / y2;
    ysq = parseInt(y2 * 16) / 16;
    var del = (y2 - ysq) * (y2 + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
});
var THRESH = 0.46875;
var SQRPI = 0.5641895835477563;
var P2 = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
var MAX_NUM = Math.pow(2, 53);

// node_modules/mathjs/lib/esm/function/special/zeta.js
var name114 = "zeta";
var dependencies114 = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"];
var createZeta = /* @__PURE__ */ factory(name114, dependencies114, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    multiply,
    pow: pow3,
    divide: divide2,
    factorial,
    equal,
    smallerEq,
    isNegative,
    gamma: gamma2,
    sin: sin3,
    subtract,
    add: add2,
    Complex: Complex3,
    BigNumber: _BigNumber,
    pi: pi4
  } = _ref;
  return typed3(name114, {
    number: (s2) => zetaNumeric(s2, (value) => value, () => 20),
    BigNumber: (s2) => zetaNumeric(s2, (value) => new _BigNumber(value), () => {
      return Math.abs(Math.log10(config4.epsilon));
    }),
    Complex: zetaComplex
  });
  function zetaNumeric(s2, createValue, determineDigits) {
    if (equal(s2, 0)) {
      return createValue(-0.5);
    }
    if (equal(s2, 1)) {
      return createValue(NaN);
    }
    if (!isFinite(s2)) {
      return isNegative(s2) ? createValue(NaN) : createValue(1);
    }
    return zeta(s2, createValue, determineDigits, (s3) => s3);
  }
  function zetaComplex(s2) {
    if (s2.re === 0 && s2.im === 0) {
      return new Complex3(-0.5);
    }
    if (s2.re === 1) {
      return new Complex3(NaN, NaN);
    }
    if (s2.re === Infinity && s2.im === 0) {
      return new Complex3(1);
    }
    if (s2.im === Infinity || s2.re === -Infinity) {
      return new Complex3(NaN, NaN);
    }
    return zeta(s2, (value) => value, (s3) => Math.round(1.3 * 15 + 0.9 * Math.abs(s3.im)), (s3) => s3.re);
  }
  function zeta(s2, createValue, determineDigits, getRe) {
    var n = determineDigits(s2);
    if (getRe(s2) > -(n - 1) / 2) {
      return f(s2, createValue(n), createValue);
    } else {
      var c2 = multiply(pow3(2, s2), pow3(createValue(pi4), subtract(s2, 1)));
      c2 = multiply(c2, sin3(multiply(divide2(createValue(pi4), 2), s2)));
      c2 = multiply(c2, gamma2(subtract(1, s2)));
      return multiply(c2, zeta(subtract(1, s2), createValue, determineDigits, getRe));
    }
  }
  function d(k2, n) {
    var S = k2;
    for (var j = k2; smallerEq(j, n); j = add2(j, 1)) {
      var factor = divide2(multiply(factorial(add2(n, subtract(j, 1))), pow3(4, j)), multiply(factorial(subtract(n, j)), factorial(multiply(2, j))));
      S = add2(S, factor);
    }
    return multiply(n, S);
  }
  function f(s2, n, createValue) {
    var c2 = divide2(1, multiply(d(createValue(0), n), subtract(1, pow3(2, subtract(1, s2)))));
    var S = createValue(0);
    for (var k2 = createValue(1); smallerEq(k2, n); k2 = add2(k2, 1)) {
      S = add2(S, divide2(multiply((-1) ** (k2 - 1), d(k2, n)), pow3(k2, s2)));
    }
    return multiply(c2, S);
  }
});

// node_modules/mathjs/lib/esm/function/statistics/mode.js
var name115 = "mode";
var dependencies115 = ["typed", "isNaN", "isNumeric"];
var createMode = /* @__PURE__ */ factory(name115, dependencies115, (_ref) => {
  var {
    typed: typed3,
    isNaN: isNaN2,
    isNumeric
  } = _ref;
  return typed3(name115, {
    "Array | Matrix": _mode,
    "...": function _(args) {
      return _mode(args);
    }
  });
  function _mode(values2) {
    values2 = flatten(values2.valueOf());
    var num = values2.length;
    if (num === 0) {
      throw new Error("Cannot calculate mode of an empty array");
    }
    var count = {};
    var mode = [];
    var max4 = 0;
    for (var i = 0; i < values2.length; i++) {
      var value = values2[i];
      if (isNumeric(value) && isNaN2(value)) {
        throw new Error("Cannot calculate mode of an array containing NaN values");
      }
      if (!(value in count)) {
        count[value] = 0;
      }
      count[value]++;
      if (count[value] === max4) {
        mode.push(value);
      } else if (count[value] > max4) {
        max4 = count[value];
        mode = [value];
      }
    }
    return mode;
  }
});

// node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
function improveErrorMessage(err, fnName, value) {
  var details;
  if (String(err).indexOf("Unexpected type") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
    return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
  }
  if (String(err).indexOf("complex numbers") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
    return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
  }
  return err;
}

// node_modules/mathjs/lib/esm/function/statistics/prod.js
var name116 = "prod";
var dependencies116 = ["typed", "config", "multiplyScalar", "numeric"];
var createProd = /* @__PURE__ */ factory(name116, dependencies116, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    multiplyScalar,
    numeric: numeric2
  } = _ref;
  return typed3(name116, {
    // prod([a, b, c, d, ...])
    "Array | Matrix": _prod,
    // prod([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array2, dim) {
      throw new Error("prod(A, dim) is not yet supported");
    },
    // prod(a, b, c, d, ...)
    "...": function _(args) {
      return _prod(args);
    }
  });
  function _prod(array2) {
    var prod;
    deepForEach(array2, function(value) {
      try {
        prod = prod === void 0 ? value : multiplyScalar(prod, value);
      } catch (err) {
        throw improveErrorMessage(err, "prod", value);
      }
    });
    if (typeof prod === "string") {
      prod = numeric2(prod, config4.number);
    }
    if (prod === void 0) {
      throw new Error("Cannot calculate prod of an empty array");
    }
    return prod;
  }
});

// node_modules/mathjs/lib/esm/function/string/format.js
var name117 = "format";
var dependencies117 = ["typed"];
var createFormat = /* @__PURE__ */ factory(name117, dependencies117, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name117, {
    any: format3,
    "any, Object | function | number": format3
  });
});

// node_modules/mathjs/lib/esm/function/string/bin.js
var name118 = "bin";
var dependencies118 = ["typed", "format"];
var createBin = factory(name118, dependencies118, (_ref) => {
  var {
    typed: typed3,
    format: format6
  } = _ref;
  return typed3(name118, {
    "number | BigNumber": function numberBigNumber(n) {
      return format6(n, {
        notation: "bin"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format6(n, {
        notation: "bin",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/oct.js
var name119 = "oct";
var dependencies119 = ["typed", "format"];
var createOct = factory(name119, dependencies119, (_ref) => {
  var {
    typed: typed3,
    format: format6
  } = _ref;
  return typed3(name119, {
    "number | BigNumber": function numberBigNumber(n) {
      return format6(n, {
        notation: "oct"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format6(n, {
        notation: "oct",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/hex.js
var name120 = "hex";
var dependencies120 = ["typed", "format"];
var createHex = factory(name120, dependencies120, (_ref) => {
  var {
    typed: typed3,
    format: format6
  } = _ref;
  return typed3(name120, {
    "number | BigNumber": function numberBigNumber(n) {
      return format6(n, {
        notation: "hex"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format6(n, {
        notation: "hex",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/utils/print.js
var printTemplate = /\$([\w.]+)/g;

// node_modules/mathjs/lib/esm/function/string/print.js
var name121 = "print";
var dependencies121 = ["typed"];
var createPrint = /* @__PURE__ */ factory(name121, dependencies121, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name121, {
    // note: Matrix will be converted automatically to an Array
    "string, Object | Array": _print,
    "string, Object | Array, number | Object": _print
  });
});
function _print(template, values2, options) {
  return template.replace(printTemplate, function(original, key) {
    var keys = key.split(".");
    var value = values2[keys.shift()];
    if (value !== void 0 && value.isMatrix) {
      value = value.toArray();
    }
    while (keys.length && value !== void 0) {
      var k2 = keys.shift();
      value = k2 ? value[k2] : value + ".";
    }
    if (value !== void 0) {
      if (!isString(value)) {
        return format3(value, options);
      } else {
        return value;
      }
    }
    return original;
  });
}

// node_modules/mathjs/lib/esm/function/unit/to.js
var name122 = "to";
var dependencies122 = ["typed", "matrix", "concat"];
var createTo = /* @__PURE__ */ factory(name122, dependencies122, (_ref) => {
  var {
    typed: typed3,
    matrix,
    concat: concat2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name122, {
    "Unit, Unit | string": (x2, unit2) => x2.to(unit2)
  }, matrixAlgorithmSuite({
    Ds: true
  }));
});

// node_modules/mathjs/lib/esm/function/utils/isPrime.js
var name123 = "isPrime";
var dependencies123 = ["typed"];
var createIsPrime = /* @__PURE__ */ factory(name123, dependencies123, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name123, {
    number: function number5(x2) {
      if (x2 * 0 !== 0) {
        return false;
      }
      if (x2 <= 3) {
        return x2 > 1;
      }
      if (x2 % 2 === 0 || x2 % 3 === 0) {
        return false;
      }
      for (var i = 5; i * i <= x2; i += 6) {
        if (x2 % i === 0 || x2 % (i + 2) === 0) {
          return false;
        }
      }
      return true;
    },
    BigNumber: function BigNumber2(n) {
      if (n.toNumber() * 0 !== 0) {
        return false;
      }
      if (n.lte(3))
        return n.gt(1);
      if (n.mod(2).eq(0) || n.mod(3).eq(0))
        return false;
      if (n.lt(Math.pow(2, 32))) {
        var x2 = n.toNumber();
        for (var i = 5; i * i <= x2; i += 6) {
          if (x2 % i === 0 || x2 % (i + 2) === 0) {
            return false;
          }
        }
        return true;
      }
      function modPow(base, exponent, modulus) {
        var accumulator = 1;
        while (!exponent.eq(0)) {
          if (exponent.mod(2).eq(0)) {
            exponent = exponent.div(2);
            base = base.mul(base).mod(modulus);
          } else {
            exponent = exponent.sub(1);
            accumulator = base.mul(accumulator).mod(modulus);
          }
        }
        return accumulator;
      }
      var Decimal2 = n.constructor.clone({
        precision: n.toFixed(0).length * 2
      });
      n = new Decimal2(n);
      var r = 0;
      var d = n.sub(1);
      while (d.mod(2).eq(0)) {
        d = d.div(2);
        r += 1;
      }
      var bases = null;
      if (n.lt("3317044064679887385961981")) {
        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x3) => x3 < n);
      } else {
        var max4 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
        bases = [];
        for (var _i = 2; _i <= max4; _i += 1) {
          bases.push(max4);
        }
      }
      for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
        var a2 = bases[_i2];
        var adn = modPow(n.sub(n).add(a2), d, n);
        if (!adn.eq(1)) {
          for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
            if (_i3 === r - 1) {
              return false;
            }
          }
        }
      }
      return true;
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/numeric.js
var name124 = "numeric";
var dependencies124 = ["number", "?bignumber", "?fraction"];
var createNumeric = /* @__PURE__ */ factory(name124, dependencies124, (_ref) => {
  var {
    number: _number,
    bignumber,
    fraction
  } = _ref;
  var validInputTypes = {
    string: true,
    number: true,
    BigNumber: true,
    Fraction: true
  };
  var validOutputTypes = {
    number: (x2) => _number(x2),
    BigNumber: bignumber ? (x2) => bignumber(x2) : noBignumber,
    Fraction: fraction ? (x2) => fraction(x2) : noFraction
  };
  return function numeric2(value) {
    var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number";
    var check = arguments.length > 2 ? arguments[2] : void 0;
    if (check !== void 0) {
      throw new SyntaxError("numeric() takes one or two arguments");
    }
    var inputType = typeOf(value);
    if (!(inputType in validInputTypes)) {
      throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
    }
    if (!(outputType in validOutputTypes)) {
      throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
    }
    if (outputType === inputType) {
      return value;
    } else {
      return validOutputTypes[outputType](value);
    }
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
var name125 = "divideScalar";
var dependencies125 = ["typed", "numeric"];
var createDivideScalar = /* @__PURE__ */ factory(name125, dependencies125, (_ref) => {
  var {
    typed: typed3,
    numeric: numeric2
  } = _ref;
  return typed3(name125, {
    "number, number": function numberNumber(x2, y2) {
      return x2 / y2;
    },
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return x2.div(y2);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.div(y2);
    },
    "Fraction, Fraction": function FractionFraction(x2, y2) {
      return x2.div(y2);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (x2, y2) => x2.divide(y2),
    "number | Fraction | Complex | BigNumber, Unit": (x2, y2) => y2.divideInto(x2)
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/pow.js
var name126 = "pow";
var dependencies126 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
var createPow = /* @__PURE__ */ factory(name126, dependencies126, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    identity: identity5,
    multiply,
    matrix,
    inv,
    number: number5,
    fraction,
    Complex: Complex3
  } = _ref;
  return typed3(name126, {
    "number, number": _pow,
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return x2.pow(y2);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      if (y2.isInteger() || x2 >= 0 || config4.predictable) {
        return x2.pow(y2);
      } else {
        return new Complex3(x2.toNumber(), 0).pow(y2.toNumber(), 0);
      }
    },
    "Fraction, Fraction": function FractionFraction(x2, y2) {
      var result = x2.pow(y2);
      if (result != null) {
        return result;
      }
      if (config4.predictable) {
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      } else {
        return _pow(x2.valueOf(), y2.valueOf());
      }
    },
    "Array, number": _powArray,
    "Array, BigNumber": function ArrayBigNumber(x2, y2) {
      return _powArray(x2, y2.toNumber());
    },
    "Matrix, number": _powMatrix,
    "Matrix, BigNumber": function MatrixBigNumber(x2, y2) {
      return _powMatrix(x2, y2.toNumber());
    },
    "Unit, number | BigNumber": function UnitNumberBigNumber(x2, y2) {
      return x2.pow(y2);
    }
  });
  function _pow(x2, y2) {
    if (config4.predictable && !isInteger(y2) && x2 < 0) {
      try {
        var yFrac = fraction(y2);
        var yNum = number5(yFrac);
        if (y2 === yNum || Math.abs((y2 - yNum) / y2) < 1e-14) {
          if (yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x2, y2);
          }
        }
      } catch (ex) {
      }
    }
    if (config4.predictable && (x2 < -1 && y2 === Infinity || x2 > -1 && x2 < 0 && y2 === -Infinity)) {
      return NaN;
    }
    if (isInteger(y2) || x2 >= 0 || config4.predictable) {
      return powNumber(x2, y2);
    } else {
      if (x2 * x2 < 1 && y2 === Infinity || x2 * x2 > 1 && y2 === -Infinity) {
        return 0;
      }
      return new Complex3(x2, 0).pow(y2, 0);
    }
  }
  function _powArray(x2, y2) {
    if (!isInteger(y2)) {
      throw new TypeError("For A^b, b must be an integer (value is " + y2 + ")");
    }
    var s2 = arraySize(x2);
    if (s2.length !== 2) {
      throw new Error("For A^b, A must be 2 dimensional (A has " + s2.length + " dimensions)");
    }
    if (s2[0] !== s2[1]) {
      throw new Error("For A^b, A must be square (size is " + s2[0] + "x" + s2[1] + ")");
    }
    if (y2 < 0) {
      try {
        return _powArray(inv(x2), -y2);
      } catch (error) {
        if (error.message === "Cannot calculate inverse, determinant is zero") {
          throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y2 + ")");
        }
        throw error;
      }
    }
    var res = identity5(s2[0]).valueOf();
    var px = x2;
    while (y2 >= 1) {
      if ((y2 & 1) === 1) {
        res = multiply(px, res);
      }
      y2 >>= 1;
      px = multiply(px, px);
    }
    return res;
  }
  function _powMatrix(x2, y2) {
    return matrix(_powArray(x2.valueOf(), y2));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/round.js
var NO_INT = "Number of decimals in function round must be an integer";
var name127 = "round";
var dependencies127 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
var createRound = /* @__PURE__ */ factory(name127, dependencies127, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    zeros: zeros2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  return typed3(name127, {
    number: roundNumber,
    "number, number": roundNumber,
    "number, BigNumber": function numberBigNumber(x2, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return new BigNumber2(x2).toDecimalPlaces(n.toNumber());
    },
    Complex: function Complex3(x2) {
      return x2.round();
    },
    "Complex, number": function ComplexNumber(x2, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x2.round(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x2, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var _n = n.toNumber();
      return x2.round(_n);
    },
    BigNumber: function BigNumber3(x2) {
      return x2.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x2.toDecimalPlaces(n.toNumber());
    },
    Fraction: function Fraction3(x2) {
      return x2.round();
    },
    "Fraction, number": function FractionNumber(x2, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x2.round(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x2, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x2.round(n.toNumber());
    },
    // deep map collection, skip zeros since round(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2, true)),
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo11xS0s(x2, y2, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo14xDs(x2, y2, self2, false);
    }),
    "Array, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo14xDs(matrix(x2), y2, self2, false).valueOf();
    }),
    "number | Complex | BigNumber | Fraction, SparseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0)) {
        return zeros2(y2.size(), y2.storage());
      }
      return matAlgo12xSfs(y2, x2, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, DenseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0)) {
        return zeros2(y2.size(), y2.storage());
      }
      return matAlgo14xDs(y2, x2, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, Array": typed3.referToSelf((self2) => (x2, y2) => {
      return matAlgo14xDs(matrix(y2), x2, self2, true).valueOf();
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log.js
var name128 = "log";
var dependencies128 = ["config", "typed", "divideScalar", "Complex"];
var createLog = /* @__PURE__ */ factory(name128, dependencies128, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    divideScalar,
    Complex: Complex3
  } = _ref;
  return typed3(name128, {
    number: function number5(x2) {
      if (x2 >= 0 || config4.predictable) {
        return logNumber(x2);
      } else {
        return new Complex3(x2, 0).log();
      }
    },
    Complex: function Complex4(x2) {
      return x2.log();
    },
    BigNumber: function BigNumber2(x2) {
      if (!x2.isNegative() || config4.predictable) {
        return x2.ln();
      } else {
        return new Complex3(x2.toNumber(), 0).log();
      }
    },
    "any, any": typed3.referToSelf((self2) => (x2, base) => {
      return divideScalar(self2(x2), self2(base));
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
var name129 = "log1p";
var dependencies129 = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = /* @__PURE__ */ factory(name129, dependencies129, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    divideScalar,
    log: log4,
    Complex: Complex3
  } = _ref;
  return typed3(name129, {
    number: function number5(x2) {
      if (x2 >= -1 || config4.predictable) {
        return log1p(x2);
      } else {
        return _log1pComplex(new Complex3(x2, 0));
      }
    },
    Complex: _log1pComplex,
    BigNumber: function BigNumber2(x2) {
      var y2 = x2.plus(1);
      if (!y2.isNegative() || config4.predictable) {
        return y2.ln();
      } else {
        return _log1pComplex(new Complex3(x2.toNumber(), 0));
      }
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2)),
    "any, any": typed3.referToSelf((self2) => (x2, base) => {
      return divideScalar(self2(x2), log4(base));
    })
  });
  function _log1pComplex(x2) {
    var xRe1p = x2.re + 1;
    return new Complex3(Math.log(Math.sqrt(xRe1p * xRe1p + x2.im * x2.im)), Math.atan2(x2.im, xRe1p));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
var name130 = "nthRoots";
var dependencies130 = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = /* @__PURE__ */ factory(name130, dependencies130, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    divideScalar,
    Complex: Complex3
  } = _ref;
  var _calculateExactResult = [function realPos(val) {
    return new Complex3(val, 0);
  }, function imagPos(val) {
    return new Complex3(0, val);
  }, function realNeg(val) {
    return new Complex3(-val, 0);
  }, function imagNeg(val) {
    return new Complex3(0, -val);
  }];
  function _nthComplexRoots(a2, root2) {
    if (root2 < 0)
      throw new Error("Root must be greater than zero");
    if (root2 === 0)
      throw new Error("Root must be non-zero");
    if (root2 % 1 !== 0)
      throw new Error("Root must be an integer");
    if (a2 === 0 || a2.abs() === 0)
      return [new Complex3(0, 0)];
    var aIsNumeric = typeof a2 === "number";
    var offset;
    if (aIsNumeric || a2.re === 0 || a2.im === 0) {
      if (aIsNumeric) {
        offset = 2 * +(a2 < 0);
      } else if (a2.im === 0) {
        offset = 2 * +(a2.re < 0);
      } else {
        offset = 2 * +(a2.im < 0) + 1;
      }
    }
    var arg = a2.arg();
    var abs3 = a2.abs();
    var roots = [];
    var r = Math.pow(abs3, 1 / root2);
    for (var k2 = 0; k2 < root2; k2++) {
      var halfPiFactor = (offset + 4 * k2) / root2;
      if (halfPiFactor === Math.round(halfPiFactor)) {
        roots.push(_calculateExactResult[halfPiFactor % 4](r));
        continue;
      }
      roots.push(new Complex3({
        r,
        phi: (arg + 2 * Math.PI * k2) / root2
      }));
    }
    return roots;
  }
  return typed3(name130, {
    Complex: function Complex4(x2) {
      return _nthComplexRoots(x2, 2);
    },
    "Complex, number": _nthComplexRoots
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
var name131 = "dotPow";
var dependencies131 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"];
var createDotPow = /* @__PURE__ */ factory(name131, dependencies131, (_ref) => {
  var {
    typed: typed3,
    equalScalar,
    matrix,
    pow: pow3,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var powScalarSignatures = {};
  for (var signature in pow3.signatures) {
    if (Object.prototype.hasOwnProperty.call(pow3.signatures, signature)) {
      if (!signature.includes("Matrix") && !signature.includes("Array")) {
        powScalarSignatures[signature] = pow3.signatures[signature];
      }
    }
  }
  var powScalar = typed3(powScalarSignatures);
  return typed3(name131, matrixAlgorithmSuite({
    elop: powScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
var name132 = "dotDivide";
var dependencies132 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"];
var createDotDivide = /* @__PURE__ */ factory(name132, dependencies132, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    divideScalar,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name132, matrixAlgorithmSuite({
    elop: divideScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
function createSolveValidation(_ref) {
  var {
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function solveValidation(m, b, copy3) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i = 0; i < rows; i++) {
          data[i] = [bdata[i]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy3) {
            data = [];
            for (var _i = 0; _i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0; _i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values2 = b._values;
          var index = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k2 = ptr[0]; k2 < k1; k2++) {
            var _i3 = index[k2];
            data[_i3][0] = values2[k2];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0; _i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0; _i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
var name133 = "lsolve";
var dependencies133 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolve = /* @__PURE__ */ factory(name133, dependencies133, (_ref) => {
  var {
    typed: typed3,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name133, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a2, b) {
      var m = matrix(a2);
      var r = _denseForwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x2 = [];
    var mdata = m._data;
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar(bj, vjj);
        for (var i = j + 1; i < rows; i++) {
          bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
        }
      } else {
        xj = 0;
      }
      x2[j] = [xj];
    }
    return new DenseMatrix2({
      data: x2,
      size: [rows, 1]
    });
  }
  function _sparseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values2 = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var x2 = [];
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k2 = firstIndex; k2 < lastIndex; k2++) {
          var i = index[k2];
          if (i === j) {
            vjj = values2[k2];
          } else if (i > j) {
            jValues.push(values2[k2]);
            jIndices.push(i);
          }
        }
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar(bj, vjj);
        for (var _k = 0, l = jIndices.length; _k < l; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];
        }
        x2[j] = [xj];
      } else {
        x2[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x2,
      size: [rows, 1]
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
var name134 = "usolve";
var dependencies134 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolve = /* @__PURE__ */ factory(name134, dependencies134, (_ref) => {
  var {
    typed: typed3,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name134, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a2, b) {
      var m = matrix(a2);
      var r = _denseBackwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x2 = [];
    var mdata = m._data;
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar(bj, vjj);
        for (var i = j - 1; i >= 0; i--) {
          bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
        }
      } else {
        xj = 0;
      }
      x2[j] = [xj];
    }
    return new DenseMatrix2({
      data: x2,
      size: [rows, 1]
    });
  }
  function _sparseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values2 = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var x2 = [];
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k2 = lastIndex - 1; k2 >= firstIndex; k2--) {
          var i = index[k2];
          if (i === j) {
            vjj = values2[k2];
          } else if (i < j) {
            jValues.push(values2[k2]);
            jIndices.push(i);
          }
        }
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar(bj, vjj);
        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
        }
        x2[j] = [xj];
      } else {
        x2[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x2,
      size: [rows, 1]
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
var name135 = "lsolveAll";
var dependencies135 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolveAll = /* @__PURE__ */ factory(name135, dependencies135, (_ref) => {
  var {
    typed: typed3,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name135, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a2, b) {
      var m = matrix(a2);
      var R = _denseForwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseForwardSubstitution(m, b_) {
    var B2 = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i = 0; i < columns; i++) {
      var L = B2.length;
      for (var k2 = 0; k2 < L; k2++) {
        var b = B2[k2];
        if (!equalScalar(M[i][i], 0)) {
          b[i] = divideScalar(b[i], M[i][i]);
          for (var j = i + 1; j < columns; j++) {
            b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k2 === 0) {
            return [];
          } else {
            B2.splice(k2, 1);
            k2 -= 1;
            L -= 1;
          }
        } else if (k2 === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j = i + 1; _j < columns; _j++) {
            bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
          }
          B2.push(bNew);
        }
      }
    }
    return B2.map((x2) => new DenseMatrix2({
      data: x2.map((e3) => [e3]),
      size: [rows, 1]
    }));
  }
  function _sparseForwardSubstitution(m, b_) {
    var B2 = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values2 = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var i = 0; i < columns; i++) {
      var L = B2.length;
      for (var k2 = 0; k2 < L; k2++) {
        var b = B2[k2];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i];
        var lastIndex = ptr[i + 1];
        var Mii = 0;
        for (var j = firstIndex; j < lastIndex; j++) {
          var J = index[j];
          if (J === i) {
            Mii = values2[j];
          } else if (J > i) {
            iValues.push(values2[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar(Mii, 0)) {
          b[i] = divideScalar(b[i], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k2 === 0) {
            return [];
          } else {
            B2.splice(k2, 1);
            k2 -= 1;
            L -= 1;
          }
        } else if (k2 === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
          }
          B2.push(bNew);
        }
      }
    }
    return B2.map((x2) => new DenseMatrix2({
      data: x2.map((e3) => [e3]),
      size: [rows, 1]
    }));
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
var name136 = "usolveAll";
var dependencies136 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolveAll = /* @__PURE__ */ factory(name136, dependencies136, (_ref) => {
  var {
    typed: typed3,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name136, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a2, b) {
      var m = matrix(a2);
      var R = _denseBackwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseBackwardSubstitution(m, b_) {
    var B2 = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i = columns - 1; i >= 0; i--) {
      var L = B2.length;
      for (var k2 = 0; k2 < L; k2++) {
        var b = B2[k2];
        if (!equalScalar(M[i][i], 0)) {
          b[i] = divideScalar(b[i], M[i][i]);
          for (var j = i - 1; j >= 0; j--) {
            b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k2 === 0) {
            return [];
          } else {
            B2.splice(k2, 1);
            k2 -= 1;
            L -= 1;
          }
        } else if (k2 === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j = i - 1; _j >= 0; _j--) {
            bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
          }
          B2.push(bNew);
        }
      }
    }
    return B2.map((x2) => new DenseMatrix2({
      data: x2.map((e3) => [e3]),
      size: [rows, 1]
    }));
  }
  function _sparseBackwardSubstitution(m, b_) {
    var B2 = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values2 = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var i = columns - 1; i >= 0; i--) {
      var L = B2.length;
      for (var k2 = 0; k2 < L; k2++) {
        var b = B2[k2];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i];
        var lastIndex = ptr[i + 1];
        var Mii = 0;
        for (var j = lastIndex - 1; j >= firstIndex; j--) {
          var J = index[j];
          if (J === i) {
            Mii = values2[j];
          } else if (J < i) {
            iValues.push(values2[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar(Mii, 0)) {
          b[i] = divideScalar(b[i], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k2 === 0) {
            return [];
          } else {
            B2.splice(k2, 1);
            k2 -= 1;
            L -= 1;
          }
        } else if (k2 === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
          }
          B2.push(bNew);
        }
      }
    }
    return B2.map((x2) => new DenseMatrix2({
      data: x2.map((e3) => [e3]),
      size: [rows, 1]
    }));
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
var name137 = "matAlgo08xS0Sid";
var dependencies137 = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = /* @__PURE__ */ factory(name137, dependencies137, (_ref) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref;
  return function matAlgo08xS0Sid(a2, b, callback) {
    var avalues = a2._values;
    var aindex = a2._index;
    var aptr = a2._ptr;
    var asize = a2._size;
    var adt = a2._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!avalues || !bvalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero3 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed3.find(equalScalar, [dt, dt]);
      zero3 = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var x2 = [];
    var w = [];
    var k2, k0, k1, i;
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k2 = k0; k2 < k1; k2++) {
        i = aindex[k2];
        w[i] = mark;
        x2[i] = avalues[k2];
        cindex.push(i);
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k2 = k0; k2 < k1; k2++) {
        i = bindex[k2];
        if (w[i] === mark) {
          x2[i] = cf(x2[i], bvalues[k2]);
        }
      }
      k2 = cptr[j];
      while (k2 < cindex.length) {
        i = cindex[k2];
        var v = x2[i];
        if (!eq(v, zero3)) {
          cvalues.push(v);
          k2++;
        } else {
          cindex.splice(k2, 1);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a2.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
var createUseMatrixForArrayScalar = /* @__PURE__ */ factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
  var {
    typed: typed3,
    matrix
  } = _ref;
  return {
    "Array, number": typed3.referTo("DenseMatrix, number", (selfDn) => (x2, y2) => selfDn(matrix(x2), y2).valueOf()),
    "Array, BigNumber": typed3.referTo("DenseMatrix, BigNumber", (selfDB) => (x2, y2) => selfDB(matrix(x2), y2).valueOf()),
    "number, Array": typed3.referTo("number, DenseMatrix", (selfnD) => (x2, y2) => selfnD(x2, matrix(y2)).valueOf()),
    "BigNumber, Array": typed3.referTo("BigNumber, DenseMatrix", (selfBD) => (x2, y2) => selfBD(x2, matrix(y2)).valueOf())
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
var name138 = "leftShift";
var dependencies138 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createLeftShift = /* @__PURE__ */ factory(name138, dependencies138, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed3,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed3,
    matrix
  });
  return typed3(name138, {
    "number, number": leftShiftNumber,
    "BigNumber, BigNumber": leftShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(y2, 0)) {
        return x2.clone();
      }
      return matAlgo11xS0s(x2, y2, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(y2, 0)) {
        return x2.clone();
      }
      return matAlgo14xDs(x2, y2, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0)) {
        return zeros2(y2.size(), y2.storage());
      }
      return matAlgo10xSids(y2, x2, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0)) {
        return zeros2(y2.size(), y2.storage());
      }
      return matAlgo14xDs(y2, x2, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
var name139 = "rightArithShift";
var dependencies139 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightArithShift = /* @__PURE__ */ factory(name139, dependencies139, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed3,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed3,
    matrix
  });
  return typed3(name139, {
    "number, number": rightArithShiftNumber,
    "BigNumber, BigNumber": rightArithShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(y2, 0)) {
        return x2.clone();
      }
      return matAlgo11xS0s(x2, y2, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(y2, 0)) {
        return x2.clone();
      }
      return matAlgo14xDs(x2, y2, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0)) {
        return zeros2(y2.size(), y2.storage());
      }
      return matAlgo10xSids(y2, x2, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0)) {
        return zeros2(y2.size(), y2.storage());
      }
      return matAlgo14xDs(y2, x2, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
var name140 = "rightLogShift";
var dependencies140 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightLogShift = /* @__PURE__ */ factory(name140, dependencies140, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed3,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed3,
    matrix
  });
  return typed3(name140, {
    "number, number": rightLogShiftNumber,
    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(y2, 0)) {
        return x2.clone();
      }
      return matAlgo11xS0s(x2, y2, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(y2, 0)) {
        return x2.clone();
      }
      return matAlgo14xDs(x2, y2, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0)) {
        return zeros2(y2.size(), y2.storage());
      }
      return matAlgo10xSids(y2, x2, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (equalScalar(x2, 0)) {
        return zeros2(y2.size(), y2.storage());
      }
      return matAlgo14xDs(y2, x2, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/logical/and.js
var name141 = "and";
var dependencies141 = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
var createAnd = /* @__PURE__ */ factory(name141, dependencies141, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    zeros: zeros2,
    not,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed3,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name141, {
    "number, number": andNumber,
    "Complex, Complex": function ComplexComplex(x2, y2) {
      return (x2.re !== 0 || x2.im !== 0) && (y2.re !== 0 || y2.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return !x2.isZero() && !y2.isZero() && !x2.isNaN() && !y2.isNaN();
    },
    "Unit, Unit": typed3.referToSelf((self2) => (x2, y2) => self2(x2.value || 0, y2.value || 0)),
    "SparseMatrix, any": typed3.referToSelf((self2) => (x2, y2) => {
      if (not(y2)) {
        return zeros2(x2.size(), x2.storage());
      }
      return matAlgo11xS0s(x2, y2, self2, false);
    }),
    "DenseMatrix, any": typed3.referToSelf((self2) => (x2, y2) => {
      if (not(y2)) {
        return zeros2(x2.size(), x2.storage());
      }
      return matAlgo14xDs(x2, y2, self2, false);
    }),
    "any, SparseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (not(x2)) {
        return zeros2(x2.size(), x2.storage());
      }
      return matAlgo11xS0s(y2, x2, self2, true);
    }),
    "any, DenseMatrix": typed3.referToSelf((self2) => (x2, y2) => {
      if (not(x2)) {
        return zeros2(x2.size(), x2.storage());
      }
      return matAlgo14xDs(y2, x2, self2, true);
    }),
    "Array, any": typed3.referToSelf((self2) => (x2, y2) => {
      return self2(matrix(x2), y2).valueOf();
    }),
    "any, Array": typed3.referToSelf((self2) => (x2, y2) => {
      return self2(x2, matrix(y2)).valueOf();
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/relational/compare.js
var name142 = "compare";
var dependencies142 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"];
var createCompare = /* @__PURE__ */ factory(name142, dependencies142, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    equalScalar,
    matrix,
    BigNumber: BigNumber2,
    Fraction: Fraction3,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name142, createCompareNumber({
    typed: typed3,
    config: config4
  }), {
    "boolean, boolean": function booleanBoolean(x2, y2) {
      return x2 === y2 ? 0 : x2 > y2 ? 1 : -1;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return nearlyEqual2(x2, y2, config4.epsilon) ? new BigNumber2(0) : new BigNumber2(x2.cmp(y2));
    },
    "Fraction, Fraction": function FractionFraction(x2, y2) {
      return new Fraction3(x2.compare(y2));
    },
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createCompareNumber = /* @__PURE__ */ factory(name142, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config4
  } = _ref2;
  return typed3(name142, {
    "number, number": function numberNumber(x2, y2) {
      return nearlyEqual(x2, y2, config4.epsilon) ? 0 : x2 > y2 ? 1 : -1;
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/compareNatural.js
var import_javascript_natural_sort = __toESM(require_naturalSort(), 1);
var name143 = "compareNatural";
var dependencies143 = ["typed", "compare"];
var createCompareNatural = /* @__PURE__ */ factory(name143, dependencies143, (_ref) => {
  var {
    typed: typed3,
    compare
  } = _ref;
  var compareBooleans = compare.signatures["boolean,boolean"];
  return typed3(name143, {
    "any, any": _compareNatural
  });
  function _compareNatural(x2, y2) {
    var typeX = typeOf(x2);
    var typeY = typeOf(y2);
    var c2;
    if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
      c2 = compare(x2, y2);
      if (c2.toString() !== "0") {
        return c2 > 0 ? 1 : -1;
      } else {
        return (0, import_javascript_natural_sort.default)(typeX, typeY);
      }
    }
    var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
    if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
      c2 = compareMatricesAndArrays(_compareNatural, x2, y2);
      if (c2 !== 0) {
        return c2;
      } else {
        return (0, import_javascript_natural_sort.default)(typeX, typeY);
      }
    }
    if (typeX !== typeY) {
      return (0, import_javascript_natural_sort.default)(typeX, typeY);
    }
    if (typeX === "Complex") {
      return compareComplexNumbers(x2, y2);
    }
    if (typeX === "Unit") {
      if (x2.equalBase(y2)) {
        return _compareNatural(x2.value, y2.value);
      }
      return compareArrays(_compareNatural, x2.formatUnits(), y2.formatUnits());
    }
    if (typeX === "boolean") {
      return compareBooleans(x2, y2);
    }
    if (typeX === "string") {
      return (0, import_javascript_natural_sort.default)(x2, y2);
    }
    if (typeX === "Object") {
      return compareObjects(_compareNatural, x2, y2);
    }
    if (typeX === "null") {
      return 0;
    }
    if (typeX === "undefined") {
      return 0;
    }
    throw new TypeError('Unsupported type of value "' + typeX + '"');
  }
  function compareMatricesAndArrays(compareNatural, x2, y2) {
    if (isSparseMatrix(x2) && isSparseMatrix(y2)) {
      return compareArrays(compareNatural, x2.toJSON().values, y2.toJSON().values);
    }
    if (isSparseMatrix(x2)) {
      return compareMatricesAndArrays(compareNatural, x2.toArray(), y2);
    }
    if (isSparseMatrix(y2)) {
      return compareMatricesAndArrays(compareNatural, x2, y2.toArray());
    }
    if (isDenseMatrix(x2)) {
      return compareMatricesAndArrays(compareNatural, x2.toJSON().data, y2);
    }
    if (isDenseMatrix(y2)) {
      return compareMatricesAndArrays(compareNatural, x2, y2.toJSON().data);
    }
    if (!Array.isArray(x2)) {
      return compareMatricesAndArrays(compareNatural, [x2], y2);
    }
    if (!Array.isArray(y2)) {
      return compareMatricesAndArrays(compareNatural, x2, [y2]);
    }
    return compareArrays(compareNatural, x2, y2);
  }
  function compareArrays(compareNatural, x2, y2) {
    for (var i = 0, ii = Math.min(x2.length, y2.length); i < ii; i++) {
      var v = compareNatural(x2[i], y2[i]);
      if (v !== 0) {
        return v;
      }
    }
    if (x2.length > y2.length) {
      return 1;
    }
    if (x2.length < y2.length) {
      return -1;
    }
    return 0;
  }
  function compareObjects(compareNatural, x2, y2) {
    var keysX = Object.keys(x2);
    var keysY = Object.keys(y2);
    keysX.sort(import_javascript_natural_sort.default);
    keysY.sort(import_javascript_natural_sort.default);
    var c2 = compareArrays(compareNatural, keysX, keysY);
    if (c2 !== 0) {
      return c2;
    }
    for (var i = 0; i < keysX.length; i++) {
      var v = compareNatural(x2[keysX[i]], y2[keysY[i]]);
      if (v !== 0) {
        return v;
      }
    }
    return 0;
  }
});
function compareComplexNumbers(x2, y2) {
  if (x2.re > y2.re) {
    return 1;
  }
  if (x2.re < y2.re) {
    return -1;
  }
  if (x2.im > y2.im) {
    return 1;
  }
  if (x2.im < y2.im) {
    return -1;
  }
  return 0;
}

// node_modules/mathjs/lib/esm/function/relational/compareText.js
var name144 = "compareText";
var dependencies144 = ["typed", "matrix", "concat"];
compareText.signature = "any, any";
var createCompareText = /* @__PURE__ */ factory(name144, dependencies144, (_ref) => {
  var {
    typed: typed3,
    matrix,
    concat: concat2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name144, compareText, matrixAlgorithmSuite({
    elop: compareText,
    Ds: true
  }));
});

// node_modules/mathjs/lib/esm/function/relational/equal.js
var name145 = "equal";
var dependencies145 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createEqual = /* @__PURE__ */ factory(name145, dependencies145, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name145, createEqualNumber({
    typed: typed3,
    equalScalar
  }), matrixAlgorithmSuite({
    elop: equalScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createEqualNumber = factory(name145, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref2;
  return typed3(name145, {
    "any, any": function anyAny(x2, y2) {
      if (x2 === null) {
        return y2 === null;
      }
      if (y2 === null) {
        return x2 === null;
      }
      if (x2 === void 0) {
        return y2 === void 0;
      }
      if (y2 === void 0) {
        return x2 === void 0;
      }
      return equalScalar(x2, y2);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/equalText.js
var name146 = "equalText";
var dependencies146 = ["typed", "compareText", "isZero"];
var createEqualText = /* @__PURE__ */ factory(name146, dependencies146, (_ref) => {
  var {
    typed: typed3,
    compareText: compareText2,
    isZero
  } = _ref;
  return typed3(name146, {
    "any, any": function anyAny(x2, y2) {
      return isZero(compareText2(x2, y2));
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/smaller.js
var name147 = "smaller";
var dependencies147 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createSmaller = /* @__PURE__ */ factory(name147, dependencies147, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name147, createSmallerNumber({
    typed: typed3,
    config: config4
  }), {
    "boolean, boolean": (x2, y2) => x2 < y2,
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.lt(y2) && !nearlyEqual2(x2, y2, config4.epsilon);
    },
    "Fraction, Fraction": (x2, y2) => x2.compare(y2) === -1,
    "Complex, Complex": function ComplexComplex(x2, y2) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerNumber = /* @__PURE__ */ factory(name147, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config4
  } = _ref2;
  return typed3(name147, {
    "number, number": function numberNumber(x2, y2) {
      return x2 < y2 && !nearlyEqual(x2, y2, config4.epsilon);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/smallerEq.js
var name148 = "smallerEq";
var dependencies148 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createSmallerEq = /* @__PURE__ */ factory(name148, dependencies148, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name148, createSmallerEqNumber({
    typed: typed3,
    config: config4
  }), {
    "boolean, boolean": (x2, y2) => x2 <= y2,
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.lte(y2) || nearlyEqual2(x2, y2, config4.epsilon);
    },
    "Fraction, Fraction": (x2, y2) => x2.compare(y2) !== 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerEqNumber = /* @__PURE__ */ factory(name148, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config4
  } = _ref2;
  return typed3(name148, {
    "number, number": function numberNumber(x2, y2) {
      return x2 <= y2 || nearlyEqual(x2, y2, config4.epsilon);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/larger.js
var name149 = "larger";
var dependencies149 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createLarger = /* @__PURE__ */ factory(name149, dependencies149, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name149, createLargerNumber({
    typed: typed3,
    config: config4
  }), {
    "boolean, boolean": (x2, y2) => x2 > y2,
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.gt(y2) && !nearlyEqual2(x2, y2, config4.epsilon);
    },
    "Fraction, Fraction": (x2, y2) => x2.compare(y2) === 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerNumber = /* @__PURE__ */ factory(name149, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config4
  } = _ref2;
  return typed3(name149, {
    "number, number": function numberNumber(x2, y2) {
      return x2 > y2 && !nearlyEqual(x2, y2, config4.epsilon);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/largerEq.js
var name150 = "largerEq";
var dependencies150 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createLargerEq = /* @__PURE__ */ factory(name150, dependencies150, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name150, createLargerEqNumber({
    typed: typed3,
    config: config4
  }), {
    "boolean, boolean": (x2, y2) => x2 >= y2,
    "BigNumber, BigNumber": function BigNumberBigNumber(x2, y2) {
      return x2.gte(y2) || nearlyEqual2(x2, y2, config4.epsilon);
    },
    "Fraction, Fraction": (x2, y2) => x2.compare(y2) !== -1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerEqNumber = /* @__PURE__ */ factory(name150, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config4
  } = _ref2;
  return typed3(name150, {
    "number, number": function numberNumber(x2, y2) {
      return x2 >= y2 || nearlyEqual(x2, y2, config4.epsilon);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/deepEqual.js
var name151 = "deepEqual";
var dependencies151 = ["typed", "equal"];
var createDeepEqual = /* @__PURE__ */ factory(name151, dependencies151, (_ref) => {
  var {
    typed: typed3,
    equal
  } = _ref;
  return typed3(name151, {
    "any, any": function anyAny(x2, y2) {
      return _deepEqual(x2.valueOf(), y2.valueOf());
    }
  });
  function _deepEqual(x2, y2) {
    if (Array.isArray(x2)) {
      if (Array.isArray(y2)) {
        var len = x2.length;
        if (len !== y2.length) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          if (!_deepEqual(x2[i], y2[i])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      if (Array.isArray(y2)) {
        return false;
      } else {
        return equal(x2, y2);
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/relational/unequal.js
var name152 = "unequal";
var dependencies152 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"];
var createUnequal = /* @__PURE__ */ factory(name152, dependencies152, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    equalScalar,
    matrix,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name152, createUnequalNumber({
    typed: typed3,
    equalScalar
  }), matrixAlgorithmSuite({
    elop: _unequal,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
  function _unequal(x2, y2) {
    return !equalScalar(x2, y2);
  }
});
var createUnequalNumber = factory(name152, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed3,
    equalScalar
  } = _ref2;
  return typed3(name152, {
    "any, any": function anyAny(x2, y2) {
      if (x2 === null) {
        return y2 !== null;
      }
      if (y2 === null) {
        return x2 !== null;
      }
      if (x2 === void 0) {
        return y2 !== void 0;
      }
      if (y2 === void 0) {
        return x2 !== void 0;
      }
      return !equalScalar(x2, y2);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
var name153 = "partitionSelect";
var dependencies153 = ["typed", "isNumeric", "isNaN", "compare"];
var createPartitionSelect = /* @__PURE__ */ factory(name153, dependencies153, (_ref) => {
  var {
    typed: typed3,
    isNumeric,
    isNaN: isNaN2,
    compare
  } = _ref;
  var asc = compare;
  var desc = (a2, b) => -compare(a2, b);
  return typed3(name153, {
    "Array | Matrix, number": function ArrayMatrixNumber(x2, k2) {
      return _partitionSelect(x2, k2, asc);
    },
    "Array | Matrix, number, string": function ArrayMatrixNumberString(x2, k2, compare2) {
      if (compare2 === "asc") {
        return _partitionSelect(x2, k2, asc);
      } else if (compare2 === "desc") {
        return _partitionSelect(x2, k2, desc);
      } else {
        throw new Error('Compare string must be "asc" or "desc"');
      }
    },
    "Array | Matrix, number, function": _partitionSelect
  });
  function _partitionSelect(x2, k2, compare2) {
    if (!isInteger(k2) || k2 < 0) {
      throw new Error("k must be a non-negative integer");
    }
    if (isMatrix(x2)) {
      var size = x2.size();
      if (size.length > 1) {
        throw new Error("Only one dimensional matrices supported");
      }
      return quickSelect(x2.valueOf(), k2, compare2);
    }
    if (Array.isArray(x2)) {
      return quickSelect(x2, k2, compare2);
    }
  }
  function quickSelect(arr, k2, compare2) {
    if (k2 >= arr.length) {
      throw new Error("k out of bounds");
    }
    for (var i = 0; i < arr.length; i++) {
      if (isNumeric(arr[i]) && isNaN2(arr[i])) {
        return arr[i];
      }
    }
    var from = 0;
    var to = arr.length - 1;
    while (from < to) {
      var r = from;
      var w = to;
      var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];
      while (r < w) {
        if (compare2(arr[r], pivot) >= 0) {
          var tmp = arr[w];
          arr[w] = arr[r];
          arr[r] = tmp;
          --w;
        } else {
          ++r;
        }
      }
      if (compare2(arr[r], pivot) > 0) {
        --r;
      }
      if (k2 <= r) {
        to = r;
      } else {
        from = r + 1;
      }
    }
    return arr[k2];
  }
});

// node_modules/mathjs/lib/esm/function/matrix/sort.js
var name154 = "sort";
var dependencies154 = ["typed", "matrix", "compare", "compareNatural"];
var createSort = /* @__PURE__ */ factory(name154, dependencies154, (_ref) => {
  var {
    typed: typed3,
    matrix,
    compare,
    compareNatural
  } = _ref;
  var compareAsc = compare;
  var compareDesc = (a2, b) => -compare(a2, b);
  return typed3(name154, {
    Array: function Array2(x2) {
      _arrayIsVector(x2);
      return x2.sort(compareAsc);
    },
    Matrix: function Matrix2(x2) {
      _matrixIsVector(x2);
      return matrix(x2.toArray().sort(compareAsc), x2.storage());
    },
    "Array, function": function ArrayFunction(x2, _comparator2) {
      _arrayIsVector(x2);
      return x2.sort(_comparator2);
    },
    "Matrix, function": function MatrixFunction(x2, _comparator2) {
      _matrixIsVector(x2);
      return matrix(x2.toArray().sort(_comparator2), x2.storage());
    },
    "Array, string": function ArrayString(x2, order) {
      _arrayIsVector(x2);
      return x2.sort(_comparator(order));
    },
    "Matrix, string": function MatrixString(x2, order) {
      _matrixIsVector(x2);
      return matrix(x2.toArray().sort(_comparator(order)), x2.storage());
    }
  });
  function _comparator(order) {
    if (order === "asc") {
      return compareAsc;
    } else if (order === "desc") {
      return compareDesc;
    } else if (order === "natural") {
      return compareNatural;
    } else {
      throw new Error('String "asc", "desc", or "natural" expected');
    }
  }
  function _arrayIsVector(array2) {
    if (arraySize(array2).length !== 1) {
      throw new Error("One dimensional array expected");
    }
  }
  function _matrixIsVector(matrix2) {
    if (matrix2.size().length !== 1) {
      throw new Error("One dimensional matrix expected");
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/max.js
var name155 = "max";
var dependencies155 = ["typed", "config", "numeric", "larger"];
var createMax = /* @__PURE__ */ factory(name155, dependencies155, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    numeric: numeric2,
    larger
  } = _ref;
  return typed3(name155, {
    // max([a, b, c, d, ...])
    "Array | Matrix": _max,
    // max([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array2, dim) {
      return reduce(array2, dim.valueOf(), _largest);
    },
    // max(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function max");
      }
      return _max(args);
    }
  });
  function _largest(x2, y2) {
    try {
      return larger(x2, y2) ? x2 : y2;
    } catch (err) {
      throw improveErrorMessage(err, "max", y2);
    }
  }
  function _max(array2) {
    var res;
    deepForEach(array2, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          res = NaN;
        } else if (res === void 0 || larger(value, res)) {
          res = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "max", value);
      }
    });
    if (res === void 0) {
      throw new Error("Cannot calculate max of an empty array");
    }
    if (typeof res === "string") {
      res = numeric2(res, config4.number);
    }
    return res;
  }
});

// node_modules/mathjs/lib/esm/function/statistics/min.js
var name156 = "min";
var dependencies156 = ["typed", "config", "numeric", "smaller"];
var createMin = /* @__PURE__ */ factory(name156, dependencies156, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    numeric: numeric2,
    smaller
  } = _ref;
  return typed3(name156, {
    // min([a, b, c, d, ...])
    "Array | Matrix": _min,
    // min([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array2, dim) {
      return reduce(array2, dim.valueOf(), _smallest);
    },
    // min(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function min");
      }
      return _min(args);
    }
  });
  function _smallest(x2, y2) {
    try {
      return smaller(x2, y2) ? x2 : y2;
    } catch (err) {
      throw improveErrorMessage(err, "min", y2);
    }
  }
  function _min(array2) {
    var min4;
    deepForEach(array2, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          min4 = NaN;
        } else if (min4 === void 0 || smaller(value, min4)) {
          min4 = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "min", value);
      }
    });
    if (min4 === void 0) {
      throw new Error("Cannot calculate min of an empty array");
    }
    if (typeof min4 === "string") {
      min4 = numeric2(min4, config4.number);
    }
    return min4;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
var name157 = "ImmutableDenseMatrix";
var dependencies157 = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name157, dependencies157, (_ref) => {
  var {
    smaller,
    DenseMatrix: DenseMatrix2
  } = _ref;
  function ImmutableDenseMatrix(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data) || isArray(data)) {
      var matrix = new DenseMatrix2(data, datatype);
      this._data = matrix._data;
      this._size = matrix._size;
      this._datatype = matrix._datatype;
      this._min = null;
      this._max = null;
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== "undefined" ? data.min : null;
      this._max = typeof data.max !== "undefined" ? data.max : null;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }
  ImmutableDenseMatrix.prototype = new DenseMatrix2();
  ImmutableDenseMatrix.prototype.type = "ImmutableDenseMatrix";
  ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
  ImmutableDenseMatrix.prototype.subset = function(index) {
    switch (arguments.length) {
      case 1: {
        var m = DenseMatrix2.prototype.subset.call(this, index);
        if (isMatrix(m)) {
          return new ImmutableDenseMatrix({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  ImmutableDenseMatrix.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.clone = function() {
    return new ImmutableDenseMatrix({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
  };
  ImmutableDenseMatrix.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  ImmutableDenseMatrix.fromJSON = function(json) {
    return new ImmutableDenseMatrix(json);
  };
  ImmutableDenseMatrix.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.min = function() {
    if (this._min === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller(v, m)) {
          m = v;
        }
      });
      this._min = m !== null ? m : void 0;
    }
    return this._min;
  };
  ImmutableDenseMatrix.prototype.max = function() {
    if (this._max === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller(m, v)) {
          m = v;
        }
      });
      this._max = m !== null ? m : void 0;
    }
    return this._max;
  };
  return ImmutableDenseMatrix;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
var name158 = "Index";
var dependencies158 = ["ImmutableDenseMatrix", "getMatrixDataType"];
var createIndexClass = /* @__PURE__ */ factory(name158, dependencies158, (_ref) => {
  var {
    ImmutableDenseMatrix,
    getMatrixDataType
  } = _ref;
  function Index(ranges) {
    if (!(this instanceof Index)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._dimensions = [];
    this._sourceSize = [];
    this._isScalar = true;
    for (var i = 0, ii = arguments.length; i < ii; i++) {
      var arg = arguments[i];
      var argIsArray = isArray(arg);
      var argIsMatrix = isMatrix(arg);
      var sourceSize = null;
      if (isRange(arg)) {
        this._dimensions.push(arg);
        this._isScalar = false;
      } else if (argIsArray || argIsMatrix) {
        var m = void 0;
        if (getMatrixDataType(arg) === "boolean") {
          if (argIsArray)
            m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg).valueOf());
          if (argIsMatrix)
            m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg._data).valueOf());
          sourceSize = arg.valueOf().length;
        } else {
          m = _createImmutableMatrix(arg.valueOf());
        }
        this._dimensions.push(m);
        var size = m.size();
        if (size.length !== 1 || size[0] !== 1 || sourceSize !== null) {
          this._isScalar = false;
        }
      } else if (typeof arg === "number") {
        this._dimensions.push(_createImmutableMatrix([arg]));
      } else if (typeof arg === "string") {
        this._dimensions.push(arg);
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      this._sourceSize.push(sourceSize);
    }
  }
  Index.prototype.type = "Index";
  Index.prototype.isIndex = true;
  function _createImmutableMatrix(arg) {
    for (var i = 0, l = arg.length; i < l; i++) {
      if (typeof arg[i] !== "number" || !isInteger(arg[i])) {
        throw new TypeError("Index parameters must be positive integer numbers");
      }
    }
    return new ImmutableDenseMatrix(arg);
  }
  Index.prototype.clone = function() {
    var index = new Index();
    index._dimensions = clone(this._dimensions);
    index._isScalar = this._isScalar;
    index._sourceSize = this._sourceSize;
    return index;
  };
  Index.create = function(ranges) {
    var index = new Index();
    Index.apply(index, ranges);
    return index;
  };
  Index.prototype.size = function() {
    var size = [];
    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var d = this._dimensions[i];
      size[i] = typeof d === "string" ? 1 : d.size()[0];
    }
    return size;
  };
  Index.prototype.max = function() {
    var values2 = [];
    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var range2 = this._dimensions[i];
      values2[i] = typeof range2 === "string" ? range2 : range2.max();
    }
    return values2;
  };
  Index.prototype.min = function() {
    var values2 = [];
    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var range2 = this._dimensions[i];
      values2[i] = typeof range2 === "string" ? range2 : range2.min();
    }
    return values2;
  };
  Index.prototype.forEach = function(callback) {
    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      callback(this._dimensions[i], i, this);
    }
  };
  Index.prototype.dimension = function(dim) {
    return this._dimensions[dim] || null;
  };
  Index.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
  };
  Index.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };
  Index.prototype.isScalar = function() {
    return this._isScalar;
  };
  Index.prototype.toArray = function() {
    var array2 = [];
    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var dimension = this._dimensions[i];
      array2.push(typeof dimension === "string" ? dimension : dimension.toArray());
    }
    return array2;
  };
  Index.prototype.valueOf = Index.prototype.toArray;
  Index.prototype.toString = function() {
    var strings = [];
    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
      var dimension = this._dimensions[i];
      if (typeof dimension === "string") {
        strings.push(JSON.stringify(dimension));
      } else {
        strings.push(dimension.toString());
      }
    }
    return "[" + strings.join(", ") + "]";
  };
  Index.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  };
  Index.fromJSON = function(json) {
    return Index.create(json.dimensions);
  };
  return Index;
}, {
  isClass: true
});
function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
  var indexOfNumbers = [];
  booleanArrayIndex.forEach((bool, idx) => {
    if (bool) {
      indexOfNumbers.push(idx);
    }
  });
  return indexOfNumbers;
}

// node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
var name159 = "FibonacciHeap";
var dependencies159 = ["smaller", "larger"];
var createFibonacciHeapClass = /* @__PURE__ */ factory(name159, dependencies159, (_ref) => {
  var {
    smaller,
    larger
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap() {
    if (!(this instanceof FibonacciHeap)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap.prototype.type = "FibonacciHeap";
  FibonacciHeap.prototype.isFibonacciHeap = true;
  FibonacciHeap.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x2 = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x2.right;
      x2.left.right = x2.right;
      x2.right.left = x2.left;
      x2.left = minimum;
      x2.right = minimum.right;
      minimum.right = x2;
      x2.right.left = x2;
      x2.parent = null;
      x2 = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes2(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size) {
    var arraySize2 = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
    var array2 = new Array(arraySize2);
    var numRoots = 0;
    var x2 = minimum;
    if (x2) {
      numRoots++;
      x2 = x2.right;
      while (x2 !== minimum) {
        numRoots++;
        x2 = x2.right;
      }
    }
    var y2;
    while (numRoots > 0) {
      var d = x2.degree;
      var next = x2.right;
      while (true) {
        y2 = array2[d];
        if (!y2) {
          break;
        }
        if (larger(x2.key, y2.key)) {
          var temp = y2;
          y2 = x2;
          x2 = temp;
        }
        _linkNodes(y2, x2);
        array2[d] = null;
        d++;
      }
      array2[d] = x2;
      x2 = next;
      numRoots--;
    }
    minimum = null;
    for (var i = 0; i < arraySize2; i++) {
      y2 = array2[i];
      if (!y2) {
        continue;
      }
      if (minimum) {
        y2.left.right = y2.right;
        y2.right.left = y2.left;
        y2.left = minimum;
        y2.right = minimum.right;
        minimum.right = y2;
        y2.right.left = y2;
        if (smaller(y2.key, minimum.key)) {
          minimum = y2;
        }
      } else {
        minimum = y2;
      }
    }
    return minimum;
  }
  return FibonacciHeap;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Spa.js
var name160 = "Spa";
var dependencies160 = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = /* @__PURE__ */ factory(name160, dependencies160, (_ref) => {
  var {
    addScalar,
    equalScalar,
    FibonacciHeap
  } = _ref;
  function Spa() {
    if (!(this instanceof Spa)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap();
  }
  Spa.prototype.type = "Spa";
  Spa.prototype.isSpa = true;
  Spa.prototype.set = function(i, v) {
    if (!this._values[i]) {
      var node = this._heap.insert(i, v);
      this._values[i] = node;
    } else {
      this._values[i].value = v;
    }
  };
  Spa.prototype.get = function(i) {
    var node = this._values[i];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa.prototype.accumulate = function(i, v) {
    var node = this._values[i];
    if (!node) {
      node = this._heap.insert(i, v);
      this._values[i] = node;
    } else {
      node.value = addScalar(node.value, v);
    }
  };
  Spa.prototype.forEach = function(from, to, callback) {
    var heap = this._heap;
    var values2 = this._values;
    var nodes = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes.push(node);
    }
    while (node && node.key <= to) {
      if (node.key >= from) {
        if (!equalScalar(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
    }
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      node = heap.insert(n.key, n.value);
      values2[node.key] = node;
    }
  };
  Spa.prototype.swap = function(i, j) {
    var nodei = this._values[i];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i, nodej.value);
      this._heap.remove(nodej);
      this._values[i] = nodei;
      this._values[j] = void 0;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i] = void 0;
    } else if (nodei && nodej) {
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  return Spa;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/utils/bignumber/constants.js
var createBigNumberE = memoize(function(BigNumber2) {
  return new BigNumber2(1).exp();
}, {
  hasher
});
var createBigNumberPhi = memoize(function(BigNumber2) {
  return new BigNumber2(1).plus(new BigNumber2(5).sqrt()).div(2);
}, {
  hasher
});
var createBigNumberPi = memoize(function(BigNumber2) {
  return BigNumber2.acos(-1);
}, {
  hasher
});
var createBigNumberTau = memoize(function(BigNumber2) {
  return createBigNumberPi(BigNumber2).times(2);
}, {
  hasher
});
function hasher(args) {
  return args[0].precision;
}

// node_modules/mathjs/lib/esm/type/unit/Unit.js
function ownKeys2(e3, r) {
  var t = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e3);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e3) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e3, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e3;
}
var name161 = "Unit";
var dependencies161 = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
var createUnitClass = /* @__PURE__ */ factory(name161, dependencies161, (_ref) => {
  var {
    on,
    config: config4,
    addScalar,
    subtractScalar,
    multiplyScalar,
    divideScalar,
    pow: pow3,
    abs: abs3,
    fix,
    round: round2,
    equal,
    isNumeric,
    format: format6,
    number: _number,
    Complex: Complex3,
    BigNumber: _BigNumber,
    Fraction: _Fraction
  } = _ref;
  var toNumber = _number;
  function Unit(value, valuelessUnit) {
    if (!(this instanceof Unit)) {
      throw new Error("Constructor must be called with the new operator");
    }
    if (!(value === null || value === void 0 || isNumeric(value) || isComplex(value))) {
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    }
    this.fixPrefix = false;
    this.skipAutomaticSimplification = true;
    if (valuelessUnit === void 0) {
      this.units = [];
      this.dimensions = BASE_DIMENSIONS.map((x2) => 0);
    } else if (typeof valuelessUnit === "string") {
      var u = Unit.parse(valuelessUnit);
      this.units = u.units;
      this.dimensions = u.dimensions;
    } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
      this.fixPrefix = valuelessUnit.fixPrefix;
      this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
      this.dimensions = valuelessUnit.dimensions.slice(0);
      this.units = valuelessUnit.units.map((u2) => _extends({}, u2));
    } else {
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    }
    this.value = this._normalize(value);
  }
  Object.defineProperty(Unit, "name", {
    value: "Unit"
  });
  Unit.prototype.constructor = Unit;
  Unit.prototype.type = "Unit";
  Unit.prototype.isUnit = true;
  var text, index, c2;
  function skipWhitespace() {
    while (c2 === " " || c2 === "	") {
      next();
    }
  }
  function isDigitDot(c3) {
    return c3 >= "0" && c3 <= "9" || c3 === ".";
  }
  function isDigit(c3) {
    return c3 >= "0" && c3 <= "9";
  }
  function next() {
    index++;
    c2 = text.charAt(index);
  }
  function revert(oldIndex) {
    index = oldIndex;
    c2 = text.charAt(index);
  }
  function parseNumber() {
    var number5 = "";
    var oldIndex = index;
    if (c2 === "+") {
      next();
    } else if (c2 === "-") {
      number5 += c2;
      next();
    }
    if (!isDigitDot(c2)) {
      revert(oldIndex);
      return null;
    }
    if (c2 === ".") {
      number5 += c2;
      next();
      if (!isDigit(c2)) {
        revert(oldIndex);
        return null;
      }
    } else {
      while (isDigit(c2)) {
        number5 += c2;
        next();
      }
      if (c2 === ".") {
        number5 += c2;
        next();
      }
    }
    while (isDigit(c2)) {
      number5 += c2;
      next();
    }
    if (c2 === "E" || c2 === "e") {
      var tentativeNumber = "";
      var tentativeIndex = index;
      tentativeNumber += c2;
      next();
      if (c2 === "+" || c2 === "-") {
        tentativeNumber += c2;
        next();
      }
      if (!isDigit(c2)) {
        revert(tentativeIndex);
        return number5;
      }
      number5 = number5 + tentativeNumber;
      while (isDigit(c2)) {
        number5 += c2;
        next();
      }
    }
    return number5;
  }
  function parseUnit() {
    var unitName = "";
    while (isDigit(c2) || Unit.isValidAlpha(c2)) {
      unitName += c2;
      next();
    }
    var firstC = unitName.charAt(0);
    if (Unit.isValidAlpha(firstC)) {
      return unitName;
    } else {
      return null;
    }
  }
  function parseCharacter(toFind) {
    if (c2 === toFind) {
      next();
      return toFind;
    } else {
      return null;
    }
  }
  Unit.parse = function(str, options) {
    options = options || {};
    text = str;
    index = -1;
    c2 = "";
    if (typeof text !== "string") {
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    }
    var unit3 = new Unit();
    unit3.units = [];
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;
    next();
    skipWhitespace();
    var valueStr = parseNumber();
    var value = null;
    if (valueStr) {
      if (config4.number === "BigNumber") {
        value = new _BigNumber(valueStr);
      } else if (config4.number === "Fraction") {
        try {
          value = new _Fraction(valueStr);
        } catch (err) {
          value = parseFloat(valueStr);
        }
      } else {
        value = parseFloat(valueStr);
      }
      skipWhitespace();
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
    }
    var powerMultiplierStack = [];
    var powerMultiplierStackProduct = 1;
    while (true) {
      skipWhitespace();
      while (c2 === "(") {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }
      var uStr = void 0;
      if (c2) {
        var oldC = c2;
        uStr = parseUnit();
        if (uStr === null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
        }
      } else {
        break;
      }
      var res = _findUnit(uStr);
      if (res === null) {
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }
      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      skipWhitespace();
      if (parseCharacter("^")) {
        skipWhitespace();
        var p = parseNumber();
        if (p === null) {
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }
      unit3.units.push({
        unit: res.unit,
        prefix: res.prefix,
        power
      });
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        unit3.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
      }
      skipWhitespace();
      while (c2 === ")") {
        if (powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }
      expectingUnit = false;
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      } else {
        powerMultiplierCurrent = 1;
      }
      if (res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    skipWhitespace();
    if (c2) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }
    if (expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }
    if (powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }
    if (unit3.units.length === 0 && !options.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }
    unit3.value = value !== void 0 ? unit3._normalize(value) : null;
    return unit3;
  };
  Unit.prototype.clone = function() {
    var unit3 = new Unit();
    unit3.fixPrefix = this.fixPrefix;
    unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
    unit3.value = clone(this.value);
    unit3.dimensions = this.dimensions.slice(0);
    unit3.units = [];
    for (var i = 0; i < this.units.length; i++) {
      unit3.units[i] = {};
      for (var p in this.units[i]) {
        if (hasOwnProperty(this.units[i], p)) {
          unit3.units[i][p] = this.units[i][p];
        }
      }
    }
    return unit3;
  };
  Unit.prototype.valueType = function() {
    return typeOf(this.value);
  };
  Unit.prototype._isDerived = function() {
    if (this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
  };
  Unit.prototype._normalize = function(value) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit._getNumberConverter(typeOf(value));
    for (var i = 0; i < this.units.length; i++) {
      var unitValue = convert(this.units[i].unit.value);
      var unitPrefixValue = convert(this.units[i].prefix.value);
      var unitPower = convert(this.units[i].power);
      res = multiplyScalar(res, pow3(multiplyScalar(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  Unit.prototype._denormalize = function(value, prefixValue) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit._getNumberConverter(typeOf(value));
    for (var i = 0; i < this.units.length; i++) {
      var unitValue = convert(this.units[i].unit.value);
      var unitPrefixValue = convert(this.units[i].prefix.value);
      var unitPower = convert(this.units[i].power);
      res = divideScalar(res, pow3(multiplyScalar(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  var _findUnit = memoize((str) => {
    if (hasOwnProperty(UNITS, str)) {
      var unit3 = UNITS[str];
      var prefix = unit3.prefixes[""];
      return {
        unit: unit3,
        prefix
      };
    }
    for (var _name in UNITS) {
      if (hasOwnProperty(UNITS, _name)) {
        if (endsWith(str, _name)) {
          var _unit = UNITS[_name];
          var prefixLen = str.length - _name.length;
          var prefixName = str.substring(0, prefixLen);
          var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
          if (_prefix !== void 0) {
            return {
              unit: _unit,
              prefix: _prefix
            };
          }
        }
      }
    }
    return null;
  }, {
    hasher: (args) => args[0],
    limit: 100
  });
  Unit.isValuelessUnit = function(name310) {
    return _findUnit(name310) !== null;
  };
  Unit.prototype.hasBase = function(base) {
    if (typeof base === "string") {
      base = BASE_UNITS[base];
    }
    if (!base) {
      return false;
    }
    for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
      if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit.prototype.equalBase = function(other) {
    for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
      if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit.prototype.equals = function(other) {
    return this.equalBase(other) && equal(this.value, other.value);
  };
  Unit.prototype.multiply = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit(_other);
    for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
    }
    for (var _i = 0; _i < other.units.length; _i++) {
      var inverted = _objectSpread2({}, other.units[_i]);
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = multiplyScalar(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit.prototype.divideInto = function(numerator) {
    return new Unit(numerator).divide(this);
  };
  Unit.prototype.divide = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit(_other);
    for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
    }
    for (var _i2 = 0; _i2 < other.units.length; _i2++) {
      var inverted = _objectSpread2(_objectSpread2({}, other.units[_i2]), {}, {
        power: -other.units[_i2].power
      });
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = divideScalar(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit.prototype.pow = function(p) {
    var res = this.clone();
    for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) * p;
    }
    for (var _i3 = 0; _i3 < res.units.length; _i3++) {
      res.units[_i3].power *= p;
    }
    if (res.value !== null) {
      res.value = pow3(res.value, p);
    } else {
      res.value = null;
    }
    res.skipAutomaticSimplification = false;
    return getNumericIfUnitless(res);
  };
  function getNumericIfUnitless(unit3) {
    if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config4.predictable) {
      return unit3.value;
    } else {
      return unit3;
    }
  }
  Unit.prototype.abs = function() {
    var ret = this.clone();
    if (ret.value !== null) {
      if (ret._isDerived() || ret.units[0].unit.offset === 0) {
        ret.value = abs3(ret.value);
      } else {
        var convert = ret._numberConverter();
        var unitValue = convert(ret.units[0].unit.value);
        var nominalOffset = convert(ret.units[0].unit.offset);
        var unitOffset = multiplyScalar(unitValue, nominalOffset);
        ret.value = subtractScalar(abs3(addScalar(ret.value, unitOffset)), unitOffset);
      }
    }
    for (var i in ret.units) {
      if (ret.units[i].unit.name === "VA" || ret.units[i].unit.name === "VAR") {
        ret.units[i].unit = UNITS.W;
      }
    }
    return ret;
  };
  Unit.prototype.to = function(valuelessUnit) {
    var value = this.value === null ? this._normalize(1) : this.value;
    var other;
    if (typeof valuelessUnit === "string") {
      other = Unit.parse(valuelessUnit);
    } else if (isUnit(valuelessUnit)) {
      other = valuelessUnit.clone();
    } else {
      throw new Error("String or Unit expected as parameter");
    }
    if (!this.equalBase(other)) {
      throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
    }
    if (other.value !== null) {
      throw new Error("Cannot convert to a unit with a value");
    }
    if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
      other.value = clone(value);
    } else {
      var convert = Unit._getNumberConverter(typeOf(value));
      var thisUnitValue = this.units[0].unit.value;
      var thisNominalOffset = this.units[0].unit.offset;
      var thisUnitOffset = multiplyScalar(thisUnitValue, thisNominalOffset);
      var otherUnitValue = other.units[0].unit.value;
      var otherNominalOffset = other.units[0].unit.offset;
      var otherUnitOffset = multiplyScalar(otherUnitValue, otherNominalOffset);
      other.value = addScalar(value, convert(subtractScalar(thisUnitOffset, otherUnitOffset)));
    }
    other.fixPrefix = true;
    other.skipAutomaticSimplification = true;
    return other;
  };
  Unit.prototype.toNumber = function(valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };
  Unit.prototype.toNumeric = function(valuelessUnit) {
    var other;
    if (valuelessUnit) {
      other = this.to(valuelessUnit);
    } else {
      other = this.clone();
    }
    if (other._isDerived() || other.units.length === 0) {
      return other._denormalize(other.value);
    } else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };
  Unit.prototype.toString = function() {
    return this.format();
  };
  Unit.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.formatUnits(),
      fixPrefix: this.fixPrefix
    };
  };
  Unit.fromJSON = function(json) {
    var unit3 = new Unit(json.value, json.unit);
    unit3.fixPrefix = json.fixPrefix || false;
    return unit3;
  };
  Unit.prototype.valueOf = Unit.prototype.toString;
  Unit.prototype.simplify = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    var matchingBase;
    for (var key2 in currentUnitSystem) {
      if (hasOwnProperty(currentUnitSystem, key2)) {
        if (ret.hasBase(BASE_UNITS[key2])) {
          matchingBase = key2;
          break;
        }
      }
    }
    if (matchingBase === "NONE") {
      ret.units = [];
    } else {
      var matchingUnit;
      if (matchingBase) {
        if (hasOwnProperty(currentUnitSystem, matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      if (matchingUnit) {
        ret.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1
        }];
      } else {
        var missingBaseDim = false;
        for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
          var baseDim = BASE_DIMENSIONS[i];
          if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
            if (hasOwnProperty(currentUnitSystem, baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: ret.dimensions[i] || 0
              });
            } else {
              missingBaseDim = true;
            }
          }
        }
        if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
          ret.units = proposedUnitList;
        }
      }
    }
    return ret;
  };
  Unit.prototype.toSI = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
      var baseDim = BASE_DIMENSIONS[i];
      if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
        if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
          proposedUnitList.push({
            unit: UNIT_SYSTEMS.si[baseDim].unit,
            prefix: UNIT_SYSTEMS.si[baseDim].prefix,
            power: ret.dimensions[i] || 0
          });
        } else {
          throw new Error("Cannot express custom unit " + baseDim + " in SI units");
        }
      }
    }
    ret.units = proposedUnitList;
    ret.fixPrefix = true;
    ret.skipAutomaticSimplification = true;
    return ret;
  };
  Unit.prototype.formatUnits = function() {
    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;
    for (var i = 0; i < this.units.length; i++) {
      if (this.units[i].power > 0) {
        nNum++;
        strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
        if (Math.abs(this.units[i].power - 1) > 1e-15) {
          strNum += "^" + this.units[i].power;
        }
      } else if (this.units[i].power < 0) {
        nDen++;
      }
    }
    if (nDen > 0) {
      for (var _i4 = 0; _i4 < this.units.length; _i4++) {
        if (this.units[_i4].power < 0) {
          if (nNum > 0) {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
              strDen += "^" + -this.units[_i4].power;
            }
          } else {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            strDen += "^" + this.units[_i4].power;
          }
        }
      }
    }
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);
    if (nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if (nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }
    var str = strNum;
    if (nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;
    return str;
  };
  Unit.prototype.format = function(options) {
    var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
    var isImaginary = false;
    if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
      isImaginary = Math.abs(simp.value.re) < 1e-14;
    }
    for (var i in simp.units) {
      if (hasOwnProperty(simp.units, i)) {
        if (simp.units[i].unit) {
          if (simp.units[i].unit.name === "VA" && isImaginary) {
            simp.units[i].unit = UNITS.VAR;
          } else if (simp.units[i].unit.name === "VAR" && !isImaginary) {
            simp.units[i].unit = UNITS.VA;
          }
        }
      }
    }
    if (simp.units.length === 1 && !simp.fixPrefix) {
      if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
        simp.units[0].prefix = simp._bestPrefix();
      }
    }
    var value = simp._denormalize(simp.value);
    var str = simp.value !== null ? format6(value, options || {}) : "";
    var unitStr = simp.formatUnits();
    if (simp.value && isComplex(simp.value)) {
      str = "(" + str + ")";
    }
    if (unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;
    return str;
  };
  Unit.prototype._bestPrefix = function() {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    var absValue = this.value !== null ? abs3(this.value) : 0;
    var absUnitValue = abs3(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if (bestDiff > -2.200001 && bestDiff < 1.800001)
      return bestPrefix;
    bestDiff = Math.abs(bestDiff);
    var prefixes2 = this.units[0].unit.prefixes;
    for (var p in prefixes2) {
      if (hasOwnProperty(prefixes2, p)) {
        var prefix = prefixes2[p];
        if (prefix.scientific) {
          var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
          if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
            bestPrefix = prefix;
            bestDiff = diff;
          }
        }
      }
    }
    return bestPrefix;
  };
  Unit.prototype.splitUnit = function(parts) {
    var x2 = this.clone();
    var ret = [];
    for (var i = 0; i < parts.length; i++) {
      x2 = x2.to(parts[i]);
      if (i === parts.length - 1)
        break;
      var xNumeric = x2.toNumeric();
      var xRounded = round2(xNumeric);
      var xFixed = void 0;
      var isNearlyEqual = equal(xRounded, xNumeric);
      if (isNearlyEqual) {
        xFixed = xRounded;
      } else {
        xFixed = fix(x2.toNumeric());
      }
      var y2 = new Unit(xFixed, parts[i].toString());
      ret.push(y2);
      x2 = subtractScalar(x2, y2);
    }
    var testSum = 0;
    for (var _i5 = 0; _i5 < ret.length; _i5++) {
      testSum = addScalar(testSum, ret[_i5].value);
    }
    if (equal(testSum, this.value)) {
      x2.value = 0;
    }
    ret.push(x2);
    return ret;
  };
  var PREFIXES = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: true
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 10,
        scientific: false
      },
      h: {
        name: "h",
        value: 100,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-3,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-6,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-9,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-12,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-15,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-18,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-21,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-24,
        scientific: true
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: false
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: false
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: false
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: false
      },
      milli: {
        name: "milli",
        value: 1e-3,
        scientific: true
      },
      micro: {
        name: "micro",
        value: 1e-6,
        scientific: true
      },
      nano: {
        name: "nano",
        value: 1e-9,
        scientific: true
      },
      pico: {
        name: "pico",
        value: 1e-12,
        scientific: true
      },
      femto: {
        name: "femto",
        value: 1e-15,
        scientific: true
      },
      atto: {
        name: "atto",
        value: 1e-18,
        scientific: true
      },
      zepto: {
        name: "zepto",
        value: 1e-21,
        scientific: true
      },
      yocto: {
        name: "yocto",
        value: 1e-24,
        scientific: true
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 100,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e12,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e18,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e24,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e30,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e36,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e42,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e48,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-4,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-6,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-12,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-18,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-24,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-30,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-36,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-42,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-48,
        scientific: true
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 1e3,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e18,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e27,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e36,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e45,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e54,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e63,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e72,
        scientific: true
      },
      d: {
        name: "d",
        value: 1e-3,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-6,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-9,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-18,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-27,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-36,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-45,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-54,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-63,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-72,
        scientific: true
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: true
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: true
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: true
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: true
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: true
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: true
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: true
      }
    }
  };
  PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
  PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
  PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var key in BASE_UNITS) {
    if (hasOwnProperty(BASE_UNITS, key)) {
      BASE_UNITS[key].key = key;
    }
  }
  var BASE_UNIT_NONE = {};
  var UNIT_NONE = {
    name: "",
    base: BASE_UNIT_NONE,
    value: 1,
    offset: 0,
    dimensions: BASE_DIMENSIONS.map((x2) => 0)
  };
  var UNITS = {
    // length
    meter: {
      name: "meter",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1e-10,
      offset: 0
    },
    m: {
      name: "m",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 254e-7,
      offset: 0
    },
    // 1/1000 inch
    // Surface
    m2: {
      name: "m2",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-8,
      offset: 0
    },
    // 645.16 mm2
    sqft: {
      name: "sqft",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    },
    // 0.09290304 m2
    sqyd: {
      name: "sqyd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    },
    // 0.83612736 m2
    sqmi: {
      name: "sqmi",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988110336e-6,
      offset: 0
    },
    // 2.589988110336 km2
    sqrd: {
      name: "sqrd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    },
    // 25.29295 m2
    sqch: {
      name: "sqch",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    },
    // 404.6873 m2
    sqmil: {
      name: "sqmil",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-14,
      offset: 0
    },
    // 6.4516 * 10^-10 m2
    acre: {
      name: "acre",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    },
    // 4046.86 m2
    hectare: {
      name: "hectare",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 1e4,
      offset: 0
    },
    // 10000 m2
    // Volume
    m3: {
      name: "m3",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    l: {
      name: "l",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    litre: {
      name: "litre",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 16387064e-12,
      offset: 0
    },
    // 1.6387064e-5 m3
    cuft: {
      name: "cuft",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    },
    // 28.316 846 592 L
    cuyd: {
      name: "cuyd",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    },
    // 764.554 857 984 L
    teaspoon: {
      name: "teaspoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-6,
      offset: 0
    },
    // 5 mL
    tablespoon: {
      name: "tablespoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 15e-6,
      offset: 0
    },
    // 15 mL
    // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: "drop",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    gtt: {
      name: "gtt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    // Liquid volume
    minim: {
      name: "minim",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 6161152e-14,
      offset: 0
    },
    // 0.06161152 mL
    fluiddram: {
      name: "fluiddram",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    fluidounce: {
      name: "fluidounce",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gill: {
      name: "gill",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cc: {
      name: "cc",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1e-6,
      offset: 0
    },
    // 1e-6 L
    cup: {
      name: "cup",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pint: {
      name: "pint",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    quart: {
      name: "quart",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gallon: {
      name: "gallon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    beerbarrel: {
      name: "beerbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    oilbarrel: {
      name: "oilbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    hogshead: {
      name: "hogshead",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.238481,
      offset: 0
    },
    // 238.4810 L
    // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
    fldr: {
      name: "fldr",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    floz: {
      name: "floz",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gi: {
      name: "gi",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cp: {
      name: "cp",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pt: {
      name: "pt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    qt: {
      name: "qt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gal: {
      name: "gal",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    bbl: {
      name: "bbl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    obl: {
      name: "obl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
    // Mass
    g: {
      name: "g",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    gram: {
      name: "gram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    ton: {
      name: "ton",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e3,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e3,
      offset: 0
    },
    grain: {
      name: "grain",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dram: {
      name: "dram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dr: {
      name: "dr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    // Time
    s: {
      name: "s",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800,
      // 1/12th of Julian year
      offset: 0
    },
    year: {
      name: "year",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600,
      // Julian year
      offset: 0
    },
    decade: {
      name: "decade",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e3,
      // Julian decade
      offset: 0
    },
    century: {
      name: "century",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e4,
      // Julian century
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e5,
      // Julian millennium
      offset: 0
    },
    // Frequency
    hertz: {
      name: "Hertz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: "Hz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    // Angle
    rad: {
      name: "rad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: "deg",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    degree: {
      name: "degree",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: "grad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: "cycle",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: "arcsec",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: "arcmin",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // Electric current
    A: {
      name: "A",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // Temperature
    // K(C) = °C + 273.15
    // K(F) = (°F + 459.67) * (5 / 9)
    // K(R) = °R * (5 / 9)
    K: {
      name: "K",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 0
    },
    // amount of substance
    mol: {
      name: "mol",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // luminous intensity
    cd: {
      name: "cd",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // Force
    N: {
      name: "N",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1e-5,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1e-5,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    // Energy
    J: {
      name: "J",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORTLONG,
      // Both kiloerg and kerg are acceptable
      value: 1e-7,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1602176565e-28,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1602176565e-28,
      offset: 0
    },
    // Power
    W: {
      name: "W",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },
    // Electrical power units
    VAR: {
      name: "VAR",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex3.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Pressure
    Pa: {
      name: "Pa",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },
    // Electric charge
    coulomb: {
      name: "coulomb",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: "farad",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: "volt",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: "ohm",
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,
      // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    Ω: {
      name: 'Ω',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: "henry",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: "siemens",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: "weber",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: "tesla",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Binary
    b: {
      name: "b",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };
  var ALIASES = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fluiddrams: "fluiddram",
    fluidounces: "fluidounce",
    gills: "gill",
    cups: "cup",
    pints: "pint",
    quarts: "quart",
    gallons: "gallon",
    beerbarrels: "beerbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    amps: "ampere",
    amp: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function calculateAngleValues(config5) {
    if (config5.number === "BigNumber") {
      var pi4 = createBigNumberPi(_BigNumber);
      UNITS.rad.value = new _BigNumber(1);
      UNITS.deg.value = pi4.div(180);
      UNITS.grad.value = pi4.div(200);
      UNITS.cycle.value = pi4.times(2);
      UNITS.arcsec.value = pi4.div(648e3);
      UNITS.arcmin.value = pi4.div(10800);
    } else {
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;
      UNITS.grad.value = Math.PI / 200;
      UNITS.cycle.value = Math.PI * 2;
      UNITS.arcsec.value = Math.PI / 648e3;
      UNITS.arcmin.value = Math.PI / 10800;
    }
    UNITS.radian.value = UNITS.rad.value;
    UNITS.degree.value = UNITS.deg.value;
    UNITS.gradian.value = UNITS.grad.value;
  }
  calculateAngleValues(config4);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.number !== prev.number) {
        calculateAngleValues(curr);
      }
    });
  }
  var UNIT_SYSTEMS = {
    si: {
      // Base units
      NONE: {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE[""]
      },
      LENGTH: {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT[""]
      },
      MASS: {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT.k
      },
      TIME: {
        unit: UNITS.s,
        prefix: PREFIXES.SHORT[""]
      },
      CURRENT: {
        unit: UNITS.A,
        prefix: PREFIXES.SHORT[""]
      },
      TEMPERATURE: {
        unit: UNITS.K,
        prefix: PREFIXES.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: UNITS.cd,
        prefix: PREFIXES.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: UNITS.mol,
        prefix: PREFIXES.SHORT[""]
      },
      ANGLE: {
        unit: UNITS.rad,
        prefix: PREFIXES.SHORT[""]
      },
      BIT: {
        unit: UNITS.bits,
        prefix: PREFIXES.SHORT[""]
      },
      // Derived units
      FORCE: {
        unit: UNITS.N,
        prefix: PREFIXES.SHORT[""]
      },
      ENERGY: {
        unit: UNITS.J,
        prefix: PREFIXES.SHORT[""]
      },
      POWER: {
        unit: UNITS.W,
        prefix: PREFIXES.SHORT[""]
      },
      PRESSURE: {
        unit: UNITS.Pa,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: UNITS.C,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: UNITS.F,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: UNITS.V,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: UNITS.ohm,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: UNITS.H,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: UNITS.S,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: UNITS.Wb,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: UNITS.T,
        prefix: PREFIXES.SHORT[""]
      },
      FREQUENCY: {
        unit: UNITS.Hz,
        prefix: PREFIXES.SHORT[""]
      }
    }
  };
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {
    unit: UNITS.m,
    prefix: PREFIXES.SHORT.c
  };
  UNIT_SYSTEMS.cgs.MASS = {
    unit: UNITS.g,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.FORCE = {
    unit: UNITS.dyn,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.ENERGY = {
    unit: UNITS.erg,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH = {
    unit: UNITS.ft,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.MASS = {
    unit: UNITS.lbm,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.TEMPERATURE = {
    unit: UNITS.degF,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.FORCE = {
    unit: UNITS.lbf,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.ENERGY = {
    unit: UNITS.BTU,
    prefix: PREFIXES.BTU[""]
  };
  UNIT_SYSTEMS.us.POWER = {
    unit: UNITS.hp,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.PRESSURE = {
    unit: UNITS.psi,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  var currentUnitSystem = UNIT_SYSTEMS.auto;
  Unit.setUnitSystem = function(name310) {
    if (hasOwnProperty(UNIT_SYSTEMS, name310)) {
      currentUnitSystem = UNIT_SYSTEMS[name310];
    } else {
      throw new Error("Unit system " + name310 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
    }
  };
  Unit.getUnitSystem = function() {
    for (var _key in UNIT_SYSTEMS) {
      if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
        if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
          return _key;
        }
      }
    }
  };
  Unit.typeConverters = {
    BigNumber: function BigNumber2(x2) {
      if (x2 !== null && x2 !== void 0 && x2.isFraction)
        return new _BigNumber(x2.n).div(x2.d).times(x2.s);
      return new _BigNumber(x2 + "");
    },
    Fraction: function Fraction3(x2) {
      return new _Fraction(x2);
    },
    Complex: function Complex4(x2) {
      return x2;
    },
    number: function number5(x2) {
      if (x2 !== null && x2 !== void 0 && x2.isFraction)
        return _number(x2);
      return x2;
    }
  };
  Unit.prototype._numberConverter = function() {
    var convert = Unit.typeConverters[this.valueType()];
    if (convert) {
      return convert;
    }
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  };
  Unit._getNumberConverter = function(type) {
    if (!Unit.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }
    return Unit.typeConverters[type];
  };
  for (var _key2 in UNITS) {
    if (hasOwnProperty(UNITS, _key2)) {
      var unit2 = UNITS[_key2];
      unit2.dimensions = unit2.base.dimensions;
    }
  }
  for (var _name2 in ALIASES) {
    if (hasOwnProperty(ALIASES, _name2)) {
      var _unit2 = UNITS[ALIASES[_name2]];
      var alias = {};
      for (var _key3 in _unit2) {
        if (hasOwnProperty(_unit2, _key3)) {
          alias[_key3] = _unit2[_key3];
        }
      }
      alias.name = _name2;
      UNITS[_name2] = alias;
    }
  }
  Unit.isValidAlpha = function isValidAlpha(c3) {
    return /^[a-zA-Z]$/.test(c3);
  };
  function assertUnitNameIsValid(name310) {
    for (var i = 0; i < name310.length; i++) {
      c2 = name310.charAt(i);
      if (i === 0 && !Unit.isValidAlpha(c2)) {
        throw new Error('Invalid unit name (must begin with alpha character): "' + name310 + '"');
      }
      if (i > 0 && !(Unit.isValidAlpha(c2) || isDigit(c2))) {
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name310 + '"');
      }
    }
  }
  Unit.createUnit = function(obj, options) {
    if (typeof obj !== "object") {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }
    if (options && options.override) {
      for (var _key4 in obj) {
        if (hasOwnProperty(obj, _key4)) {
          Unit.deleteUnit(_key4);
        }
        if (obj[_key4].aliases) {
          for (var i = 0; i < obj[_key4].aliases.length; i++) {
            Unit.deleteUnit(obj[_key4].aliases[i]);
          }
        }
      }
    }
    var lastUnit;
    for (var _key5 in obj) {
      if (hasOwnProperty(obj, _key5)) {
        lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
      }
    }
    return lastUnit;
  };
  Unit.createUnitSingle = function(name310, obj) {
    if (typeof obj === "undefined" || obj === null) {
      obj = {};
    }
    if (typeof name310 !== "string") {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
    if (hasOwnProperty(UNITS, name310)) {
      throw new Error('Cannot create unit "' + name310 + '": a unit with that name already exists');
    }
    assertUnitNameIsValid(name310);
    var defUnit = null;
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes2;
    var baseName;
    if (obj && obj.type === "Unit") {
      defUnit = obj.clone();
    } else if (typeof obj === "string") {
      if (obj !== "") {
        definition = obj;
      }
    } else if (typeof obj === "object") {
      definition = obj.definition;
      prefixes2 = obj.prefixes;
      offset = obj.offset;
      baseName = obj.baseName;
      if (obj.aliases) {
        aliases = obj.aliases.valueOf();
      }
    } else {
      throw new TypeError('Cannot create unit "' + name310 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }
    if (aliases) {
      for (var i = 0; i < aliases.length; i++) {
        if (hasOwnProperty(UNITS, aliases[i])) {
          throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
        }
      }
    }
    if (definition && typeof definition === "string" && !defUnit) {
      try {
        defUnit = Unit.parse(definition, {
          allowNoUnits: true
        });
      } catch (ex) {
        ex.message = 'Could not create unit "' + name310 + '" from "' + definition + '": ' + ex.message;
        throw ex;
      }
    } else if (definition && definition.type === "Unit") {
      defUnit = definition.clone();
    }
    aliases = aliases || [];
    offset = offset || 0;
    if (prefixes2 && prefixes2.toUpperCase) {
      prefixes2 = PREFIXES[prefixes2.toUpperCase()] || PREFIXES.NONE;
    } else {
      prefixes2 = PREFIXES.NONE;
    }
    var newUnit = {};
    if (!defUnit) {
      baseName = baseName || name310 + "_STUFF";
      if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name310 + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);
      for (var b in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
        }
      }
      var newBaseUnit = {
        dimensions: []
      };
      for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
        newBaseUnit.dimensions[_i6] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
      newUnit = {
        name: name310,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes: prefixes2,
        offset,
        base: BASE_UNITS[baseName]
      };
      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE[""]
      };
    } else {
      newUnit = {
        name: name310,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes: prefixes2,
        offset
      };
      var anyMatch = false;
      for (var _i7 in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, _i7)) {
          var match = true;
          for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
              match = false;
              break;
            }
          }
          if (match) {
            anyMatch = true;
            newUnit.base = BASE_UNITS[_i7];
            break;
          }
        }
      }
      if (!anyMatch) {
        baseName = baseName || name310 + "_STUFF";
        var _newBaseUnit = {
          dimensions: defUnit.dimensions.slice(0)
        };
        _newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = _newBaseUnit;
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
        newUnit.base = BASE_UNITS[baseName];
      }
    }
    Unit.UNITS[name310] = newUnit;
    for (var _i8 = 0; _i8 < aliases.length; _i8++) {
      var aliasName = aliases[_i8];
      var _alias = {};
      for (var _key6 in newUnit) {
        if (hasOwnProperty(newUnit, _key6)) {
          _alias[_key6] = newUnit[_key6];
        }
      }
      _alias.name = aliasName;
      Unit.UNITS[aliasName] = _alias;
    }
    delete _findUnit.cache;
    return new Unit(null, name310);
  };
  Unit.deleteUnit = function(name310) {
    delete Unit.UNITS[name310];
  };
  Unit.PREFIXES = PREFIXES;
  Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
  Unit.BASE_UNITS = BASE_UNITS;
  Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
  Unit.UNITS = UNITS;
  return Unit;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/unit/function/unit.js
var name162 = "unit";
var dependencies162 = ["typed", "Unit"];
var createUnitFunction = /* @__PURE__ */ factory(name162, dependencies162, (_ref) => {
  var {
    typed: typed3,
    Unit
  } = _ref;
  return typed3(name162, {
    Unit: function Unit2(x2) {
      return x2.clone();
    },
    string: function string(x2) {
      if (Unit.isValuelessUnit(x2)) {
        return new Unit(null, x2);
      }
      return Unit.parse(x2, {
        allowNoUnits: true
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit2) {
      return new Unit(value, unit2);
    },
    "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
      return new Unit(value);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x2) => deepMap(x2, self2))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
var name163 = "sparse";
var dependencies163 = ["typed", "SparseMatrix"];
var createSparse = /* @__PURE__ */ factory(name163, dependencies163, (_ref) => {
  var {
    typed: typed3,
    SparseMatrix
  } = _ref;
  return typed3(name163, {
    "": function _() {
      return new SparseMatrix([]);
    },
    string: function string(datatype) {
      return new SparseMatrix([], datatype);
    },
    "Array | Matrix": function ArrayMatrix(data) {
      return new SparseMatrix(data);
    },
    "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
      return new SparseMatrix(data, datatype);
    }
  });
});

// node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
var name164 = "createUnit";
var dependencies164 = ["typed", "Unit"];
var createCreateUnit = /* @__PURE__ */ factory(name164, dependencies164, (_ref) => {
  var {
    typed: typed3,
    Unit
  } = _ref;
  return typed3(name164, {
    // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
    "Object, Object": function ObjectObject(obj, options) {
      return Unit.createUnit(obj, options);
    },
    // Same as above but without the options.
    Object: function Object2(obj) {
      return Unit.createUnit(obj, {});
    },
    // Shortcut method for creating one unit.
    "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name310, def, options) {
      var obj = {};
      obj[name310] = def;
      return Unit.createUnit(obj, options);
    },
    // Same as above but without the options.
    "string, Unit | string | Object": function stringUnitStringObject(name310, def) {
      var obj = {};
      obj[name310] = def;
      return Unit.createUnit(obj, {});
    },
    // Without a definition, creates a base unit.
    string: function string(name310) {
      var obj = {};
      obj[name310] = {};
      return Unit.createUnit(obj, {});
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acos.js
var name165 = "acos";
var dependencies165 = ["typed", "config", "Complex"];
var createAcos = /* @__PURE__ */ factory(name165, dependencies165, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3
  } = _ref;
  return typed3(name165, {
    number: function number5(x2) {
      if (x2 >= -1 && x2 <= 1 || config4.predictable) {
        return Math.acos(x2);
      } else {
        return new Complex3(x2, 0).acos();
      }
    },
    Complex: function Complex4(x2) {
      return x2.acos();
    },
    BigNumber: function BigNumber2(x2) {
      return x2.acos();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
var name166 = "acosh";
var dependencies166 = ["typed", "config", "Complex"];
var createAcosh = /* @__PURE__ */ factory(name166, dependencies166, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3
  } = _ref;
  return typed3(name166, {
    number: function number5(x2) {
      if (x2 >= 1 || config4.predictable) {
        return acoshNumber(x2);
      }
      if (x2 <= -1) {
        return new Complex3(Math.log(Math.sqrt(x2 * x2 - 1) - x2), Math.PI);
      }
      return new Complex3(x2, 0).acosh();
    },
    Complex: function Complex4(x2) {
      return x2.acosh();
    },
    BigNumber: function BigNumber2(x2) {
      return x2.acosh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acot.js
var name167 = "acot";
var dependencies167 = ["typed", "BigNumber"];
var createAcot = /* @__PURE__ */ factory(name167, dependencies167, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name167, {
    number: acotNumber,
    Complex: function Complex3(x2) {
      return x2.acot();
    },
    BigNumber: function BigNumber2(x2) {
      return new _BigNumber(1).div(x2).atan();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
var name168 = "acoth";
var dependencies168 = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = /* @__PURE__ */ factory(name168, dependencies168, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name168, {
    number: function number5(x2) {
      if (x2 >= 1 || x2 <= -1 || config4.predictable) {
        return acothNumber(x2);
      }
      return new Complex3(x2, 0).acoth();
    },
    Complex: function Complex4(x2) {
      return x2.acoth();
    },
    BigNumber: function BigNumber2(x2) {
      return new _BigNumber(1).div(x2).atanh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
var name169 = "acsc";
var dependencies169 = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = /* @__PURE__ */ factory(name169, dependencies169, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name169, {
    number: function number5(x2) {
      if (x2 <= -1 || x2 >= 1 || config4.predictable) {
        return acscNumber(x2);
      }
      return new Complex3(x2, 0).acsc();
    },
    Complex: function Complex4(x2) {
      return x2.acsc();
    },
    BigNumber: function BigNumber2(x2) {
      return new _BigNumber(1).div(x2).asin();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
var name170 = "acsch";
var dependencies170 = ["typed", "BigNumber"];
var createAcsch = /* @__PURE__ */ factory(name170, dependencies170, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name170, {
    number: acschNumber,
    Complex: function Complex3(x2) {
      return x2.acsch();
    },
    BigNumber: function BigNumber2(x2) {
      return new _BigNumber(1).div(x2).asinh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asec.js
var name171 = "asec";
var dependencies171 = ["typed", "config", "Complex", "BigNumber"];
var createAsec = /* @__PURE__ */ factory(name171, dependencies171, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name171, {
    number: function number5(x2) {
      if (x2 <= -1 || x2 >= 1 || config4.predictable) {
        return asecNumber(x2);
      }
      return new Complex3(x2, 0).asec();
    },
    Complex: function Complex4(x2) {
      return x2.asec();
    },
    BigNumber: function BigNumber2(x2) {
      return new _BigNumber(1).div(x2).acos();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asech.js
var name172 = "asech";
var dependencies172 = ["typed", "config", "Complex", "BigNumber"];
var createAsech = /* @__PURE__ */ factory(name172, dependencies172, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name172, {
    number: function number5(x2) {
      if (x2 <= 1 && x2 >= -1 || config4.predictable) {
        var xInv = 1 / x2;
        if (xInv > 0 || config4.predictable) {
          return asechNumber(x2);
        }
        var ret = Math.sqrt(xInv * xInv - 1);
        return new Complex3(Math.log(ret - xInv), Math.PI);
      }
      return new Complex3(x2, 0).asech();
    },
    Complex: function Complex4(x2) {
      return x2.asech();
    },
    BigNumber: function BigNumber2(x2) {
      return new _BigNumber(1).div(x2).acosh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asin.js
var name173 = "asin";
var dependencies173 = ["typed", "config", "Complex"];
var createAsin = /* @__PURE__ */ factory(name173, dependencies173, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3
  } = _ref;
  return typed3(name173, {
    number: function number5(x2) {
      if (x2 >= -1 && x2 <= 1 || config4.predictable) {
        return Math.asin(x2);
      } else {
        return new Complex3(x2, 0).asin();
      }
    },
    Complex: function Complex4(x2) {
      return x2.asin();
    },
    BigNumber: function BigNumber2(x2) {
      return x2.asin();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
var name174 = "asinh";
var dependencies174 = ["typed"];
var createAsinh = /* @__PURE__ */ factory(name174, dependencies174, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("asinh", {
    number: asinhNumber,
    Complex: function Complex3(x2) {
      return x2.asinh();
    },
    BigNumber: function BigNumber2(x2) {
      return x2.asinh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan.js
var name175 = "atan";
var dependencies175 = ["typed"];
var createAtan = /* @__PURE__ */ factory(name175, dependencies175, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("atan", {
    number: function number5(x2) {
      return Math.atan(x2);
    },
    Complex: function Complex3(x2) {
      return x2.atan();
    },
    BigNumber: function BigNumber2(x2) {
      return x2.atan();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
var name176 = "atan2";
var dependencies176 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
var createAtan2 = /* @__PURE__ */ factory(name176, dependencies176, (_ref) => {
  var {
    typed: typed3,
    matrix,
    equalScalar,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed3,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name176, {
    "number, number": Math.atan2,
    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored
    // the imaginary.
    "BigNumber, BigNumber": (y2, x2) => BigNumber2.atan2(y2, x2)
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SS: matAlgo09xS0Sf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
var name177 = "atanh";
var dependencies177 = ["typed", "config", "Complex"];
var createAtanh = /* @__PURE__ */ factory(name177, dependencies177, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    Complex: Complex3
  } = _ref;
  return typed3(name177, {
    number: function number5(x2) {
      if (x2 <= 1 && x2 >= -1 || config4.predictable) {
        return atanhNumber(x2);
      }
      return new Complex3(x2, 0).atanh();
    },
    Complex: function Complex4(x2) {
      return x2.atanh();
    },
    BigNumber: function BigNumber2(x2) {
      return x2.atanh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
var createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return {
    Unit: typed3.referToSelf((self2) => (x2) => {
      if (!x2.hasBase(x2.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed3.find(self2, x2.valueType())(x2.value);
    })
  };
});

// node_modules/mathjs/lib/esm/function/trigonometry/cos.js
var name178 = "cos";
var dependencies178 = ["typed"];
var createCos = /* @__PURE__ */ factory(name178, dependencies178, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name178, {
    number: Math.cos,
    "Complex | BigNumber": (x2) => x2.cos()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
var name179 = "cosh";
var dependencies179 = ["typed"];
var createCosh = /* @__PURE__ */ factory(name179, dependencies179, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name179, {
    number: cosh,
    "Complex | BigNumber": (x2) => x2.cosh()
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/cot.js
var name180 = "cot";
var dependencies180 = ["typed", "BigNumber"];
var createCot = /* @__PURE__ */ factory(name180, dependencies180, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name180, {
    number: cotNumber,
    Complex: (x2) => x2.cot(),
    BigNumber: (x2) => new _BigNumber(1).div(x2.tan())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/coth.js
var name181 = "coth";
var dependencies181 = ["typed", "BigNumber"];
var createCoth = /* @__PURE__ */ factory(name181, dependencies181, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name181, {
    number: cothNumber,
    Complex: (x2) => x2.coth(),
    BigNumber: (x2) => new _BigNumber(1).div(x2.tanh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/csc.js
var name182 = "csc";
var dependencies182 = ["typed", "BigNumber"];
var createCsc = /* @__PURE__ */ factory(name182, dependencies182, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name182, {
    number: cscNumber,
    Complex: (x2) => x2.csc(),
    BigNumber: (x2) => new _BigNumber(1).div(x2.sin())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/csch.js
var name183 = "csch";
var dependencies183 = ["typed", "BigNumber"];
var createCsch = /* @__PURE__ */ factory(name183, dependencies183, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name183, {
    number: cschNumber,
    Complex: (x2) => x2.csch(),
    BigNumber: (x2) => new _BigNumber(1).div(x2.sinh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/sec.js
var name184 = "sec";
var dependencies184 = ["typed", "BigNumber"];
var createSec = /* @__PURE__ */ factory(name184, dependencies184, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name184, {
    number: secNumber,
    Complex: (x2) => x2.sec(),
    BigNumber: (x2) => new _BigNumber(1).div(x2.cos())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/sech.js
var name185 = "sech";
var dependencies185 = ["typed", "BigNumber"];
var createSech = /* @__PURE__ */ factory(name185, dependencies185, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name185, {
    number: sechNumber,
    Complex: (x2) => x2.sech(),
    BigNumber: (x2) => new _BigNumber(1).div(x2.cosh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/sin.js
var name186 = "sin";
var dependencies186 = ["typed"];
var createSin = /* @__PURE__ */ factory(name186, dependencies186, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name186, {
    number: Math.sin,
    "Complex | BigNumber": (x2) => x2.sin()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
var name187 = "sinh";
var dependencies187 = ["typed"];
var createSinh = /* @__PURE__ */ factory(name187, dependencies187, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name187, {
    number: sinhNumber,
    "Complex | BigNumber": (x2) => x2.sinh()
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/tan.js
var name188 = "tan";
var dependencies188 = ["typed"];
var createTan = /* @__PURE__ */ factory(name188, dependencies188, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name188, {
    number: Math.tan,
    "Complex | BigNumber": (x2) => x2.tan()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
var name189 = "tanh";
var dependencies189 = ["typed"];
var createTanh = /* @__PURE__ */ factory(name189, dependencies189, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("tanh", {
    number: tanh,
    "Complex | BigNumber": (x2) => x2.tanh()
  });
});

// node_modules/mathjs/lib/esm/function/set/setCartesian.js
var name190 = "setCartesian";
var dependencies190 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetCartesian = /* @__PURE__ */ factory(name190, dependencies190, (_ref) => {
  var {
    typed: typed3,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed3(name190, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result = [];
      if (subset(size(a1), new Index(0)) !== 0 && subset(size(a2), new Index(0)) !== 0) {
        var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
        var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
        result = [];
        for (var i = 0; i < b1.length; i++) {
          for (var j = 0; j < b2.length; j++) {
            result.push([b1[i], b2[j]]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setDifference.js
var name191 = "setDifference";
var dependencies191 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDifference = /* @__PURE__ */ factory(name191, dependencies191, (_ref) => {
  var {
    typed: typed3,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed3(name191, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset(size(a1), new Index(0)) === 0) {
        result = [];
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1.toArray());
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        result = [];
        var inb2;
        for (var i = 0; i < b1.length; i++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (!inb2) {
            result.push(b1[i]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setDistinct.js
var name192 = "setDistinct";
var dependencies192 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDistinct = /* @__PURE__ */ factory(name192, dependencies192, (_ref) => {
  var {
    typed: typed3,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed3(name192, {
    "Array | Matrix": function ArrayMatrix(a2) {
      var result;
      if (subset(size(a2), new Index(0)) === 0) {
        result = [];
      } else {
        var b = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
        result = [];
        result.push(b[0]);
        for (var i = 1; i < b.length; i++) {
          if (compareNatural(b[i], b[i - 1]) !== 0) {
            result.push(b[i]);
          }
        }
      }
      if (Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setIntersect.js
var name193 = "setIntersect";
var dependencies193 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetIntersect = /* @__PURE__ */ factory(name193, dependencies193, (_ref) => {
  var {
    typed: typed3,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed3(name193, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset(size(a1), new Index(0)) === 0 || subset(size(a2), new Index(0)) === 0) {
        result = [];
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        result = [];
        for (var i = 0; i < b1.length; i++) {
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              result.push(b1[i]);
              break;
            }
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setIsSubset.js
var name194 = "setIsSubset";
var dependencies194 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = /* @__PURE__ */ factory(name194, dependencies194, (_ref) => {
  var {
    typed: typed3,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed3(name194, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return true;
      } else if (subset(size(a2), new Index(0)) === 0) {
        return false;
      }
      var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
      var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
      var inb2;
      for (var i = 0; i < b1.length; i++) {
        inb2 = false;
        for (var j = 0; j < b2.length; j++) {
          if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
            inb2 = true;
            break;
          }
        }
        if (inb2 === false) {
          return false;
        }
      }
      return true;
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
var name195 = "setMultiplicity";
var dependencies195 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = /* @__PURE__ */ factory(name195, dependencies195, (_ref) => {
  var {
    typed: typed3,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed3(name195, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e3, a2) {
      if (subset(size(a2), new Index(0)) === 0) {
        return 0;
      }
      var b = flatten(Array.isArray(a2) ? a2 : a2.toArray());
      var count = 0;
      for (var i = 0; i < b.length; i++) {
        if (compareNatural(b[i], e3) === 0) {
          count++;
        }
      }
      return count;
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setPowerset.js
var name196 = "setPowerset";
var dependencies196 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = /* @__PURE__ */ factory(name196, dependencies196, (_ref) => {
  var {
    typed: typed3,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed3(name196, {
    "Array | Matrix": function ArrayMatrix(a2) {
      if (subset(size(a2), new Index(0)) === 0) {
        return [];
      }
      var b = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
      var result = [];
      var number5 = 0;
      while (number5.toString(2).length <= b.length) {
        result.push(_subset(b, number5.toString(2).split("").reverse()));
        number5++;
      }
      return _sort(result);
    }
  });
  function _subset(array2, bitarray) {
    var result = [];
    for (var i = 0; i < bitarray.length; i++) {
      if (bitarray[i] === "1") {
        result.push(array2[i]);
      }
    }
    return result;
  }
  function _sort(array2) {
    var temp = [];
    for (var i = array2.length - 1; i > 0; i--) {
      for (var j = 0; j < i; j++) {
        if (array2[j].length > array2[j + 1].length) {
          temp = array2[j];
          array2[j] = array2[j + 1];
          array2[j + 1] = temp;
        }
      }
    }
    return array2;
  }
});

// node_modules/mathjs/lib/esm/function/set/setSize.js
var name197 = "setSize";
var dependencies197 = ["typed", "compareNatural"];
var createSetSize = /* @__PURE__ */ factory(name197, dependencies197, (_ref) => {
  var {
    typed: typed3,
    compareNatural
  } = _ref;
  return typed3(name197, {
    "Array | Matrix": function ArrayMatrix(a2) {
      return Array.isArray(a2) ? flatten(a2).length : flatten(a2.toArray()).length;
    },
    "Array | Matrix, boolean": function ArrayMatrixBoolean(a2, unique) {
      if (unique === false || a2.length === 0) {
        return Array.isArray(a2) ? flatten(a2).length : flatten(a2.toArray()).length;
      } else {
        var b = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
        var count = 1;
        for (var i = 1; i < b.length; i++) {
          if (compareNatural(b[i], b[i - 1]) !== 0) {
            count++;
          }
        }
        return count;
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setSymDifference.js
var name198 = "setSymDifference";
var dependencies198 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
var createSetSymDifference = /* @__PURE__ */ factory(name198, dependencies198, (_ref) => {
  var {
    typed: typed3,
    size,
    concat: concat2,
    subset,
    setDifference,
    Index
  } = _ref;
  return typed3(name198, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return flatten(a2);
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat2(setDifference(b1, b2), setDifference(b2, b1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setUnion.js
var name199 = "setUnion";
var dependencies199 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
var createSetUnion = /* @__PURE__ */ factory(name199, dependencies199, (_ref) => {
  var {
    typed: typed3,
    size,
    concat: concat2,
    subset,
    setIntersect,
    setSymDifference,
    Index
  } = _ref;
  return typed3(name199, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return flatten(a2);
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat2(setSymDifference(b1, b2), setIntersect(b1, b2));
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/add.js
var name200 = "add";
var dependencies200 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
var createAdd = /* @__PURE__ */ factory(name200, dependencies200, (_ref) => {
  var {
    typed: typed3,
    matrix,
    addScalar,
    equalScalar,
    DenseMatrix: DenseMatrix2,
    SparseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed3,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix,
    concat: concat2
  });
  return typed3(name200, {
    "any, any": addScalar,
    "any, any, ...any": typed3.referToSelf((self2) => (x2, y2, rest) => {
      var result = self2(x2, y2);
      for (var i = 0; i < rest.length; i++) {
        result = self2(result, rest[i]);
      }
      return result;
    })
  }, matrixAlgorithmSuite({
    elop: addScalar,
    DS: matAlgo01xDSid,
    SS: matAlgo04xSidSid,
    Ss: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
var name201 = "hypot";
var dependencies201 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
var createHypot = /* @__PURE__ */ factory(name201, dependencies201, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    addScalar,
    divideScalar,
    multiplyScalar,
    sqrt: sqrt5,
    smaller,
    isPositive
  } = _ref;
  return typed3(name201, {
    "... number | BigNumber": _hypot,
    Array: _hypot,
    Matrix: (M) => _hypot(flatten(M.toArray()))
  });
  function _hypot(args) {
    var result = 0;
    var largest = 0;
    for (var i = 0; i < args.length; i++) {
      if (isComplex(args[i])) {
        throw new TypeError("Unexpected type of argument to hypot");
      }
      var value = abs3(args[i]);
      if (smaller(largest, value)) {
        result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
        result = addScalar(result, 1);
        largest = value;
      } else {
        result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
      }
    }
    return multiplyScalar(largest, sqrt5(result));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/norm.js
var name202 = "norm";
var dependencies202 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
var createNorm = /* @__PURE__ */ factory(name202, dependencies202, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    add: add2,
    pow: pow3,
    conj,
    sqrt: sqrt5,
    multiply,
    equalScalar,
    larger,
    smaller,
    matrix,
    ctranspose,
    eigs
  } = _ref;
  return typed3(name202, {
    number: Math.abs,
    Complex: function Complex3(x2) {
      return x2.abs();
    },
    BigNumber: function BigNumber2(x2) {
      return x2.abs();
    },
    boolean: function boolean(x2) {
      return Math.abs(x2);
    },
    Array: function Array2(x2) {
      return _norm(matrix(x2), 2);
    },
    Matrix: function Matrix2(x2) {
      return _norm(x2, 2);
    },
    "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x2, p) {
      return _norm(matrix(x2), p);
    },
    "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x2, p) {
      return _norm(x2, p);
    }
  });
  function _vectorNormPlusInfinity(x2) {
    var pinf = 0;
    x2.forEach(function(value) {
      var v = abs3(value);
      if (larger(v, pinf)) {
        pinf = v;
      }
    }, true);
    return pinf;
  }
  function _vectorNormMinusInfinity(x2) {
    var ninf;
    x2.forEach(function(value) {
      var v = abs3(value);
      if (!ninf || smaller(v, ninf)) {
        ninf = v;
      }
    }, true);
    return ninf || 0;
  }
  function _vectorNorm(x2, p) {
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _vectorNormPlusInfinity(x2);
    }
    if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
      return _vectorNormMinusInfinity(x2);
    }
    if (p === "fro") {
      return _norm(x2, 2);
    }
    if (typeof p === "number" && !isNaN(p)) {
      if (!equalScalar(p, 0)) {
        var n = 0;
        x2.forEach(function(value) {
          n = add2(pow3(abs3(value), p), n);
        }, true);
        return pow3(n, 1 / p);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function _matrixNormFrobenius(x2) {
    var fro = 0;
    x2.forEach(function(value, index) {
      fro = add2(fro, multiply(value, conj(value)));
    });
    return abs3(sqrt5(fro));
  }
  function _matrixNormOne(x2) {
    var c2 = [];
    var maxc = 0;
    x2.forEach(function(value, index) {
      var j = index[1];
      var cj = add2(c2[j] || 0, abs3(value));
      if (larger(cj, maxc)) {
        maxc = cj;
      }
      c2[j] = cj;
    }, true);
    return maxc;
  }
  function _matrixNormTwo(x2) {
    var sizeX = x2.size();
    if (sizeX[0] !== sizeX[1]) {
      throw new RangeError("Invalid matrix dimensions");
    }
    var tx = ctranspose(x2);
    var squaredX = multiply(tx, x2);
    var eigenVals = eigs(squaredX).values.toArray();
    var rho = eigenVals[eigenVals.length - 1];
    return abs3(sqrt5(rho));
  }
  function _matrixNormInfinity(x2) {
    var r = [];
    var maxr = 0;
    x2.forEach(function(value, index) {
      var i = index[0];
      var ri = add2(r[i] || 0, abs3(value));
      if (larger(ri, maxr)) {
        maxr = ri;
      }
      r[i] = ri;
    }, true);
    return maxr;
  }
  function _matrixNorm(x2, p) {
    if (p === 1) {
      return _matrixNormOne(x2);
    }
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _matrixNormInfinity(x2);
    }
    if (p === "fro") {
      return _matrixNormFrobenius(x2);
    }
    if (p === 2) {
      return _matrixNormTwo(x2);
    }
    throw new Error("Unsupported parameter value " + p);
  }
  function _norm(x2, p) {
    var sizeX = x2.size();
    if (sizeX.length === 1) {
      return _vectorNorm(x2, p);
    }
    if (sizeX.length === 2) {
      if (sizeX[0] && sizeX[1]) {
        return _matrixNorm(x2, p);
      } else {
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/dot.js
var name203 = "dot";
var dependencies203 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = /* @__PURE__ */ factory(name203, dependencies203, (_ref) => {
  var {
    typed: typed3,
    addScalar,
    multiplyScalar,
    conj,
    size
  } = _ref;
  return typed3(name203, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x2, y2) {
    var xSize = _size(x2);
    var ySize = _size(y2);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen)
      throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a2, b) {
    var N = _validateDim(a2, b);
    var adata = isMatrix(a2) ? a2._data : a2;
    var adt = isMatrix(a2) ? a2._datatype : void 0;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype : void 0;
    var aIsColumn = _size(a2).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add2 = addScalar;
    var mul2 = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      var dt = adt;
      add2 = typed3.find(addScalar, [dt, dt]);
      mul2 = typed3.find(multiplyScalar, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c2 = mul2(conj(adata[0]), bdata[0]);
      for (var i = 1; i < N; i++) {
        c2 = add2(c2, mul2(conj(adata[i]), bdata[i]));
      }
      return c2;
    }
    if (!aIsColumn && bIsColumn) {
      var _c = mul2(conj(adata[0]), bdata[0][0]);
      for (var _i = 1; _i < N; _i++) {
        _c = add2(_c, mul2(conj(adata[_i]), bdata[_i][0]));
      }
      return _c;
    }
    if (aIsColumn && !bIsColumn) {
      var _c2 = mul2(conj(adata[0][0]), bdata[0]);
      for (var _i2 = 1; _i2 < N; _i2++) {
        _c2 = add2(_c2, mul2(conj(adata[_i2][0]), bdata[_i2]));
      }
      return _c2;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul2(conj(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1; _i3 < N; _i3++) {
        _c3 = add2(_c3, mul2(conj(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x2, y2) {
    _validateDim(x2, y2);
    var xindex = x2._index;
    var xvalues = x2._values;
    var yindex = y2._index;
    var yvalues = y2._values;
    var c2 = 0;
    var add2 = addScalar;
    var mul2 = multiplyScalar;
    var i = 0;
    var j = 0;
    while (i < xindex.length && j < yindex.length) {
      var I = xindex[i];
      var J = yindex[j];
      if (I < J) {
        i++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c2 = add2(c2, mul2(xvalues[i], yvalues[j]));
        i++;
        j++;
      }
    }
    return c2;
  }
  function _size(x2) {
    return isMatrix(x2) ? x2.size() : size(x2);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/trace.js
var name204 = "trace";
var dependencies204 = ["typed", "matrix", "add"];
var createTrace = /* @__PURE__ */ factory(name204, dependencies204, (_ref) => {
  var {
    typed: typed3,
    matrix,
    add: add2
  } = _ref;
  return typed3("trace", {
    Array: function _arrayTrace(x2) {
      return _denseTrace(matrix(x2));
    },
    SparseMatrix: _sparseTrace,
    DenseMatrix: _denseTrace,
    any: clone
  });
  function _denseTrace(m) {
    var size = m._size;
    var data = m._data;
    switch (size.length) {
      case 1:
        if (size[0] === 1) {
          return clone(data[0]);
        }
        throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
      case 2: {
        var rows = size[0];
        var cols = size[1];
        if (rows === cols) {
          var sum3 = 0;
          for (var i = 0; i < rows; i++) {
            sum3 = add2(sum3, data[i][i]);
          }
          return sum3;
        } else {
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        }
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
    }
  }
  function _sparseTrace(m) {
    var values2 = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var size = m._size;
    var rows = size[0];
    var columns = size[1];
    if (rows === columns) {
      var sum3 = 0;
      if (values2.length > 0) {
        for (var j = 0; j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k2 = k0; k2 < k1; k2++) {
            var i = index[k2];
            if (i === j) {
              sum3 = add2(sum3, values2[k2]);
              break;
            }
            if (i > j) {
              break;
            }
          }
        }
      }
      return sum3;
    }
    throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
  }
});

// node_modules/mathjs/lib/esm/type/matrix/function/index.js
var name205 = "index";
var dependencies205 = ["typed", "Index"];
var createIndex = /* @__PURE__ */ factory(name205, dependencies205, (_ref) => {
  var {
    typed: typed3,
    Index
  } = _ref;
  return typed3(name205, {
    "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
      var ranges = args.map(function(arg) {
        if (isBigNumber(arg)) {
          return arg.toNumber();
        } else if (isArray(arg) || isMatrix(arg)) {
          return arg.map(function(elem) {
            return isBigNumber(elem) ? elem.toNumber() : elem;
          });
        } else {
          return arg;
        }
      });
      var res = new Index();
      Index.apply(res, ranges);
      return res;
    }
  });
});

// node_modules/mathjs/lib/esm/expression/keywords.js
var keywords = /* @__PURE__ */ new Set(["end"]);

// node_modules/mathjs/lib/esm/expression/node/Node.js
var name206 = "Node";
var dependencies206 = ["mathWithTransform"];
var createNode = /* @__PURE__ */ factory(name206, dependencies206, (_ref) => {
  var {
    mathWithTransform
  } = _ref;
  function _validateScope(scope) {
    for (var symbol of [...keywords]) {
      if (scope.has(symbol)) {
        throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
      }
    }
  }
  class Node {
    get type() {
      return "Node";
    }
    get isNode() {
      return true;
    }
    /**
     * Evaluate the node
     * @param {Object} [scope]  Scope to read/write variables
     * @return {*}              Returns the result
     */
    evaluate(scope) {
      return this.compile().evaluate(scope);
    }
    /**
     * Compile the node into an optimized, evauatable JavaScript function
     * @return {{evaluate: function([Object])}} object
     *                Returns an object with a function 'evaluate',
     *                which can be invoked as expr.evaluate([scope: Object]),
     *                where scope is an optional object with
     *                variables.
     */
    compile() {
      var expr = this._compile(mathWithTransform, {});
      var args = {};
      var context = null;
      function evaluate(scope) {
        var s2 = createMap(scope);
        _validateScope(s2);
        return expr(s2, args, context);
      }
      return {
        evaluate
      };
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      throw new Error("Method _compile must be implemented by type " + this.type);
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      throw new Error("Cannot run forEach on a Node interface");
    }
    /**
     * Create a new Node whose children are the results of calling the
     * provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(callback) {
      throw new Error("Cannot run map on a Node interface");
    }
    /**
     * Validate whether an object is a Node, for use with map
     * @param {Node} node
     * @returns {Node} Returns the input if it's a node, else throws an Error
     * @protected
     */
    _ifNode(node) {
      if (!isNode(node)) {
        throw new TypeError("Callback function must return a Node");
      }
      return node;
    }
    /**
     * Recursively traverse all nodes in a node tree. Executes given callback for
     * this node and each of its child nodes.
     * @param {function(node: Node, path: string, parent: Node)} callback
     *          A callback called for every node in the node tree.
     */
    traverse(callback) {
      callback(this, null, null);
      function _traverse(node, callback2) {
        node.forEach(function(child, path2, parent) {
          callback2(child, path2, parent);
          _traverse(child, callback2);
        });
      }
      _traverse(this, callback);
    }
    /**
     * Recursively transform a node tree via a transform function.
     *
     * For example, to replace all nodes of type SymbolNode having name 'x' with
     * a ConstantNode with value 2:
     *
     *     const res = Node.transform(function (node, path, parent) {
     *       if (node && node.isSymbolNode) && (node.name === 'x')) {
     *         return new ConstantNode(2)
     *       }
     *       else {
     *         return node
     *       }
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *          A mapping function accepting a node, and returning
     *          a replacement for the node or the original node. The "signature"
     *          of the callback must be:
     *          callback(node: Node, index: string, parent: Node) : Node
     * @return {Node} Returns the original node or its replacement
     */
    transform(callback) {
      function _transform(child, path2, parent) {
        var replacement = callback(child, path2, parent);
        if (replacement !== child) {
          return replacement;
        }
        return child.map(_transform);
      }
      return _transform(this, null, null);
    }
    /**
     * Find any node in the node tree matching given filter function. For
     * example, to find all nodes of type SymbolNode having name 'x':
     *
     *     const results = Node.filter(function (node) {
     *       return (node && node.isSymbolNode) && (node.name === 'x')
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *            A test function returning true when a node matches, and false
     *            otherwise. Function signature:
     *            callback(node: Node, index: string, parent: Node) : boolean
     * @return {Node[]} nodes
     *            An array with nodes matching given filter criteria
     */
    filter(callback) {
      var nodes = [];
      this.traverse(function(node, path2, parent) {
        if (callback(node, path2, parent)) {
          nodes.push(node);
        }
      });
      return nodes;
    }
    /**
     * Create a shallow clone of this node
     * @return {Node}
     */
    clone() {
      throw new Error("Cannot clone a Node interface");
    }
    /**
     * Create a deep clone of this node
     * @return {Node}
     */
    cloneDeep() {
      return this.map(function(node) {
        return node.cloneDeep();
      });
    }
    /**
     * Deep compare this node with another node.
     * @param {Node} other
     * @return {boolean} Returns true when both nodes are of the same type and
     *                   contain the same values (as do their childs)
     */
    equals(other) {
      return other ? this.type === other.type && deepStrictEqual(this, other) : false;
    }
    /**
     * Get string representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toString(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toString(options);
    }
    /**
     * Get a JSON representation of the node
     * Both .toJSON() and the static .fromJSON(json) should be implemented by all
     * implementations of Node
     * @returns {Object}
     */
    toJSON() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    }
    /**
     * Get HTML representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)" or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toHTML(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this.toHTML(options);
    }
    /**
     * Internal function to generate the string output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toString() {
      throw new Error("_toString not implemented for " + this.type);
    }
    /**
     * Get LaTeX representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toTex(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toTex(options);
    }
    /**
     * Internal function to generate the LaTeX output.
     * This has to be implemented by every Node
     *
     * @param {Object} [options]
     * @throws {Error}
     */
    _toTex(options) {
      throw new Error("_toTex not implemented for " + this.type);
    }
    /**
     * Helper used by `to...` functions.
     */
    _getCustomString(options) {
      if (options && typeof options === "object") {
        switch (typeof options.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return options.handler(this, options);
          default:
            throw new TypeError("Object or function expected as callback");
        }
      }
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type;
    }
    /**
     * Get the content of the current Node.
     * @return {Node} node
     **/
    getContent() {
      return this;
    }
  }
  return Node;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
function errorTransform(err) {
  if (err && err.isIndexError) {
    return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
  }
  return err;
}

// node_modules/mathjs/lib/esm/expression/node/utils/access.js
function accessFactory(_ref) {
  var {
    subset
  } = _ref;
  return function access(object, index) {
    try {
      if (Array.isArray(object)) {
        return subset(object, index);
      } else if (object && typeof object.subset === "function") {
        return object.subset(index);
      } else if (typeof object === "string") {
        return subset(object, index);
      } else if (typeof object === "object") {
        if (!index.isObjectProperty()) {
          throw new TypeError("Cannot apply a numeric index as object property");
        }
        return getSafeProperty(object, index.getObjectProperty());
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
var name207 = "AccessorNode";
var dependencies207 = ["subset", "Node"];
var createAccessorNode = /* @__PURE__ */ factory(name207, dependencies207, (_ref) => {
  var {
    subset,
    Node
  } = _ref;
  var access = accessFactory({
    subset
  });
  function needParenthesis(node) {
    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
  }
  class AccessorNode extends Node {
    /**
     * @constructor AccessorNode
     * @extends {Node}
     * Access an object property or get a matrix subset
     *
     * @param {Node} object                 The object from which to retrieve
     *                                      a property or subset.
     * @param {IndexNode} index             IndexNode containing ranges
     */
    constructor(object, index) {
      super();
      if (!isNode(object)) {
        throw new TypeError('Node expected for parameter "object"');
      }
      if (!isIndexNode(index)) {
        throw new TypeError('IndexNode expected for parameter "index"');
      }
      this.object = object;
      this.index = index;
    }
    // readonly property name
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name207;
    }
    get isAccessorNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var evalObject = this.object._compile(math, argNames);
      var evalIndex = this.index._compile(math, argNames);
      if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAccessorNode(scope, args, context) {
          return getSafeProperty(evalObject(scope, args, context), prop);
        };
      } else {
        return function evalAccessorNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var index = evalIndex(scope, args, object);
          return access(object, index);
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.object, "object", this);
      callback(this.index, "index", this);
    }
    /**
     * Create a new AccessorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AccessorNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new AccessorNode(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AccessorNode}
     */
    clone() {
      return new AccessorNode(this.object, this.index);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(options) {
      var object = this.object.toString(options);
      if (needParenthesis(this.object)) {
        object = "(" + object + ")";
      }
      return object + this.index.toString(options);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    toHTML(options) {
      var object = this.object.toHTML(options);
      if (needParenthesis(this.object)) {
        object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return object + this.index.toHTML(options);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(options) {
      var object = this.object.toTex(options);
      if (needParenthesis(this.object)) {
        object = "\\left(' + object + '\\right)";
      }
      return object + this.index.toTex(options);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name207,
        object: this.object,
        index: this.index
      };
    }
    /**
     * Instantiate an AccessorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
     *     where mathjs is optional
     * @returns {AccessorNode}
     */
    static fromJSON(json) {
      return new AccessorNode(json.object, json.index);
    }
  }
  _defineProperty(AccessorNode, "name", name207);
  return AccessorNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
var name208 = "ArrayNode";
var dependencies208 = ["Node"];
var createArrayNode = /* @__PURE__ */ factory(name208, dependencies208, (_ref) => {
  var {
    Node
  } = _ref;
  class ArrayNode extends Node {
    /**
     * @constructor ArrayNode
     * @extends {Node}
     * Holds an 1-dimensional array with items
     * @param {Node[]} [items]   1 dimensional array with items
     */
    constructor(items) {
      super();
      this.items = items || [];
      if (!Array.isArray(this.items) || !this.items.every(isNode)) {
        throw new TypeError("Array containing Nodes expected");
      }
    }
    get type() {
      return name208;
    }
    get isArrayNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var evalItems = map(this.items, function(item) {
        return item._compile(math, argNames);
      });
      var asMatrix = math.config.matrix !== "Array";
      if (asMatrix) {
        var matrix = math.matrix;
        return function evalArrayNode(scope, args, context) {
          return matrix(map(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          }));
        };
      } else {
        return function evalArrayNode(scope, args, context) {
          return map(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          });
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i = 0; i < this.items.length; i++) {
        var node = this.items[i];
        callback(node, "items[" + i + "]", this);
      }
    }
    /**
     * Create a new ArrayNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ArrayNode} Returns a transformed copy of the node
     */
    map(callback) {
      var items = [];
      for (var i = 0; i < this.items.length; i++) {
        items[i] = this._ifNode(callback(this.items[i], "items[" + i + "]", this));
      }
      return new ArrayNode(items);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ArrayNode}
     */
    clone() {
      return new ArrayNode(this.items.slice(0));
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      var items = this.items.map(function(node) {
        return node.toString(options);
      });
      return "[" + items.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name208,
        items: this.items
      };
    }
    /**
     * Instantiate an ArrayNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ArrayNode", items: [...]}`,
     *                       where mathjs is optional
     * @returns {ArrayNode}
     */
    static fromJSON(json) {
      return new ArrayNode(json.items);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toHTML(options) {
      var items = this.items.map(function(node) {
        return node.toHTML(options);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      function itemsToTex(items, nested) {
        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
        var itemsFormRow = nested || mixedItems;
        var itemSep = itemsFormRow ? "&" : "\\\\";
        var itemsTex = items.map(function(node) {
          if (node.items) {
            return itemsToTex(node.items, !nested);
          } else {
            return node.toTex(options);
          }
        }).join(itemSep);
        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
      }
      return itemsToTex(this.items, false);
    }
  }
  _defineProperty(ArrayNode, "name", name208);
  return ArrayNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/utils/assign.js
function assignFactory(_ref) {
  var {
    subset,
    matrix
  } = _ref;
  return function assign2(object, index, value) {
    try {
      if (Array.isArray(object)) {
        var result = matrix(object).subset(index, value).valueOf();
        result.forEach((item, index2) => {
          object[index2] = item;
        });
        return object;
      } else if (object && typeof object.subset === "function") {
        return object.subset(index, value);
      } else if (typeof object === "string") {
        return subset(object, index, value);
      } else if (typeof object === "object") {
        if (!index.isObjectProperty()) {
          throw TypeError("Cannot apply a numeric index as object property");
        }
        setSafeProperty(object, index.getObjectProperty(), value);
        return object;
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// node_modules/mathjs/lib/esm/expression/operators.js
var properties = [{
  // assignment
  AssignmentNode: {},
  FunctionAssignmentNode: {}
}, {
  // conditional expression
  ConditionalNode: {
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
    // conditionals don't need parentheses in LaTeX because
    // they are 2 dimensional
  }
}, {
  // logical or
  "OperatorNode:or": {
    op: "or",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical xor
  "OperatorNode:xor": {
    op: "xor",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical and
  "OperatorNode:and": {
    op: "and",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise or
  "OperatorNode:bitOr": {
    op: "|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise xor
  "OperatorNode:bitXor": {
    op: "^|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise and
  "OperatorNode:bitAnd": {
    op: "&",
    associativity: "left",
    associativeWith: []
  }
}, {
  // relational operators
  "OperatorNode:equal": {
    op: "==",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:unequal": {
    op: "!=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smaller": {
    op: "<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:larger": {
    op: ">",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smallerEq": {
    op: "<=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:largerEq": {
    op: ">=",
    associativity: "left",
    associativeWith: []
  },
  RelationalNode: {
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitshift operators
  "OperatorNode:leftShift": {
    op: "<<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightArithShift": {
    op: ">>",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightLogShift": {
    op: ">>>",
    associativity: "left",
    associativeWith: []
  }
}, {
  // unit conversion
  "OperatorNode:to": {
    op: "to",
    associativity: "left",
    associativeWith: []
  }
}, {
  // range
  RangeNode: {}
}, {
  // addition, subtraction
  "OperatorNode:add": {
    op: "+",
    associativity: "left",
    associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
  },
  "OperatorNode:subtract": {
    op: "-",
    associativity: "left",
    associativeWith: []
  }
}, {
  // multiply, divide, modulus
  "OperatorNode:multiply": {
    op: "*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  },
  "OperatorNode:divide": {
    op: "/",
    associativity: "left",
    associativeWith: [],
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
    // fractions don't require parentheses because
    // they're 2 dimensional, so parens aren't needed
    // in LaTeX
  },
  "OperatorNode:dotMultiply": {
    op: ".*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
  },
  "OperatorNode:dotDivide": {
    op: "./",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:mod": {
    op: "mod",
    associativity: "left",
    associativeWith: []
  }
}, {
  // Repeat multiplication for implicit multiplication
  "OperatorNode:multiply": {
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  }
}, {
  // unary prefix operators
  "OperatorNode:unaryPlus": {
    op: "+",
    associativity: "right"
  },
  "OperatorNode:unaryMinus": {
    op: "-",
    associativity: "right"
  },
  "OperatorNode:bitNot": {
    op: "~",
    associativity: "right"
  },
  "OperatorNode:not": {
    op: "not",
    associativity: "right"
  }
}, {
  // exponentiation
  "OperatorNode:pow": {
    op: "^",
    associativity: "right",
    associativeWith: [],
    latexRightParens: false
    // the exponent doesn't need parentheses in
    // LaTeX because it's 2 dimensional
    // (it's on top)
  },
  "OperatorNode:dotPow": {
    op: ".^",
    associativity: "right",
    associativeWith: []
  }
}, {
  // factorial
  "OperatorNode:factorial": {
    op: "!",
    associativity: "left"
  }
}, {
  // matrix transpose
  "OperatorNode:ctranspose": {
    op: "'",
    associativity: "left"
  }
}];
function unwrapParen(_node, parenthesis) {
  if (!parenthesis || parenthesis !== "auto")
    return _node;
  var node = _node;
  while (isParenthesisNode(node))
    node = node.content;
  return node;
}
function getPrecedence(_node, parenthesis, implicit2, parent) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var precedence = null;
  for (var i = 0; i < properties.length; i++) {
    if (identifier in properties[i]) {
      precedence = i;
      break;
    }
  }
  if (identifier === "OperatorNode:multiply" && node.implicit && implicit2 !== "show") {
    var leftArg = unwrapParen(node.args[0], parenthesis);
    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
      precedence += 1;
    }
  }
  return precedence;
}
function getAssociativity(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index = getPrecedence(node, parenthesis);
  if (index === null) {
    return null;
  }
  var property = properties[index][identifier];
  if (hasOwnProperty(property, "associativity")) {
    if (property.associativity === "left") {
      return "left";
    }
    if (property.associativity === "right") {
      return "right";
    }
    throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
  }
  return null;
}
function isAssociativeWith(nodeA, nodeB, parenthesis) {
  var a2 = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
  var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
  var identifierA = a2.getIdentifier();
  var identifierB = b.getIdentifier();
  var index = getPrecedence(a2, parenthesis);
  if (index === null) {
    return null;
  }
  var property = properties[index][identifierA];
  if (hasOwnProperty(property, "associativeWith") && property.associativeWith instanceof Array) {
    for (var i = 0; i < property.associativeWith.length; i++) {
      if (property.associativeWith[i] === identifierB) {
        return true;
      }
    }
    return false;
  }
  return null;
}
function getOperator(fn) {
  var identifier = "OperatorNode:" + fn;
  for (var group of properties) {
    if (identifier in group) {
      return group[identifier].op;
    }
  }
  return null;
}

// node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
var name209 = "AssignmentNode";
var dependencies209 = [
  "subset",
  "?matrix",
  // FIXME: should not be needed at all, should be handled by subset
  "Node"
];
var createAssignmentNode = /* @__PURE__ */ factory(name209, dependencies209, (_ref) => {
  var {
    subset,
    matrix,
    Node
  } = _ref;
  var access = accessFactory({
    subset
  });
  var assign2 = assignFactory({
    subset,
    matrix
  });
  function needParenthesis(node, parenthesis, implicit2) {
    if (!parenthesis) {
      parenthesis = "keep";
    }
    var precedence = getPrecedence(node, parenthesis, implicit2);
    var exprPrecedence = getPrecedence(node.value, parenthesis, implicit2);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }
  class AssignmentNode extends Node {
    /**
     * @constructor AssignmentNode
     * @extends {Node}
     *
     * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
     * replace a subset of a matrix like `A[2,2]=42`.
     *
     * Syntax:
     *
     *     new AssignmentNode(symbol, value)
     *     new AssignmentNode(object, index, value)
     *
     * Usage:
     *
     *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode('b'),
     *                       new ConstantNode(2))   // a.b=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode(1, 2),
     *                       new ConstantNode(3))  // a[1,2]=3
     *
     * @param {SymbolNode | AccessorNode} object
     *     Object on which to assign a value
     * @param {IndexNode} [index=null]
     *     Index, property name or matrix index. Optional. If not provided
     *     and `object` is a SymbolNode, the property is assigned to the
     *     global scope.
     * @param {Node} value
     *     The value to be assigned
     */
    constructor(object, index, value) {
      super();
      this.object = object;
      this.index = value ? index : null;
      this.value = value || index;
      if (!isSymbolNode(object) && !isAccessorNode(object)) {
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      }
      if (isSymbolNode(object) && object.name === "end") {
        throw new Error('Cannot assign to symbol "end"');
      }
      if (this.index && !isIndexNode(this.index)) {
        throw new TypeError('IndexNode expected as "index"');
      }
      if (!isNode(this.value)) {
        throw new TypeError('Node expected as "value"');
      }
    }
    // class name for typing purposes:
    // readonly property name
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name209;
    }
    get isAssignmentNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var evalObject = this.object._compile(math, argNames);
      var evalIndex = this.index ? this.index._compile(math, argNames) : null;
      var evalValue = this.value._compile(math, argNames);
      var name310 = this.object.name;
      if (!this.index) {
        if (!isSymbolNode(this.object)) {
          throw new TypeError("SymbolNode expected as object");
        }
        return function evalAssignmentNode(scope, args, context) {
          var value = evalValue(scope, args, context);
          scope.set(name310, value);
          return value;
        };
      } else if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAssignmentNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          setSafeProperty(object, prop, value);
          return value;
        };
      } else if (isSymbolNode(this.object)) {
        return function evalAssignmentNode(scope, args, context) {
          var childObject = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          var index = evalIndex(scope, args, childObject);
          scope.set(name310, assign2(childObject, index, value));
          return value;
        };
      } else {
        var evalParentObject = this.object.object._compile(math, argNames);
        if (this.object.index.isObjectProperty()) {
          var parentProp = this.object.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var childObject = getSafeProperty(parent, parentProp);
            var index = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            setSafeProperty(parent, parentProp, assign2(childObject, index, value));
            return value;
          };
        } else {
          var evalParentIndex = this.object.index._compile(math, argNames);
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var parentIndex = evalParentIndex(scope, args, parent);
            var childObject = access(parent, parentIndex);
            var index = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            assign2(parent, parentIndex, assign2(childObject, index, value));
            return value;
          };
        }
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.object, "object", this);
      if (this.index) {
        callback(this.index, "index", this);
      }
      callback(this.value, "value", this);
    }
    /**
     * Create a new AssignmentNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AssignmentNode} Returns a transformed copy of the node
     */
    map(callback) {
      var object = this._ifNode(callback(this.object, "object", this));
      var index = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
      var value = this._ifNode(callback(this.value, "value", this));
      return new AssignmentNode(object, index, value);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AssignmentNode}
     */
    clone() {
      return new AssignmentNode(this.object, this.index, this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(options) {
      var object = this.object.toString(options);
      var index = this.index ? this.index.toString(options) : "";
      var value = this.value.toString(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "(" + value + ")";
      }
      return object + index + " = " + value;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name209,
        object: this.object,
        index: this.index,
        value: this.value
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
     *     where mathjs is optional
     * @returns {AssignmentNode}
     */
    static fromJSON(json) {
      return new AssignmentNode(json.object, json.index, json.value);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    toHTML(options) {
      var object = this.object.toHTML(options);
      var index = this.index ? this.index.toHTML(options) : "";
      var value = this.value.toHTML(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      return object + index + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(options) {
      var object = this.object.toTex(options);
      var index = this.index ? this.index.toTex(options) : "";
      var value = this.value.toTex(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "\\left(".concat(value, "\\right)");
      }
      return object + index + ":=" + value;
    }
  }
  _defineProperty(AssignmentNode, "name", name209);
  return AssignmentNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/BlockNode.js
var name210 = "BlockNode";
var dependencies210 = ["ResultSet", "Node"];
var createBlockNode = /* @__PURE__ */ factory(name210, dependencies210, (_ref) => {
  var {
    ResultSet,
    Node
  } = _ref;
  class BlockNode extends Node {
    /**
     * @constructor BlockNode
     * @extends {Node}
     * Holds a set with blocks
     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
     *            An array with blocks, where a block is constructed as an
     *            Object with properties block, which is a Node, and visible,
     *            which is a boolean. The property visible is optional and
     *            is true by default
     */
    constructor(blocks) {
      super();
      if (!Array.isArray(blocks))
        throw new Error("Array expected");
      this.blocks = blocks.map(function(block) {
        var node = block && block.node;
        var visible = block && block.visible !== void 0 ? block.visible : true;
        if (!isNode(node))
          throw new TypeError('Property "node" must be a Node');
        if (typeof visible !== "boolean") {
          throw new TypeError('Property "visible" must be a boolean');
        }
        return {
          node,
          visible
        };
      });
    }
    get type() {
      return name210;
    }
    get isBlockNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var evalBlocks = map(this.blocks, function(block) {
        return {
          evaluate: block.node._compile(math, argNames),
          visible: block.visible
        };
      });
      return function evalBlockNodes(scope, args, context) {
        var results = [];
        forEach(evalBlocks, function evalBlockNode(block) {
          var result = block.evaluate(scope, args, context);
          if (block.visible) {
            results.push(result);
          }
        });
        return new ResultSet(results);
      };
    }
    /**
     * Execute a callback for each of the child blocks of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i = 0; i < this.blocks.length; i++) {
        callback(this.blocks[i].node, "blocks[" + i + "].node", this);
      }
    }
    /**
     * Create a new BlockNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {BlockNode} Returns a transformed copy of the node
     */
    map(callback) {
      var blocks = [];
      for (var i = 0; i < this.blocks.length; i++) {
        var block = this.blocks[i];
        var node = this._ifNode(callback(block.node, "blocks[" + i + "].node", this));
        blocks[i] = {
          node,
          visible: block.visible
        };
      }
      return new BlockNode(blocks);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {BlockNode}
     */
    clone() {
      var blocks = this.blocks.map(function(block) {
        return {
          node: block.node,
          visible: block.visible
        };
      });
      return new BlockNode(blocks);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      return this.blocks.map(function(param) {
        return param.node.toString(options) + (param.visible ? "" : ";");
      }).join("\n");
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name210,
        blocks: this.blocks
      };
    }
    /**
     * Instantiate an BlockNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
     *     where mathjs is optional
     * @returns {BlockNode}
     */
    static fromJSON(json) {
      return new BlockNode(json.blocks);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toHTML(options) {
      return this.blocks.map(function(param) {
        return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      return this.blocks.map(function(param) {
        return param.node.toTex(options) + (param.visible ? "" : ";");
      }).join("\\;\\;\n");
    }
  }
  _defineProperty(BlockNode, "name", name210);
  return BlockNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
var name211 = "ConditionalNode";
var dependencies211 = ["Node"];
var createConditionalNode = /* @__PURE__ */ factory(name211, dependencies211, (_ref) => {
  var {
    Node
  } = _ref;
  function testCondition(condition) {
    if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
      return !!condition;
    }
    if (condition) {
      if (isBigNumber(condition)) {
        return !condition.isZero();
      }
      if (isComplex(condition)) {
        return !!(condition.re || condition.im);
      }
      if (isUnit(condition)) {
        return !!condition.value;
      }
    }
    if (condition === null || condition === void 0) {
      return false;
    }
    throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
  }
  class ConditionalNode extends Node {
    /**
     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
     *
     * @param {Node} condition   Condition, must result in a boolean
     * @param {Node} trueExpr    Expression evaluated when condition is true
     * @param {Node} falseExpr   Expression evaluated when condition is true
     *
     * @constructor ConditionalNode
     * @extends {Node}
     */
    constructor(condition, trueExpr, falseExpr) {
      super();
      if (!isNode(condition)) {
        throw new TypeError("Parameter condition must be a Node");
      }
      if (!isNode(trueExpr)) {
        throw new TypeError("Parameter trueExpr must be a Node");
      }
      if (!isNode(falseExpr)) {
        throw new TypeError("Parameter falseExpr must be a Node");
      }
      this.condition = condition;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    }
    get type() {
      return name211;
    }
    get isConditionalNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var evalCondition = this.condition._compile(math, argNames);
      var evalTrueExpr = this.trueExpr._compile(math, argNames);
      var evalFalseExpr = this.falseExpr._compile(math, argNames);
      return function evalConditionalNode(scope, args, context) {
        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.condition, "condition", this);
      callback(this.trueExpr, "trueExpr", this);
      callback(this.falseExpr, "falseExpr", this);
    }
    /**
     * Create a new ConditionalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ConditionalNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new ConditionalNode(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConditionalNode}
     */
    clone() {
      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toString(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = "(" + condition + ")";
      }
      var trueExpr = this.trueExpr.toString(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = "(" + trueExpr + ")";
      }
      var falseExpr = this.falseExpr.toString(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = "(" + falseExpr + ")";
      }
      return condition + " ? " + trueExpr + " : " + falseExpr;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name211,
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    }
    /**
     * Instantiate an ConditionalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "ConditionalNode",
     *      "condition": ...,
     *      "trueExpr": ...,
     *      "falseExpr": ...}
     *     ```
     *     where mathjs is optional
     * @returns {ConditionalNode}
     */
    static fromJSON(json) {
      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toHTML(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var trueExpr = this.trueExpr.toHTML(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var falseExpr = this.falseExpr.toHTML(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    }
  }
  _defineProperty(ConditionalNode, "name", name211);
  return ConditionalNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/utils/latex.js
var import_escape_latex = __toESM(require_dist(), 1);
var latexSymbols = {
  // GREEK LETTERS
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  // logic
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  // other
  i: "i",
  // TODO use \i ??
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
};
var latexOperators = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  // TODO find ideal solution
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  // TODO find ideal solution
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  // TODO how to handle that properly?
  dotMultiply: ".\\cdot",
  // TODO find ideal solution
  dotDivide: ".:",
  // TODO find ideal solution
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
};
var latexFunctions = {
  // arithmetic
  abs: {
    1: "\\left|${args[0]}\\right|"
  },
  add: {
    2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
  },
  cbrt: {
    1: "\\sqrt[3]{${args[0]}}"
  },
  ceil: {
    1: "\\left\\lceil${args[0]}\\right\\rceil"
  },
  cube: {
    1: "\\left(${args[0]}\\right)^3"
  },
  divide: {
    2: "\\frac{${args[0]}}{${args[1]}}"
  },
  dotDivide: {
    2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
  },
  dotMultiply: {
    2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
  },
  dotPow: {
    2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
  },
  exp: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
  fix: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  floor: {
    1: "\\left\\lfloor${args[0]}\\right\\rfloor"
  },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: {
    1: "\\log_{10}\\left(${args[0]}\\right)"
  },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: {
    2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
  },
  multiply: {
    2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: void 0
    // use default template
  },
  nthRoot: {
    2: "\\sqrt[${args[1]}]{${args[0]}}"
  },
  nthRoots: {
    2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
  },
  pow: {
    2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
  },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: void 0
    // use default template
  },
  sign: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  sqrt: {
    1: "\\sqrt{${args[0]}}"
  },
  square: {
    1: "\\left(${args[0]}\\right)^2"
  },
  subtract: {
    2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
  },
  unaryMinus: {
    1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
  },
  unaryPlus: {
    1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
  },
  // bitwise
  bitAnd: {
    2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
  },
  bitNot: {
    1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
  },
  bitOr: {
    2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
  },
  bitXor: {
    2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
  },
  leftShift: {
    2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
  },
  rightArithShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
  },
  rightLogShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
  },
  // combinatorics
  bellNumbers: {
    1: "\\mathrm{B}_{${args[0]}}"
  },
  catalan: {
    1: "\\mathrm{C}_{${args[0]}}"
  },
  stirlingS2: {
    2: "\\mathrm{S}\\left(${args}\\right)"
  },
  // complex
  arg: {
    1: "\\arg\\left(${args[0]}\\right)"
  },
  conj: {
    1: "\\left(${args[0]}\\right)^*"
  },
  im: {
    1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  re: {
    1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  // logical
  and: {
    2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
  },
  not: {
    1: latexOperators.not + "\\left(${args[0]}\\right)"
  },
  or: {
    2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
  },
  xor: {
    2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
  },
  // matrix
  cross: {
    2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
  },
  ctranspose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
  },
  det: {
    1: "\\det\\left(${args[0]}\\right)"
  },
  dot: {
    2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
  },
  expm: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  inv: {
    1: "\\left(${args[0]}\\right)^{-1}"
  },
  pinv: {
    1: "\\left(${args[0]}\\right)^{+}"
  },
  sqrtm: {
    1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
  },
  trace: {
    1: "\\mathrm{tr}\\left(${args[0]}\\right)"
  },
  transpose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
  },
  // probability
  combinations: {
    2: "\\binom{${args[0]}}{${args[1]}}"
  },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
  },
  gamma: {
    1: "\\Gamma\\left(${args[0]}\\right)"
  },
  lgamma: {
    1: "\\ln\\Gamma\\left(${args[0]}\\right)"
  },
  // relational
  equal: {
    2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
  },
  larger: {
    2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
  },
  largerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
  },
  smaller: {
    2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
  },
  smallerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
  },
  unequal: {
    2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
  },
  // special
  erf: {
    1: "erf\\left(${args[0]}\\right)"
  },
  // statistics
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  // trigonometry
  acos: {
    1: "\\cos^{-1}\\left(${args[0]}\\right)"
  },
  acosh: {
    1: "\\cosh^{-1}\\left(${args[0]}\\right)"
  },
  acot: {
    1: "\\cot^{-1}\\left(${args[0]}\\right)"
  },
  acoth: {
    1: "\\coth^{-1}\\left(${args[0]}\\right)"
  },
  acsc: {
    1: "\\csc^{-1}\\left(${args[0]}\\right)"
  },
  acsch: {
    1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
  },
  asec: {
    1: "\\sec^{-1}\\left(${args[0]}\\right)"
  },
  asech: {
    1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
  },
  asin: {
    1: "\\sin^{-1}\\left(${args[0]}\\right)"
  },
  asinh: {
    1: "\\sinh^{-1}\\left(${args[0]}\\right)"
  },
  atan: {
    1: "\\tan^{-1}\\left(${args[0]}\\right)"
  },
  atan2: {
    2: "\\mathrm{atan2}\\left(${args}\\right)"
  },
  atanh: {
    1: "\\tanh^{-1}\\left(${args[0]}\\right)"
  },
  cos: {
    1: "\\cos\\left(${args[0]}\\right)"
  },
  cosh: {
    1: "\\cosh\\left(${args[0]}\\right)"
  },
  cot: {
    1: "\\cot\\left(${args[0]}\\right)"
  },
  coth: {
    1: "\\coth\\left(${args[0]}\\right)"
  },
  csc: {
    1: "\\csc\\left(${args[0]}\\right)"
  },
  csch: {
    1: "\\mathrm{csch}\\left(${args[0]}\\right)"
  },
  sec: {
    1: "\\sec\\left(${args[0]}\\right)"
  },
  sech: {
    1: "\\mathrm{sech}\\left(${args[0]}\\right)"
  },
  sin: {
    1: "\\sin\\left(${args[0]}\\right)"
  },
  sinh: {
    1: "\\sinh\\left(${args[0]}\\right)"
  },
  tan: {
    1: "\\tan\\left(${args[0]}\\right)"
  },
  tanh: {
    1: "\\tanh\\left(${args[0]}\\right)"
  },
  // unit
  to: {
    2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
  },
  // utils
  numeric: function numeric(node, options) {
    return node.args[0].toTex();
  },
  // type
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
};
var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
var latexUnits = {
  deg: "^\\circ"
};
function escapeLatex(string) {
  return (0, import_escape_latex.default)(string, {
    preserveFormatting: true
  });
}
function toSymbol(name310, isUnit2) {
  isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
  if (isUnit2) {
    if (hasOwnProperty(latexUnits, name310)) {
      return latexUnits[name310];
    }
    return "\\mathrm{" + escapeLatex(name310) + "}";
  }
  if (hasOwnProperty(latexSymbols, name310)) {
    return latexSymbols[name310];
  }
  return escapeLatex(name310);
}

// node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
var name212 = "ConstantNode";
var dependencies212 = ["Node"];
var createConstantNode = /* @__PURE__ */ factory(name212, dependencies212, (_ref) => {
  var {
    Node
  } = _ref;
  class ConstantNode extends Node {
    /**
     * A ConstantNode holds a constant value like a number or string.
     *
     * Usage:
     *
     *     new ConstantNode(2.3)
     *     new ConstantNode('hello')
     *
     * @param {*} value    Value can be any type (number, BigNumber, string, ...)
     * @constructor ConstantNode
     * @extends {Node}
     */
    constructor(value) {
      super();
      this.value = value;
    }
    get type() {
      return name212;
    }
    get isConstantNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var value = this.value;
      return function evalConstantNode() {
        return value;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
    }
    /**
     * Create a new ConstantNode with children produced by the given callback.
     * Trivial because there are no children.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ConstantNode} Returns a clone of the node
     */
    map(callback) {
      return this.clone();
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConstantNode}
     */
    clone() {
      return new ConstantNode(this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      return format3(this.value, options);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    toHTML(options) {
      var value = this._toString(options);
      switch (typeOf(this.value)) {
        case "number":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + value + "</span>";
        case "string":
          return '<span class="math-string">' + value + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + value + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + value + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + value + "</span>";
        default:
          return '<span class="math-symbol">' + value + "</span>";
      }
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name212,
        value: this.value
      };
    }
    /**
     * Instantiate a ConstantNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", value: 2.3}`,
     *                       where mathjs is optional
     * @returns {ConstantNode}
     */
    static fromJSON(json) {
      return new ConstantNode(json.value);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var value = this._toString(options);
      switch (typeOf(this.value)) {
        case "string":
          return "\\mathtt{" + escapeLatex(value) + "}";
        case "number":
        case "BigNumber":
          {
            if (!isFinite(this.value)) {
              return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
            }
            var index = value.toLowerCase().indexOf("e");
            if (index !== -1) {
              return value.substring(0, index) + "\\cdot10^{" + value.substring(index + 1) + "}";
            }
          }
          return value;
        case "Fraction":
          return this.value.toLatex();
        default:
          return value;
      }
    }
  }
  _defineProperty(ConstantNode, "name", name212);
  return ConstantNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
var name213 = "FunctionAssignmentNode";
var dependencies213 = ["typed", "Node"];
var createFunctionAssignmentNode = /* @__PURE__ */ factory(name213, dependencies213, (_ref) => {
  var {
    typed: typed3,
    Node
  } = _ref;
  function needParenthesis(node, parenthesis, implicit2) {
    var precedence = getPrecedence(node, parenthesis, implicit2);
    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit2);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }
  class FunctionAssignmentNode extends Node {
    /**
     * @constructor FunctionAssignmentNode
     * @extends {Node}
     * Function assignment
     *
     * @param {string} name           Function name
     * @param {string[] | Array.<{name: string, type: string}>} params
     *                                Array with function parameter names, or an
     *                                array with objects containing the name
     *                                and type of the parameter
     * @param {Node} expr             The function expression
     */
    constructor(name310, params, expr) {
      super();
      if (typeof name310 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      if (!Array.isArray(params)) {
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      }
      if (!isNode(expr)) {
        throw new TypeError('Node expected for parameter "expr"');
      }
      if (keywords.has(name310)) {
        throw new Error('Illegal function name, "' + name310 + '" is a reserved keyword');
      }
      var paramNames = /* @__PURE__ */ new Set();
      for (var param of params) {
        var _name = typeof param === "string" ? param : param.name;
        if (paramNames.has(_name)) {
          throw new Error('Duplicate parameter name "'.concat(_name, '"'));
        } else {
          paramNames.add(_name);
        }
      }
      this.name = name310;
      this.params = params.map(function(param2) {
        return param2 && param2.name || param2;
      });
      this.types = params.map(function(param2) {
        return param2 && param2.type || "any";
      });
      this.expr = expr;
    }
    get type() {
      return name213;
    }
    get isFunctionAssignmentNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var childArgNames = Object.create(argNames);
      forEach(this.params, function(param) {
        childArgNames[param] = true;
      });
      var evalExpr = this.expr._compile(math, childArgNames);
      var name310 = this.name;
      var params = this.params;
      var signature = join(this.types, ",");
      var syntax = name310 + "(" + join(this.params, ", ") + ")";
      return function evalFunctionAssignmentNode(scope, args, context) {
        var signatures = {};
        signatures[signature] = function() {
          var childArgs = Object.create(args);
          for (var i = 0; i < params.length; i++) {
            childArgs[params[i]] = arguments[i];
          }
          return evalExpr(scope, childArgs, context);
        };
        var fn = typed3(name310, signatures);
        fn.syntax = syntax;
        scope.set(name310, fn);
        return fn;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.expr, "expr", this);
    }
    /**
     * Create a new FunctionAssignmentNode whose children are the results of
     * calling the provided callback function for each child of the original
     * node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
     */
    map(callback) {
      var expr = this._ifNode(callback(this.expr, "expr", this));
      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionAssignmentNode}
     */
    clone() {
      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
    }
    /**
     * get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toString(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "(" + expr + ")";
      }
      return this.name + "(" + this.params.join(", ") + ") = " + expr;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      var types = this.types;
      return {
        mathjs: name213,
        name: this.name,
        params: this.params.map(function(param, index) {
          return {
            name: param,
            type: types[index]
          };
        }),
        expr: this.expr
      };
    }
    /**
     * Instantiate an FunctionAssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "FunctionAssignmentNode",
     *      name: ..., params: ..., expr: ...}
     *     ```
     *     where mathjs is optional
     * @returns {FunctionAssignmentNode}
     */
    static fromJSON(json) {
      return new FunctionAssignmentNode(json.name, json.params, json.expr);
    }
    /**
     * get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var params = [];
      for (var i = 0; i < this.params.length; i++) {
        params.push('<span class="math-symbol math-parameter">' + escape(this.params[i]) + "</span>");
      }
      var expr = this.expr.toHTML(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
    }
    /**
     * get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toTex(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "\\left(".concat(expr, "\\right)");
      }
      return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right):=" + expr;
    }
  }
  _defineProperty(FunctionAssignmentNode, "name", name213);
  return FunctionAssignmentNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/IndexNode.js
var name214 = "IndexNode";
var dependencies214 = ["Node", "size"];
var createIndexNode = /* @__PURE__ */ factory(name214, dependencies214, (_ref) => {
  var {
    Node,
    size
  } = _ref;
  class IndexNode extends Node {
    /**
     * @constructor IndexNode
     * @extends Node
     *
     * Describes a subset of a matrix or an object property.
     * Cannot be used on its own, needs to be used within an AccessorNode or
     * AssignmentNode.
     *
     * @param {Node[]} dimensions
     * @param {boolean} [dotNotation=false]
     *     Optional property describing whether this index was written using dot
     *     notation like `a.b`, or using bracket notation like `a["b"]`
     *     (which is the default). This property is used for string conversion.
     */
    constructor(dimensions, dotNotation) {
      super();
      this.dimensions = dimensions;
      this.dotNotation = dotNotation || false;
      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      }
      if (this.dotNotation && !this.isObjectProperty()) {
        throw new Error("dotNotation only applicable for object properties");
      }
    }
    get type() {
      return name214;
    }
    get isIndexNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var evalDimensions = map(this.dimensions, function(dimension, i) {
        var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
        if (needsEnd) {
          var childArgNames = Object.create(argNames);
          childArgNames.end = true;
          var _evalDimension = dimension._compile(math, childArgNames);
          return function evalDimension(scope, args, context) {
            if (!isMatrix(context) && !isArray(context) && !isString(context)) {
              throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf(context));
            }
            var s2 = size(context).valueOf();
            var childArgs = Object.create(args);
            childArgs.end = s2[i];
            return _evalDimension(scope, childArgs, context);
          };
        } else {
          return dimension._compile(math, argNames);
        }
      });
      var index = getSafeProperty(math, "index");
      return function evalIndexNode(scope, args, context) {
        var dimensions = map(evalDimensions, function(evalDimension) {
          return evalDimension(scope, args, context);
        });
        return index(...dimensions);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i = 0; i < this.dimensions.length; i++) {
        callback(this.dimensions[i], "dimensions[" + i + "]", this);
      }
    }
    /**
     * Create a new IndexNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {IndexNode} Returns a transformed copy of the node
     */
    map(callback) {
      var dimensions = [];
      for (var i = 0; i < this.dimensions.length; i++) {
        dimensions[i] = this._ifNode(callback(this.dimensions[i], "dimensions[" + i + "]", this));
      }
      return new IndexNode(dimensions, this.dotNotation);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {IndexNode}
     */
    clone() {
      return new IndexNode(this.dimensions.slice(0), this.dotNotation);
    }
    /**
     * Test whether this IndexNode contains a single property name
     * @return {boolean}
     */
    isObjectProperty() {
      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
    }
    /**
     * Returns the property name if IndexNode contains a property.
     * If not, returns null.
     * @return {string | null}
     */
    getObjectProperty() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name214,
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    }
    /**
     * Instantiate an IndexNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
     *     where mathjs is optional
     * @returns {IndexNode}
     */
    static fromJSON(json) {
      return new IndexNode(json.dimensions, json.dotNotation);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    toHTML(options) {
      var dimensions = [];
      for (var i = 0; i < this.dimensions.length; i++) {
        dimensions[i] = this.dimensions[i].toHTML();
      }
      if (this.dotNotation) {
        return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
      } else {
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var dimensions = this.dimensions.map(function(range2) {
        return range2.toTex(options);
      });
      return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
    }
  }
  _defineProperty(IndexNode, "name", name214);
  return IndexNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
var name215 = "ObjectNode";
var dependencies215 = ["Node"];
var createObjectNode = /* @__PURE__ */ factory(name215, dependencies215, (_ref) => {
  var {
    Node
  } = _ref;
  class ObjectNode extends Node {
    /**
     * @constructor ObjectNode
     * @extends {Node}
     * Holds an object with keys/values
     * @param {Object.<string, Node>} [properties]   object with key/value pairs
     */
    constructor(properties2) {
      super();
      this.properties = properties2 || {};
      if (properties2) {
        if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
          return isNode(properties2[key]);
        })) {
          throw new TypeError("Object containing Nodes expected");
        }
      }
    }
    get type() {
      return name215;
    }
    get isObjectNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var evalEntries = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          var stringifiedKey = stringify(key);
          var parsedKey = JSON.parse(stringifiedKey);
          var prop = getSafeProperty(this.properties, key);
          evalEntries[parsedKey] = prop._compile(math, argNames);
        }
      }
      return function evalObjectNode(scope, args, context) {
        var obj = {};
        for (var _key in evalEntries) {
          if (hasOwnProperty(evalEntries, _key)) {
            obj[_key] = evalEntries[_key](scope, args, context);
          }
        }
        return obj;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          callback(this.properties[key], "properties[" + stringify(key) + "]", this);
        }
      }
    }
    /**
     * Create a new ObjectNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ObjectNode} Returns a transformed copy of the node
     */
    map(callback) {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
        }
      }
      return new ObjectNode(properties2);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ObjectNode}
     */
    clone() {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties2[key] = this.properties[key];
        }
      }
      return new ObjectNode(properties2);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push(stringify(key) + ": " + this.properties[key].toString(options));
        }
      }
      return "{" + entries.join(", ") + "}";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name215,
        properties: this.properties
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
     *                       where mathjs is optional
     * @returns {ObjectNode}
     */
    static fromJSON(json) {
      return new ObjectNode(json.properties);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toHTML(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push('<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
        }
      }
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
        }
      }
      var tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
      return tex;
    }
  }
  _defineProperty(ObjectNode, "name", name215);
  return ObjectNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
var name216 = "OperatorNode";
var dependencies216 = ["Node"];
var createOperatorNode = /* @__PURE__ */ factory(name216, dependencies216, (_ref) => {
  var {
    Node
  } = _ref;
  function startsWithConstant(expr, parenthesis) {
    var curNode = expr;
    if (parenthesis === "auto") {
      while (isParenthesisNode(curNode))
        curNode = curNode.content;
    }
    if (isConstantNode(curNode))
      return true;
    if (isOperatorNode(curNode)) {
      return startsWithConstant(curNode.args[0], parenthesis);
    }
    return false;
  }
  function calculateNecessaryParentheses(root2, parenthesis, implicit2, args, latex) {
    var precedence = getPrecedence(root2, parenthesis, implicit2);
    var associativity = getAssociativity(root2, parenthesis);
    if (parenthesis === "all" || args.length > 2 && root2.getIdentifier() !== "OperatorNode:add" && root2.getIdentifier() !== "OperatorNode:multiply") {
      return args.map(function(arg) {
        switch (arg.getContent().type) {
          case "ArrayNode":
          case "ConstantNode":
          case "SymbolNode":
          case "ParenthesisNode":
            return false;
          default:
            return true;
        }
      });
    }
    var result;
    switch (args.length) {
      case 0:
        result = [];
        break;
      case 1:
        {
          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit2, root2);
          if (latex && operandPrecedence !== null) {
            var operandIdentifier;
            var rootIdentifier;
            if (parenthesis === "keep") {
              operandIdentifier = args[0].getIdentifier();
              rootIdentifier = root2.getIdentifier();
            } else {
              operandIdentifier = args[0].getContent().getIdentifier();
              rootIdentifier = root2.getContent().getIdentifier();
            }
            if (properties[precedence][rootIdentifier].latexLeftParens === false) {
              result = [false];
              break;
            }
            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
              result = [false];
              break;
            }
          }
          if (operandPrecedence === null) {
            result = [false];
            break;
          }
          if (operandPrecedence <= precedence) {
            result = [true];
            break;
          }
          result = [false];
        }
        break;
      case 2:
        {
          var lhsParens;
          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit2, root2);
          var assocWithLhs = isAssociativeWith(root2, args[0], parenthesis);
          if (lhsPrecedence === null) {
            lhsParens = false;
          } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
            lhsParens = true;
          } else if (lhsPrecedence < precedence) {
            lhsParens = true;
          } else {
            lhsParens = false;
          }
          var rhsParens;
          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit2, root2);
          var assocWithRhs = isAssociativeWith(root2, args[1], parenthesis);
          if (rhsPrecedence === null) {
            rhsParens = false;
          } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
            rhsParens = true;
          } else if (rhsPrecedence < precedence) {
            rhsParens = true;
          } else {
            rhsParens = false;
          }
          if (latex) {
            var _rootIdentifier;
            var lhsIdentifier;
            var rhsIdentifier;
            if (parenthesis === "keep") {
              _rootIdentifier = root2.getIdentifier();
              lhsIdentifier = root2.args[0].getIdentifier();
              rhsIdentifier = root2.args[1].getIdentifier();
            } else {
              _rootIdentifier = root2.getContent().getIdentifier();
              lhsIdentifier = root2.args[0].getContent().getIdentifier();
              rhsIdentifier = root2.args[1].getContent().getIdentifier();
            }
            if (lhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                lhsParens = false;
              }
              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                lhsParens = false;
              }
            }
            if (rhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                rhsParens = false;
              }
              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                rhsParens = false;
              }
            }
          }
          result = [lhsParens, rhsParens];
        }
        break;
      default:
        if (root2.getIdentifier() === "OperatorNode:add" || root2.getIdentifier() === "OperatorNode:multiply") {
          result = args.map(function(arg) {
            var argPrecedence = getPrecedence(arg, parenthesis, implicit2, root2);
            var assocWithArg = isAssociativeWith(root2, arg, parenthesis);
            var argAssociativity = getAssociativity(arg, parenthesis);
            if (argPrecedence === null) {
              return false;
            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
              return true;
            } else if (argPrecedence < precedence) {
              return true;
            }
            return false;
          });
        }
        break;
    }
    if (args.length >= 2 && root2.getIdentifier() === "OperatorNode:multiply" && root2.implicit && parenthesis !== "all" && implicit2 === "hide") {
      for (var i = 1; i < result.length; ++i) {
        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i - 1]))) {
          result[i] = true;
        }
      }
    }
    return result;
  }
  class OperatorNode extends Node {
    /**
     * @constructor OperatorNode
     * @extends {Node}
     * An operator with two arguments, like 2+3
     *
     * @param {string} op           Operator name, for example '+'
     * @param {string} fn           Function name, for example 'add'
     * @param {Node[]} args         Operator arguments
     * @param {boolean} [implicit]  Is this an implicit multiplication?
     * @param {boolean} [isPercentage] Is this an percentage Operation?
     */
    constructor(op, fn, args, implicit2, isPercentage) {
      super();
      if (typeof op !== "string") {
        throw new TypeError('string expected for parameter "op"');
      }
      if (typeof fn !== "string") {
        throw new TypeError('string expected for parameter "fn"');
      }
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.implicit = implicit2 === true;
      this.isPercentage = isPercentage === true;
      this.op = op;
      this.fn = fn;
      this.args = args || [];
    }
    get type() {
      return name216;
    }
    get isOperatorNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      if (typeof this.fn !== "string" || !isSafeMethod(math, this.fn)) {
        if (!math[this.fn]) {
          throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
        } else {
          throw new Error('No access to function "' + this.fn + '"');
        }
      }
      var fn = getSafeProperty(math, this.fn);
      var evalArgs = map(this.args, function(arg) {
        return arg._compile(math, argNames);
      });
      if (evalArgs.length === 1) {
        var evalArg0 = evalArgs[0];
        return function evalOperatorNode(scope, args, context) {
          return fn(evalArg0(scope, args, context));
        };
      } else if (evalArgs.length === 2) {
        var _evalArg = evalArgs[0];
        var evalArg1 = evalArgs[1];
        return function evalOperatorNode(scope, args, context) {
          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
        };
      } else {
        return function evalOperatorNode(scope, args, context) {
          return fn.apply(null, map(evalArgs, function(evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i = 0; i < this.args.length; i++) {
        callback(this.args[i], "args[" + i + "]", this);
      }
    }
    /**
     * Create a new OperatorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(callback) {
      var args = [];
      for (var i = 0; i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
      }
      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {OperatorNode}
     */
    clone() {
      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
    }
    /**
     * Check whether this is an unary OperatorNode:
     * has exactly one argument, like `-a`.
     * @return {boolean}
     *     Returns true when an unary operator node, false otherwise.
     */
    isUnary() {
      return this.args.length === 1;
    }
    /**
     * Check whether this is a binary OperatorNode:
     * has exactly two arguments, like `a + b`.
     * @return {boolean}
     *     Returns true when a binary operator node, false otherwise.
     */
    isBinary() {
      return this.args.length === 2;
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit2 = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit2, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toString(options);
        if (parens[0]) {
          operand = "(" + operand + ")";
        }
        var opIsNamed = /[a-zA-Z]+/.test(this.op);
        if (assoc === "right") {
          return this.op + (opIsNamed ? " " : "") + operand;
        } else if (assoc === "left") {
          return operand + (opIsNamed ? " " : "") + this.op;
        }
        return operand + this.op;
      } else if (args.length === 2) {
        var lhs = args[0].toString(options);
        var rhs = args[1].toString(options);
        if (parens[0]) {
          lhs = "(" + lhs + ")";
        }
        if (parens[1]) {
          rhs = "(" + rhs + ")";
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit2 === "hide") {
          return lhs + " " + rhs;
        }
        return lhs + " " + this.op + " " + rhs;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var stringifiedArgs = args.map(function(arg, index) {
          arg = arg.toString(options);
          if (parens[index]) {
            arg = "(" + arg + ")";
          }
          return arg;
        });
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit2 === "hide") {
          return stringifiedArgs.join(" ");
        }
        return stringifiedArgs.join(" " + this.op + " ");
      } else {
        return this.fn + "(" + this.args.join(", ") + ")";
      }
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name216,
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit,
        isPercentage: this.isPercentage
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "OperatorNode",
     *      "op": "+", "fn": "add", "args": [...],
     *      "implicit": false,
     *      "isPercentage":false}
     *     ```
     *     where mathjs is optional
     * @returns {OperatorNode}
     */
    static fromJSON(json) {
      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);
    }
    /**
     * Get HTML representation.
     * @param {Object} options
     * @return {string} str
     */
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit2 = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit2, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toHTML(options);
        if (parens[0]) {
          operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (assoc === "right") {
          return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
        } else {
          return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
        }
      } else if (args.length === 2) {
        var lhs = args[0].toHTML(options);
        var rhs = args[1].toHTML(options);
        if (parens[0]) {
          lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (parens[1]) {
          rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit2 === "hide") {
          return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
        }
        return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
      } else {
        var stringifiedArgs = args.map(function(arg, index) {
          arg = arg.toHTML(options);
          if (parens[index]) {
            arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          return arg;
        });
        if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit2 === "hide") {
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
          }
          return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
        } else {
          return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
      }
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit2 = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit2, args, true);
      var op = latexOperators[this.fn];
      op = typeof op === "undefined" ? this.op : op;
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toTex(options);
        if (parens[0]) {
          operand = "\\left(".concat(operand, "\\right)");
        }
        if (assoc === "right") {
          return op + operand;
        } else if (assoc === "left") {
          return operand + op;
        }
        return operand + op;
      } else if (args.length === 2) {
        var lhs = args[0];
        var lhsTex = lhs.toTex(options);
        if (parens[0]) {
          lhsTex = "\\left(".concat(lhsTex, "\\right)");
        }
        var rhs = args[1];
        var rhsTex = rhs.toTex(options);
        if (parens[1]) {
          rhsTex = "\\left(".concat(rhsTex, "\\right)");
        }
        var lhsIdentifier;
        if (parenthesis === "keep") {
          lhsIdentifier = lhs.getIdentifier();
        } else {
          lhsIdentifier = lhs.getContent().getIdentifier();
        }
        switch (this.getIdentifier()) {
          case "OperatorNode:divide":
            return op + "{" + lhsTex + "}{" + rhsTex + "}";
          case "OperatorNode:pow":
            lhsTex = "{" + lhsTex + "}";
            rhsTex = "{" + rhsTex + "}";
            switch (lhsIdentifier) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && implicit2 === "hide") {
              return lhsTex + "~" + rhsTex;
            }
        }
        return lhsTex + op + rhsTex;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var texifiedArgs = args.map(function(arg, index) {
          arg = arg.toTex(options);
          if (parens[index]) {
            arg = "\\left(".concat(arg, "\\right)");
          }
          return arg;
        });
        if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit2 === "hide") {
          return texifiedArgs.join("~");
        }
        return texifiedArgs.join(op);
      } else {
        return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg) {
          return arg.toTex(options);
        }).join(",") + "\\right)";
      }
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.fn;
    }
  }
  _defineProperty(OperatorNode, "name", name216);
  return OperatorNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
var name217 = "ParenthesisNode";
var dependencies217 = ["Node"];
var createParenthesisNode = /* @__PURE__ */ factory(name217, dependencies217, (_ref) => {
  var {
    Node
  } = _ref;
  class ParenthesisNode extends Node {
    /**
     * @constructor ParenthesisNode
     * @extends {Node}
     * A parenthesis node describes manual parenthesis from the user input
     * @param {Node} content
     * @extends {Node}
     */
    constructor(content) {
      super();
      if (!isNode(content)) {
        throw new TypeError('Node expected for parameter "content"');
      }
      this.content = content;
    }
    get type() {
      return name217;
    }
    get isParenthesisNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      return this.content._compile(math, argNames);
    }
    /**
     * Get the content of the current Node.
     * @return {Node} content
     * @override
     **/
    getContent() {
      return this.content.getContent();
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.content, "content", this);
    }
    /**
     * Create a new ParenthesisNode whose child is the result of calling
     * the provided callback function on the child of this node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ParenthesisNode} Returns a clone of the node
     */
    map(callback) {
      var content = callback(this.content, "content", this);
      return new ParenthesisNode(content);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ParenthesisNode}
     */
    clone() {
      return new ParenthesisNode(this.content);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "(" + this.content.toString(options) + ")";
      }
      return this.content.toString(options);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name217,
        content: this.content
      };
    }
    /**
     * Instantiate an ParenthesisNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
     *                       where mathjs is optional
     * @returns {ParenthesisNode}
     */
    static fromJSON(json) {
      return new ParenthesisNode(json.content);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toHTML(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return this.content.toHTML(options);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "\\left(".concat(this.content.toTex(options), "\\right)");
      }
      return this.content.toTex(options);
    }
  }
  _defineProperty(ParenthesisNode, "name", name217);
  return ParenthesisNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/RangeNode.js
var name218 = "RangeNode";
var dependencies218 = ["Node"];
var createRangeNode = /* @__PURE__ */ factory(name218, dependencies218, (_ref) => {
  var {
    Node
  } = _ref;
  function calculateNecessaryParentheses(node, parenthesis, implicit2) {
    var precedence = getPrecedence(node, parenthesis, implicit2);
    var parens = {};
    var startPrecedence = getPrecedence(node.start, parenthesis, implicit2);
    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
    if (node.step) {
      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit2);
      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
    }
    var endPrecedence = getPrecedence(node.end, parenthesis, implicit2);
    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
    return parens;
  }
  class RangeNode extends Node {
    /**
     * @constructor RangeNode
     * @extends {Node}
     * create a range
     * @param {Node} start  included lower-bound
     * @param {Node} end    included upper-bound
     * @param {Node} [step] optional step
     */
    constructor(start2, end, step) {
      super();
      if (!isNode(start2))
        throw new TypeError("Node expected");
      if (!isNode(end))
        throw new TypeError("Node expected");
      if (step && !isNode(step))
        throw new TypeError("Node expected");
      if (arguments.length > 3)
        throw new Error("Too many arguments");
      this.start = start2;
      this.end = end;
      this.step = step || null;
    }
    get type() {
      return name218;
    }
    get isRangeNode() {
      return true;
    }
    /**
     * Check whether the RangeNode needs the `end` symbol to be defined.
     * This end is the size of the Matrix in current dimension.
     * @return {boolean}
     */
    needsEnd() {
      var endSymbols = this.filter(function(node) {
        return isSymbolNode(node) && node.name === "end";
      });
      return endSymbols.length > 0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var range2 = math.range;
      var evalStart = this.start._compile(math, argNames);
      var evalEnd = this.end._compile(math, argNames);
      if (this.step) {
        var evalStep = this.step._compile(math, argNames);
        return function evalRangeNode(scope, args, context) {
          return range2(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
        };
      } else {
        return function evalRangeNode(scope, args, context) {
          return range2(evalStart(scope, args, context), evalEnd(scope, args, context));
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.start, "start", this);
      callback(this.end, "end", this);
      if (this.step) {
        callback(this.step, "step", this);
      }
    }
    /**
     * Create a new RangeNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RangeNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new RangeNode(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RangeNode}
     */
    clone() {
      return new RangeNode(this.start, this.end, this.step && this.step);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start2 = this.start.toString(options);
      if (parens.start) {
        start2 = "(" + start2 + ")";
      }
      str = start2;
      if (this.step) {
        var step = this.step.toString(options);
        if (parens.step) {
          step = "(" + step + ")";
        }
        str += ":" + step;
      }
      var end = this.end.toString(options);
      if (parens.end) {
        end = "(" + end + ")";
      }
      str += ":" + end;
      return str;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name218,
        start: this.start,
        end: this.end,
        step: this.step
      };
    }
    /**
     * Instantiate an RangeNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
     *     where mathjs is optional
     * @returns {RangeNode}
     */
    static fromJSON(json) {
      return new RangeNode(json.start, json.end, json.step);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start2 = this.start.toHTML(options);
      if (parens.start) {
        start2 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start2 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str = start2;
      if (this.step) {
        var step = this.step.toHTML(options);
        if (parens.step) {
          step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + step;
      }
      var end = this.end.toHTML(options);
      if (parens.end) {
        end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str += '<span class="math-operator math-range-operator">:</span>' + end;
      return str;
    }
    /**
     * Get LaTeX representation
     * @params {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str = this.start.toTex(options);
      if (parens.start) {
        str = "\\left(".concat(str, "\\right)");
      }
      if (this.step) {
        var step = this.step.toTex(options);
        if (parens.step) {
          step = "\\left(".concat(step, "\\right)");
        }
        str += ":" + step;
      }
      var end = this.end.toTex(options);
      if (parens.end) {
        end = "\\left(".concat(end, "\\right)");
      }
      str += ":" + end;
      return str;
    }
  }
  _defineProperty(RangeNode, "name", name218);
  return RangeNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
var name219 = "RelationalNode";
var dependencies219 = ["Node"];
var createRelationalNode = /* @__PURE__ */ factory(name219, dependencies219, (_ref) => {
  var {
    Node
  } = _ref;
  var operatorMap = {
    equal: "==",
    unequal: "!=",
    smaller: "<",
    larger: ">",
    smallerEq: "<=",
    largerEq: ">="
  };
  class RelationalNode extends Node {
    /**
     * A node representing a chained conditional expression, such as 'x > y > z'
     *
     * @param {String[]} conditionals
     *     An array of conditional operators used to compare the parameters
     * @param {Node[]} params
     *     The parameters that will be compared
     *
     * @constructor RelationalNode
     * @extends {Node}
     */
    constructor(conditionals, params) {
      super();
      if (!Array.isArray(conditionals)) {
        throw new TypeError("Parameter conditionals must be an array");
      }
      if (!Array.isArray(params)) {
        throw new TypeError("Parameter params must be an array");
      }
      if (conditionals.length !== params.length - 1) {
        throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
      }
      this.conditionals = conditionals;
      this.params = params;
    }
    get type() {
      return name219;
    }
    get isRelationalNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math, argNames) {
      var self2 = this;
      var compiled = this.params.map((p) => p._compile(math, argNames));
      return function evalRelationalNode(scope, args, context) {
        var evalLhs;
        var evalRhs = compiled[0](scope, args, context);
        for (var i = 0; i < self2.conditionals.length; i++) {
          evalLhs = evalRhs;
          evalRhs = compiled[i + 1](scope, args, context);
          var condFn = getSafeProperty(math, self2.conditionals[i]);
          if (!condFn(evalLhs, evalRhs)) {
            return false;
          }
        }
        return true;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      this.params.forEach((n, i) => callback(n, "params[" + i + "]", this), this);
    }
    /**
     * Create a new RelationalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RelationalNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, "params[" + i + "]", this)), this));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RelationalNode}
     */
    clone() {
      return new RelationalNode(this.conditionals, this.params);
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
      });
      var ret = paramStrings[0];
      for (var i = 0; i < this.conditionals.length; i++) {
        ret += " " + operatorMap[this.conditionals[i]];
        ret += " " + paramStrings[i + 1];
      }
      return ret;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name219,
        conditionals: this.conditionals,
        params: this.params
      };
    }
    /**
     * Instantiate a RelationalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
     *     where mathjs is optional
     * @returns {RelationalNode}
     */
    static fromJSON(json) {
      return new RelationalNode(json.conditionals, json.params);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
      });
      var ret = paramStrings[0];
      for (var i = 0; i < this.conditionals.length; i++) {
        ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i]]) + "</span>" + paramStrings[i + 1];
      }
      return ret;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
      });
      var ret = paramStrings[0];
      for (var i = 0; i < this.conditionals.length; i++) {
        ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];
      }
      return ret;
    }
  }
  _defineProperty(RelationalNode, "name", name219);
  return RelationalNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
var name220 = "SymbolNode";
var dependencies220 = ["math", "?Unit", "Node"];
var createSymbolNode = /* @__PURE__ */ factory(name220, dependencies220, (_ref) => {
  var {
    math,
    Unit,
    Node
  } = _ref;
  function isValuelessUnit(name310) {
    return Unit ? Unit.isValuelessUnit(name310) : false;
  }
  class SymbolNode extends Node {
    /**
     * @constructor SymbolNode
     * @extends {Node}
     * A symbol node can hold and resolve a symbol
     * @param {string} name
     * @extends {Node}
     */
    constructor(name310) {
      super();
      if (typeof name310 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      this.name = name310;
    }
    get type() {
      return "SymbolNode";
    }
    get isSymbolNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var name310 = this.name;
      if (argNames[name310] === true) {
        return function(scope, args, context) {
          return getSafeProperty(args, name310);
        };
      } else if (name310 in math2) {
        return function(scope, args, context) {
          return scope.has(name310) ? scope.get(name310) : getSafeProperty(math2, name310);
        };
      } else {
        var isUnit2 = isValuelessUnit(name310);
        return function(scope, args, context) {
          return scope.has(name310) ? scope.get(name310) : isUnit2 ? new Unit(null, name310) : SymbolNode.onUndefinedSymbol(name310);
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
    }
    /**
     * Create a new SymbolNode with children produced by the given callback.
     * Trivial since a SymbolNode has no children
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {SymbolNode} Returns a clone of the node
     */
    map(callback) {
      return this.clone();
    }
    /**
     * Throws an error 'Undefined symbol {name}'
     * @param {string} name
     */
    static onUndefinedSymbol(name310) {
      throw new Error("Undefined symbol " + name310);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {SymbolNode}
     */
    clone() {
      return new SymbolNode(this.name);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      return this.name;
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toHTML(options) {
      var name310 = escape(this.name);
      if (name310 === "true" || name310 === "false") {
        return '<span class="math-symbol math-boolean">' + name310 + "</span>";
      } else if (name310 === "i") {
        return '<span class="math-symbol math-imaginary-symbol">' + name310 + "</span>";
      } else if (name310 === "Infinity") {
        return '<span class="math-symbol math-infinity-symbol">' + name310 + "</span>";
      } else if (name310 === "NaN") {
        return '<span class="math-symbol math-nan-symbol">' + name310 + "</span>";
      } else if (name310 === "null") {
        return '<span class="math-symbol math-null-symbol">' + name310 + "</span>";
      } else if (name310 === "undefined") {
        return '<span class="math-symbol math-undefined-symbol">' + name310 + "</span>";
      }
      return '<span class="math-symbol">' + name310 + "</span>";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    }
    /**
     * Instantiate a SymbolNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", name: "x"}`,
     *                       where mathjs is optional
     * @returns {SymbolNode}
     */
    static fromJSON(json) {
      return new SymbolNode(json.name);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(options) {
      var isUnit2 = false;
      if (typeof math[this.name] === "undefined" && isValuelessUnit(this.name)) {
        isUnit2 = true;
      }
      var symbol = toSymbol(this.name, isUnit2);
      if (symbol[0] === "\\") {
        return symbol;
      }
      return " " + symbol;
    }
  }
  return SymbolNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/utils/scope.js
function createSubScope(parentScope) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (typeof parentScope.createSubScope === "function") {
    return assign(parentScope.createSubScope(), ...args);
  }
  return assign(createEmptyMap(), parentScope, ...args);
}

// node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
var name221 = "FunctionNode";
var dependencies221 = ["math", "Node", "SymbolNode"];
var createFunctionNode = /* @__PURE__ */ factory(name221, dependencies221, (_ref) => {
  var _class;
  var {
    math,
    Node,
    SymbolNode
  } = _ref;
  var strin = (entity) => format3(entity, {
    truncate: 78
  });
  function expandTemplate(template, node, options) {
    var latex = "";
    var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
    var inputPos = 0;
    var match;
    while ((match = regex.exec(template)) !== null) {
      latex += template.substring(inputPos, match.index);
      inputPos = match.index;
      if (match[0] === "$$") {
        latex += "$";
        inputPos++;
      } else {
        inputPos += match[0].length;
        var property = node[match[1]];
        if (!property) {
          throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
        }
        if (match[2] === void 0) {
          switch (typeof property) {
            case "string":
              latex += property;
              break;
            case "object":
              if (isNode(property)) {
                latex += property.toTex(options);
              } else if (Array.isArray(property)) {
                latex += property.map(function(arg, index) {
                  if (isNode(arg)) {
                    return arg.toTex(options);
                  }
                  throw new TypeError("Template: " + match[1] + "[" + index + "] is not a Node.");
                }).join(",");
              } else {
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
              }
              break;
            default:
              throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
          }
        } else {
          if (isNode(property[match[2]] && property[match[2]])) {
            latex += property[match[2]].toTex(options);
          } else {
            throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
          }
        }
      }
    }
    latex += template.slice(inputPos);
    return latex;
  }
  class FunctionNode extends Node {
    /**
     * @constructor FunctionNode
     * @extends {./Node}
     * invoke a list with arguments on a node
     * @param {./Node | string} fn
     *     Item resolving to a function on which to invoke
     *     the arguments, typically a SymboNode or AccessorNode
     * @param {./Node[]} args
     */
    constructor(fn, args) {
      super();
      if (typeof fn === "string") {
        fn = new SymbolNode(fn);
      }
      if (!isNode(fn))
        throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.fn = fn;
      this.args = args || [];
    }
    // readonly property name
    get name() {
      return this.fn.name || "";
    }
    get type() {
      return name221;
    }
    get isFunctionNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalArgs = this.args.map((arg) => arg._compile(math2, argNames));
      if (isSymbolNode(this.fn)) {
        var _name = this.fn.name;
        if (!argNames[_name]) {
          var fn = _name in math2 ? getSafeProperty(math2, _name) : void 0;
          var isRaw = typeof fn === "function" && fn.rawArgs === true;
          var resolveFn = (scope) => {
            var value;
            if (scope.has(_name)) {
              value = scope.get(_name);
            } else if (_name in math2) {
              value = getSafeProperty(math2, _name);
            } else {
              return FunctionNode.onUndefinedFunction(_name);
            }
            if (typeof value === "function") {
              return value;
            }
            throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
          };
          if (isRaw) {
            var rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              var fn2 = resolveFn(scope);
              return fn2(rawArgs, math2, createSubScope(scope, args), scope);
            };
          } else {
            switch (evalArgs.length) {
              case 0:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  return fn2();
                };
              case 1:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  return fn2(evalArg0(scope, args, context));
                };
              case 2:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  var evalArg1 = evalArgs[1];
                  return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                };
              default:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
                  return fn2(...values2);
                };
            }
          }
        } else {
          var _rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            var fn2 = getSafeProperty(args, _name);
            if (typeof fn2 !== "function") {
              throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs, math2, createSubScope(scope, args), scope);
            } else {
              var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(fn2, values2);
            }
          };
        }
      } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
        var evalObject = this.fn.object._compile(math2, argNames);
        var prop = this.fn.index.getObjectProperty();
        var _rawArgs2 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var fn2 = getSafeMethod(object, prop);
          if (fn2 !== null && fn2 !== void 0 && fn2.rawArgs) {
            return fn2(_rawArgs2, math2, createSubScope(scope, args), scope);
          } else {
            var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(object, values2);
          }
        };
      } else {
        var fnExpr = this.fn.toString();
        var evalFn = this.fn._compile(math2, argNames);
        var _rawArgs3 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var fn2 = evalFn(scope, args, context);
          if (typeof fn2 !== "function") {
            throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
          }
          if (fn2.rawArgs) {
            return fn2(_rawArgs3, math2, createSubScope(scope, args), scope);
          } else {
            var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(fn2, values2);
          }
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.fn, "fn", this);
      for (var i = 0; i < this.args.length; i++) {
        callback(this.args[i], "args[" + i + "]", this);
      }
    }
    /**
     * Create a new FunctionNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionNode} Returns a transformed copy of the node
     */
    map(callback) {
      var fn = this._ifNode(callback(this.fn, "fn", this));
      var args = [];
      for (var i = 0; i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
      }
      return new FunctionNode(fn, args);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionNode}
     */
    clone() {
      return new FunctionNode(this.fn, this.args.slice(0));
    }
    /**
     * Throws an error 'Undefined function {name}'
     * @param {string} name
     */
    /**
     * Get string representation. (wrapper function)
     * This overrides parts of Node's toString function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toString
     * function.
     *
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toString(options) {
      var customString;
      var name310 = this.fn.toString(options);
      if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, name310)) {
        customString = options.handler[name310](this, options);
      }
      if (typeof customString !== "undefined") {
        return customString;
      }
      return super.toString(options);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var args = this.args.map(function(arg) {
        return arg.toString(options);
      });
      var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
      return fn + "(" + args.join(", ") + ")";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name221,
        fn: this.fn,
        args: this.args
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionNode}
     */
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    toHTML(options) {
      var args = this.args.map(function(arg) {
        return arg.toHTML(options);
      });
      return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    }
    /**
     * Get LaTeX representation. (wrapper function)
     * This overrides parts of Node's toTex function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toTex
     * function.
     *
     * @param {Object} options
     * @return {string}
     */
    toTex(options) {
      var customTex;
      if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, this.name)) {
        customTex = options.handler[this.name](this, options);
      }
      if (typeof customTex !== "undefined") {
        return customTex;
      }
      return super.toTex(options);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var args = this.args.map(function(arg) {
        return arg.toTex(options);
      });
      var latexConverter;
      if (latexFunctions[this.name]) {
        latexConverter = latexFunctions[this.name];
      }
      if (math[this.name] && (typeof math[this.name].toTex === "function" || typeof math[this.name].toTex === "object" || typeof math[this.name].toTex === "string")) {
        latexConverter = math[this.name].toTex;
      }
      var customToTex;
      switch (typeof latexConverter) {
        case "function":
          customToTex = latexConverter(this, options);
          break;
        case "string":
          customToTex = expandTemplate(latexConverter, this, options);
          break;
        case "object":
          switch (typeof latexConverter[args.length]) {
            case "function":
              customToTex = latexConverter[args.length](this, options);
              break;
            case "string":
              customToTex = expandTemplate(latexConverter[args.length], this, options);
              break;
          }
      }
      if (typeof customToTex !== "undefined") {
        return customToTex;
      }
      return expandTemplate(defaultTemplate, this, options);
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.name;
    }
  }
  _class = FunctionNode;
  _defineProperty(FunctionNode, "name", name221);
  _defineProperty(FunctionNode, "onUndefinedFunction", function(name310) {
    throw new Error("Undefined function " + name310);
  });
  _defineProperty(FunctionNode, "fromJSON", function(json) {
    return new _class(json.fn, json.args);
  });
  return FunctionNode;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/parse.js
var name222 = "parse";
var dependencies222 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
var createParse = /* @__PURE__ */ factory(name222, dependencies222, (_ref) => {
  var {
    typed: typed3,
    numeric: numeric2,
    config: config4,
    AccessorNode,
    ArrayNode,
    AssignmentNode,
    BlockNode,
    ConditionalNode,
    ConstantNode,
    FunctionAssignmentNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    RangeNode,
    RelationalNode,
    SymbolNode
  } = _ref;
  var parse = typed3(name222, {
    string: function string(expression) {
      return parseStart(expression, {});
    },
    "Array | Matrix": function ArrayMatrix(expressions) {
      return parseMultiple(expressions, {});
    },
    "string, Object": function stringObject(expression, options) {
      var extraNodes = options.nodes !== void 0 ? options.nodes : {};
      return parseStart(expression, extraNodes);
    },
    "Array | Matrix, Object": parseMultiple
  });
  function parseMultiple(expressions) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var extraNodes = options.nodes !== void 0 ? options.nodes : {};
    return deepMap(expressions, function(elem) {
      if (typeof elem !== "string")
        throw new TypeError("String expected");
      return parseStart(elem, extraNodes);
    });
  }
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    NUMBER: 2,
    SYMBOL: 3,
    UNKNOWN: 4
  };
  var DELIMITERS = {
    ",": true,
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
    '"': true,
    "'": true,
    ";": true,
    "+": true,
    "-": true,
    "*": true,
    ".*": true,
    "/": true,
    "./": true,
    "%": true,
    "^": true,
    ".^": true,
    "~": true,
    "!": true,
    "&": true,
    "|": true,
    "^|": true,
    "=": true,
    ":": true,
    "?": true,
    "==": true,
    "!=": true,
    "<": true,
    ">": true,
    "<=": true,
    ">=": true,
    "<<": true,
    ">>": true,
    ">>>": true
  };
  var NAMED_DELIMITERS = {
    mod: true,
    to: true,
    in: true,
    and: true,
    xor: true,
    or: true,
    not: true
  };
  var CONSTANTS = {
    true: true,
    false: false,
    null: null,
    undefined: void 0
  };
  var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
  var ESCAPE_CHARACTERS = {
    '"': '"',
    "'": "'",
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	"
    // note that \u is handled separately in parseStringToken()
  };
  function initialState() {
    return {
      extraNodes: {},
      // current extra nodes, must be careful not to mutate
      expression: "",
      // current expression
      comment: "",
      // last parsed comment
      index: 0,
      // current index in expr
      token: "",
      // current token
      tokenType: TOKENTYPE.NULL,
      // type of the token
      nestingLevel: 0,
      // level of nesting inside parameters, used to ignore newline characters
      conditionalLevel: null
      // when a conditional is being parsed, the level of the conditional is stored here
    };
  }
  function currentString(state, length) {
    return state.expression.substr(state.index, length);
  }
  function currentCharacter(state) {
    return currentString(state, 1);
  }
  function next(state) {
    state.index++;
  }
  function prevCharacter(state) {
    return state.expression.charAt(state.index - 1);
  }
  function nextCharacter(state) {
    return state.expression.charAt(state.index + 1);
  }
  function getToken(state) {
    state.tokenType = TOKENTYPE.NULL;
    state.token = "";
    state.comment = "";
    while (true) {
      if (currentCharacter(state) === "#") {
        while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
          state.comment += currentCharacter(state);
          next(state);
        }
      }
      if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {
        next(state);
      } else {
        break;
      }
    }
    if (currentCharacter(state) === "") {
      state.tokenType = TOKENTYPE.DELIMITER;
      return;
    }
    if (currentCharacter(state) === "\n" && !state.nestingLevel) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = currentCharacter(state);
      next(state);
      return;
    }
    var c1 = currentCharacter(state);
    var c2 = currentString(state, 2);
    var c3 = currentString(state, 3);
    if (c3.length === 3 && DELIMITERS[c3]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c3;
      next(state);
      next(state);
      next(state);
      return;
    }
    if (c2.length === 2 && DELIMITERS[c2]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c2;
      next(state);
      next(state);
      return;
    }
    if (DELIMITERS[c1]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c1;
      next(state);
      return;
    }
    if (parse.isDigitDot(c1)) {
      state.tokenType = TOKENTYPE.NUMBER;
      var _c = currentString(state, 2);
      if (_c === "0b" || _c === "0o" || _c === "0x") {
        state.token += currentCharacter(state);
        next(state);
        state.token += currentCharacter(state);
        next(state);
        while (parse.isHexDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === ".") {
          state.token += ".";
          next(state);
          while (parse.isHexDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        } else if (currentCharacter(state) === "i") {
          state.token += "i";
          next(state);
          while (parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        return;
      }
      if (currentCharacter(state) === ".") {
        state.token += currentCharacter(state);
        next(state);
        if (!parse.isDigit(currentCharacter(state))) {
          state.tokenType = TOKENTYPE.DELIMITER;
          return;
        }
      } else {
        while (parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
      }
      while (parse.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
          state.token += currentCharacter(state);
          next(state);
          if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
            state.token += currentCharacter(state);
            next(state);
          }
          if (!parse.isDigit(currentCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
          while (parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        } else if (nextCharacter(state) === ".") {
          next(state);
          throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
        }
      }
      return;
    }
    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {
        state.tokenType = TOKENTYPE.DELIMITER;
      } else {
        state.tokenType = TOKENTYPE.SYMBOL;
      }
      return;
    }
    state.tokenType = TOKENTYPE.UNKNOWN;
    while (currentCharacter(state) !== "") {
      state.token += currentCharacter(state);
      next(state);
    }
    throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
  }
  function getTokenSkipNewline(state) {
    do {
      getToken(state);
    } while (state.token === "\n");
  }
  function openParams(state) {
    state.nestingLevel++;
  }
  function closeParams(state) {
    state.nestingLevel--;
  }
  parse.isAlpha = function isAlpha(c2, cPrev, cNext) {
    return parse.isValidLatinOrGreek(c2) || parse.isValidMathSymbol(c2, cNext) || parse.isValidMathSymbol(cPrev, c2);
  };
  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c2) {
    return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c2);
  };
  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {
    return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
  };
  parse.isWhitespace = function isWhitespace(c2, nestingLevel) {
    return c2 === " " || c2 === "	" || c2 === "\n" && nestingLevel > 0;
  };
  parse.isDecimalMark = function isDecimalMark(c2, cNext) {
    return c2 === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
  };
  parse.isDigitDot = function isDigitDot(c2) {
    return c2 >= "0" && c2 <= "9" || c2 === ".";
  };
  parse.isDigit = function isDigit(c2) {
    return c2 >= "0" && c2 <= "9";
  };
  parse.isHexDigit = function isHexDigit(c2) {
    return c2 >= "0" && c2 <= "9" || c2 >= "a" && c2 <= "f" || c2 >= "A" && c2 <= "F";
  };
  function parseStart(expression, extraNodes) {
    var state = initialState();
    _extends(state, {
      expression,
      extraNodes
    });
    getToken(state);
    var node = parseBlock(state);
    if (state.token !== "") {
      if (state.tokenType === TOKENTYPE.DELIMITER) {
        throw createError(state, "Unexpected operator " + state.token);
      } else {
        throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
      }
    }
    return node;
  }
  function parseBlock(state) {
    var node;
    var blocks = [];
    var visible;
    if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
      node = parseAssignment(state);
      if (state.comment) {
        node.comment = state.comment;
      }
    }
    while (state.token === "\n" || state.token === ";") {
      if (blocks.length === 0 && node) {
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
      getToken(state);
      if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
        node = parseAssignment(state);
        if (state.comment) {
          node.comment = state.comment;
        }
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
    }
    if (blocks.length > 0) {
      return new BlockNode(blocks);
    } else {
      if (!node) {
        node = new ConstantNode(void 0);
        if (state.comment) {
          node.comment = state.comment;
        }
      }
      return node;
    }
  }
  function parseAssignment(state) {
    var name310, args, value, valid;
    var node = parseConditional(state);
    if (state.token === "=") {
      if (isSymbolNode(node)) {
        name310 = node.name;
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode(new SymbolNode(name310), value);
      } else if (isAccessorNode(node)) {
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode(node.object, node.index, value);
      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
        valid = true;
        args = [];
        name310 = node.name;
        node.args.forEach(function(arg, index) {
          if (isSymbolNode(arg)) {
            args[index] = arg.name;
          } else {
            valid = false;
          }
        });
        if (valid) {
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new FunctionAssignmentNode(name310, args, value);
        }
      }
      throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
    }
    return node;
  }
  function parseConditional(state) {
    var node = parseLogicalOr(state);
    while (state.token === "?") {
      var prev = state.conditionalLevel;
      state.conditionalLevel = state.nestingLevel;
      getTokenSkipNewline(state);
      var condition = node;
      var trueExpr = parseAssignment(state);
      if (state.token !== ":")
        throw createSyntaxError(state, "False part of conditional expression expected");
      state.conditionalLevel = null;
      getTokenSkipNewline(state);
      var falseExpr = parseAssignment(state);
      node = new ConditionalNode(condition, trueExpr, falseExpr);
      state.conditionalLevel = prev;
    }
    return node;
  }
  function parseLogicalOr(state) {
    var node = parseLogicalXor(state);
    while (state.token === "or") {
      getTokenSkipNewline(state);
      node = new OperatorNode("or", "or", [node, parseLogicalXor(state)]);
    }
    return node;
  }
  function parseLogicalXor(state) {
    var node = parseLogicalAnd(state);
    while (state.token === "xor") {
      getTokenSkipNewline(state);
      node = new OperatorNode("xor", "xor", [node, parseLogicalAnd(state)]);
    }
    return node;
  }
  function parseLogicalAnd(state) {
    var node = parseBitwiseOr(state);
    while (state.token === "and") {
      getTokenSkipNewline(state);
      node = new OperatorNode("and", "and", [node, parseBitwiseOr(state)]);
    }
    return node;
  }
  function parseBitwiseOr(state) {
    var node = parseBitwiseXor(state);
    while (state.token === "|") {
      getTokenSkipNewline(state);
      node = new OperatorNode("|", "bitOr", [node, parseBitwiseXor(state)]);
    }
    return node;
  }
  function parseBitwiseXor(state) {
    var node = parseBitwiseAnd(state);
    while (state.token === "^|") {
      getTokenSkipNewline(state);
      node = new OperatorNode("^|", "bitXor", [node, parseBitwiseAnd(state)]);
    }
    return node;
  }
  function parseBitwiseAnd(state) {
    var node = parseRelational(state);
    while (state.token === "&") {
      getTokenSkipNewline(state);
      node = new OperatorNode("&", "bitAnd", [node, parseRelational(state)]);
    }
    return node;
  }
  function parseRelational(state) {
    var params = [parseShift(state)];
    var conditionals = [];
    var operators = {
      "==": "equal",
      "!=": "unequal",
      "<": "smaller",
      ">": "larger",
      "<=": "smallerEq",
      ">=": "largerEq"
    };
    while (hasOwnProperty(operators, state.token)) {
      var cond = {
        name: state.token,
        fn: operators[state.token]
      };
      conditionals.push(cond);
      getTokenSkipNewline(state);
      params.push(parseShift(state));
    }
    if (params.length === 1) {
      return params[0];
    } else if (params.length === 2) {
      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
    } else {
      return new RelationalNode(conditionals.map((c2) => c2.fn), params);
    }
  }
  function parseShift(state) {
    var node, name310, fn, params;
    node = parseConversion(state);
    var operators = {
      "<<": "leftShift",
      ">>": "rightArithShift",
      ">>>": "rightLogShift"
    };
    while (hasOwnProperty(operators, state.token)) {
      name310 = state.token;
      fn = operators[name310];
      getTokenSkipNewline(state);
      params = [node, parseConversion(state)];
      node = new OperatorNode(name310, fn, params);
    }
    return node;
  }
  function parseConversion(state) {
    var node, name310, fn, params;
    node = parseRange(state);
    var operators = {
      to: "to",
      in: "to"
      // alias of 'to'
    };
    while (hasOwnProperty(operators, state.token)) {
      name310 = state.token;
      fn = operators[name310];
      getTokenSkipNewline(state);
      if (name310 === "in" && state.token === "") {
        node = new OperatorNode("*", "multiply", [node, new SymbolNode("in")], true);
      } else {
        params = [node, parseRange(state)];
        node = new OperatorNode(name310, fn, params);
      }
    }
    return node;
  }
  function parseRange(state) {
    var node;
    var params = [];
    if (state.token === ":") {
      node = new ConstantNode(1);
    } else {
      node = parseAddSubtract(state);
    }
    if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
      params.push(node);
      while (state.token === ":" && params.length < 3) {
        getTokenSkipNewline(state);
        if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
          params.push(new SymbolNode("end"));
        } else {
          params.push(parseAddSubtract(state));
        }
      }
      if (params.length === 3) {
        node = new RangeNode(params[0], params[2], params[1]);
      } else {
        node = new RangeNode(params[0], params[1]);
      }
    }
    return node;
  }
  function parseAddSubtract(state) {
    var node, name310, fn, params;
    node = parseMultiplyDivide(state);
    var operators = {
      "+": "add",
      "-": "subtract"
    };
    while (hasOwnProperty(operators, state.token)) {
      name310 = state.token;
      fn = operators[name310];
      getTokenSkipNewline(state);
      var rightNode = parseMultiplyDivide(state);
      if (rightNode.isPercentage) {
        params = [node, new OperatorNode("*", "multiply", [node, rightNode])];
      } else {
        params = [node, rightNode];
      }
      node = new OperatorNode(name310, fn, params);
    }
    return node;
  }
  function parseMultiplyDivide(state) {
    var node, last, name310, fn;
    node = parseImplicitMultiplication(state);
    last = node;
    var operators = {
      "*": "multiply",
      ".*": "dotMultiply",
      "/": "divide",
      "./": "dotDivide"
    };
    while (true) {
      if (hasOwnProperty(operators, state.token)) {
        name310 = state.token;
        fn = operators[name310];
        getTokenSkipNewline(state);
        last = parseImplicitMultiplication(state);
        node = new OperatorNode(name310, fn, [node, last]);
      } else {
        break;
      }
    }
    return node;
  }
  function parseImplicitMultiplication(state) {
    var node, last;
    node = parseRule2(state);
    last = node;
    while (true) {
      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
        last = parseRule2(state);
        node = new OperatorNode(
          "*",
          "multiply",
          [node, last],
          true
          /* implicit */
        );
      } else {
        break;
      }
    }
    return node;
  }
  function parseRule2(state) {
    var node = parsePercentage(state);
    var last = node;
    var tokenStates = [];
    while (true) {
      if (state.token === "/" && rule2Node(last)) {
        tokenStates.push(_extends({}, state));
        getTokenSkipNewline(state);
        if (state.tokenType === TOKENTYPE.NUMBER) {
          tokenStates.push(_extends({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
            _extends(state, tokenStates.pop());
            tokenStates.pop();
            last = parsePercentage(state);
            node = new OperatorNode("/", "divide", [node, last]);
          } else {
            tokenStates.pop();
            _extends(state, tokenStates.pop());
            break;
          }
        } else {
          _extends(state, tokenStates.pop());
          break;
        }
      } else {
        break;
      }
    }
    return node;
  }
  function parsePercentage(state) {
    var node, name310, fn, params;
    node = parseUnary(state);
    var operators = {
      "%": "mod",
      mod: "mod"
    };
    while (hasOwnProperty(operators, state.token)) {
      name310 = state.token;
      fn = operators[name310];
      getTokenSkipNewline(state);
      if (name310 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
        node = new OperatorNode("/", "divide", [node, new ConstantNode(100)], false, true);
      } else {
        params = [node, parseUnary(state)];
        node = new OperatorNode(name310, fn, params);
      }
    }
    return node;
  }
  function parseUnary(state) {
    var name310, params, fn;
    var operators = {
      "-": "unaryMinus",
      "+": "unaryPlus",
      "~": "bitNot",
      not: "not"
    };
    if (hasOwnProperty(operators, state.token)) {
      fn = operators[state.token];
      name310 = state.token;
      getTokenSkipNewline(state);
      params = [parseUnary(state)];
      return new OperatorNode(name310, fn, params);
    }
    return parsePow(state);
  }
  function parsePow(state) {
    var node, name310, fn, params;
    node = parseLeftHandOperators(state);
    if (state.token === "^" || state.token === ".^") {
      name310 = state.token;
      fn = name310 === "^" ? "pow" : "dotPow";
      getTokenSkipNewline(state);
      params = [node, parseUnary(state)];
      node = new OperatorNode(name310, fn, params);
    }
    return node;
  }
  function parseLeftHandOperators(state) {
    var node, name310, fn, params;
    node = parseCustomNodes(state);
    var operators = {
      "!": "factorial",
      "'": "ctranspose"
    };
    while (hasOwnProperty(operators, state.token)) {
      name310 = state.token;
      fn = operators[name310];
      getToken(state);
      params = [node];
      node = new OperatorNode(name310, fn, params);
      node = parseAccessors(state, node);
    }
    return node;
  }
  function parseCustomNodes(state) {
    var params = [];
    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {
      var CustomNode = state.extraNodes[state.token];
      getToken(state);
      if (state.token === "(") {
        params = [];
        openParams(state);
        getToken(state);
        if (state.token !== ")") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
      }
      return new CustomNode(params);
    }
    return parseSymbol(state);
  }
  function parseSymbol(state) {
    var node, name310;
    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
      name310 = state.token;
      getToken(state);
      if (hasOwnProperty(CONSTANTS, name310)) {
        node = new ConstantNode(CONSTANTS[name310]);
      } else if (NUMERIC_CONSTANTS.indexOf(name310) !== -1) {
        node = new ConstantNode(numeric2(name310, "number"));
      } else {
        node = new SymbolNode(name310);
      }
      node = parseAccessors(state, node);
      return node;
    }
    return parseString(state);
  }
  function parseAccessors(state, node, types) {
    var params;
    while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.indexOf(state.token) !== -1)) {
      params = [];
      if (state.token === "(") {
        if (isSymbolNode(node) || isAccessorNode(node)) {
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
          node = new FunctionNode(node, params);
        } else {
          return node;
        }
      } else if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== "]") {
          throw createSyntaxError(state, "Parenthesis ] expected");
        }
        closeParams(state);
        getToken(state);
        node = new AccessorNode(node, new IndexNode(params));
      } else {
        getToken(state);
        var isPropertyName = state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS;
        if (!isPropertyName) {
          throw createSyntaxError(state, "Property name expected after dot");
        }
        params.push(new ConstantNode(state.token));
        getToken(state);
        var dotNotation = true;
        node = new AccessorNode(node, new IndexNode(params, dotNotation));
      }
    }
    return node;
  }
  function parseString(state) {
    var node, str;
    if (state.token === '"' || state.token === "'") {
      str = parseStringToken(state, state.token);
      node = new ConstantNode(str);
      node = parseAccessors(state, node);
      return node;
    }
    return parseMatrix(state);
  }
  function parseStringToken(state, quote) {
    var str = "";
    while (currentCharacter(state) !== "" && currentCharacter(state) !== quote) {
      if (currentCharacter(state) === "\\") {
        next(state);
        var char = currentCharacter(state);
        var escapeChar = ESCAPE_CHARACTERS[char];
        if (escapeChar !== void 0) {
          str += escapeChar;
          state.index += 1;
        } else if (char === "u") {
          var unicode = state.expression.slice(state.index + 1, state.index + 5);
          if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {
            str += String.fromCharCode(parseInt(unicode, 16));
            state.index += 5;
          } else {
            throw createSyntaxError(state, "Invalid unicode character \\u".concat(unicode));
          }
        } else {
          throw createSyntaxError(state, "Bad escape character \\".concat(char));
        }
      } else {
        str += currentCharacter(state);
        next(state);
      }
    }
    getToken(state);
    if (state.token !== quote) {
      throw createSyntaxError(state, "End of string ".concat(quote, " expected"));
    }
    getToken(state);
    return str;
  }
  function parseMatrix(state) {
    var array2, params, rows, cols;
    if (state.token === "[") {
      openParams(state);
      getToken(state);
      if (state.token !== "]") {
        var row = parseRow(state);
        if (state.token === ";") {
          rows = 1;
          params = [row];
          while (state.token === ";") {
            getToken(state);
            params[rows] = parseRow(state);
            rows++;
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          cols = params[0].items.length;
          for (var r = 1; r < rows; r++) {
            if (params[r].items.length !== cols) {
              throw createError(state, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
            }
          }
          array2 = new ArrayNode(params);
        } else {
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          array2 = row;
        }
      } else {
        closeParams(state);
        getToken(state);
        array2 = new ArrayNode([]);
      }
      return parseAccessors(state, array2);
    }
    return parseObject(state);
  }
  function parseRow(state) {
    var params = [parseAssignment(state)];
    var len = 1;
    while (state.token === ",") {
      getToken(state);
      params[len] = parseAssignment(state);
      len++;
    }
    return new ArrayNode(params);
  }
  function parseObject(state) {
    if (state.token === "{") {
      openParams(state);
      var key;
      var properties2 = {};
      do {
        getToken(state);
        if (state.token !== "}") {
          if (state.token === '"' || state.token === "'") {
            key = parseStringToken(state, state.token);
          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
            key = state.token;
            getToken(state);
          } else {
            throw createSyntaxError(state, "Symbol or string expected as object key");
          }
          if (state.token !== ":") {
            throw createSyntaxError(state, "Colon : expected after object key");
          }
          getToken(state);
          properties2[key] = parseAssignment(state);
        }
      } while (state.token === ",");
      if (state.token !== "}") {
        throw createSyntaxError(state, "Comma , or bracket } expected after object value");
      }
      closeParams(state);
      getToken(state);
      var node = new ObjectNode(properties2);
      node = parseAccessors(state, node);
      return node;
    }
    return parseNumber(state);
  }
  function parseNumber(state) {
    var numberStr;
    if (state.tokenType === TOKENTYPE.NUMBER) {
      numberStr = state.token;
      getToken(state);
      return new ConstantNode(numeric2(numberStr, config4.number));
    }
    return parseParentheses(state);
  }
  function parseParentheses(state) {
    var node;
    if (state.token === "(") {
      openParams(state);
      getToken(state);
      node = parseAssignment(state);
      if (state.token !== ")") {
        throw createSyntaxError(state, "Parenthesis ) expected");
      }
      closeParams(state);
      getToken(state);
      node = new ParenthesisNode(node);
      node = parseAccessors(state, node);
      return node;
    }
    return parseEnd(state);
  }
  function parseEnd(state) {
    if (state.token === "") {
      throw createSyntaxError(state, "Unexpected end of expression");
    } else {
      throw createSyntaxError(state, "Value expected");
    }
  }
  function col(state) {
    return state.index - state.token.length + 1;
  }
  function createSyntaxError(state, message) {
    var c2 = col(state);
    var error = new SyntaxError(message + " (char " + c2 + ")");
    error.char = c2;
    return error;
  }
  function createError(state, message) {
    var c2 = col(state);
    var error = new SyntaxError(message + " (char " + c2 + ")");
    error.char = c2;
    return error;
  }
  typed3.addConversion({
    from: "string",
    to: "Node",
    convert: parse
  });
  return parse;
});

// node_modules/mathjs/lib/esm/expression/function/compile.js
var name223 = "compile";
var dependencies223 = ["typed", "parse"];
var createCompile = /* @__PURE__ */ factory(name223, dependencies223, (_ref) => {
  var {
    typed: typed3,
    parse
  } = _ref;
  return typed3(name223, {
    string: function string(expr) {
      return parse(expr).compile();
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      return deepMap(expr, function(entry) {
        return parse(entry).compile();
      });
    }
  });
});

// node_modules/mathjs/lib/esm/expression/function/evaluate.js
var name224 = "evaluate";
var dependencies224 = ["typed", "parse"];
var createEvaluate = /* @__PURE__ */ factory(name224, dependencies224, (_ref) => {
  var {
    typed: typed3,
    parse
  } = _ref;
  return typed3(name224, {
    string: function string(expr) {
      var scope = createEmptyMap();
      return parse(expr).compile().evaluate(scope);
    },
    "string, Map | Object": function stringMapObject(expr, scope) {
      return parse(expr).compile().evaluate(scope);
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      var scope = createEmptyMap();
      return deepMap(expr, function(entry) {
        return parse(entry).compile().evaluate(scope);
      });
    },
    "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
      return deepMap(expr, function(entry) {
        return parse(entry).compile().evaluate(scope);
      });
    }
  });
});

// node_modules/mathjs/lib/esm/expression/Parser.js
var name225 = "Parser";
var dependencies225 = ["evaluate"];
var createParserClass = /* @__PURE__ */ factory(name225, dependencies225, (_ref) => {
  var {
    evaluate
  } = _ref;
  function Parser() {
    if (!(this instanceof Parser)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    Object.defineProperty(this, "scope", {
      value: createEmptyMap(),
      writable: false
    });
  }
  Parser.prototype.type = "Parser";
  Parser.prototype.isParser = true;
  Parser.prototype.evaluate = function(expr) {
    return evaluate(expr, this.scope);
  };
  Parser.prototype.get = function(name310) {
    if (this.scope.has(name310)) {
      return this.scope.get(name310);
    }
  };
  Parser.prototype.getAll = function() {
    return toObject(this.scope);
  };
  Parser.prototype.getAllAsMap = function() {
    return this.scope;
  };
  Parser.prototype.set = function(name310, value) {
    this.scope.set(name310, value);
    return value;
  };
  Parser.prototype.remove = function(name310) {
    this.scope.delete(name310);
  };
  Parser.prototype.clear = function() {
    this.scope.clear();
  };
  return Parser;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/expression/function/parser.js
var name226 = "parser";
var dependencies226 = ["typed", "Parser"];
var createParser = /* @__PURE__ */ factory(name226, dependencies226, (_ref) => {
  var {
    typed: typed3,
    Parser
  } = _ref;
  return typed3(name226, {
    "": function _() {
      return new Parser();
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
var name227 = "lup";
var dependencies227 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = /* @__PURE__ */ factory(name227, dependencies227, (_ref) => {
  var {
    typed: typed3,
    matrix,
    abs: abs3,
    addScalar,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    larger,
    equalScalar,
    unaryMinus,
    DenseMatrix: DenseMatrix2,
    SparseMatrix,
    Spa
  } = _ref;
  return typed3(name227, {
    DenseMatrix: function DenseMatrix3(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix2(m) {
      return _sparseLUP(m);
    },
    Array: function Array2(a2) {
      var m = matrix(a2);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i, j, k2;
    var p = [];
    for (i = 0; i < rows; i++) {
      p[i] = i;
    }
    for (j = 0; j < columns; j++) {
      if (j > 0) {
        for (i = 0; i < rows; i++) {
          var min4 = Math.min(i, j);
          var s2 = 0;
          for (k2 = 0; k2 < min4; k2++) {
            s2 = addScalar(s2, multiplyScalar(data[i][k2], data[k2][j]));
          }
          data[i][j] = subtractScalar(data[i][j], s2);
        }
      }
      var pi4 = j;
      var pabsv = 0;
      var vjj = 0;
      for (i = j; i < rows; i++) {
        var v = data[i][j];
        var absv = abs3(v);
        if (larger(absv, pabsv)) {
          pi4 = i;
          pabsv = absv;
          vjj = v;
        }
      }
      if (j !== pi4) {
        p[j] = [p[pi4], p[pi4] = p[j]][0];
        DenseMatrix2._swapRows(j, pi4, data);
      }
      if (j < rows) {
        for (i = j + 1; i < rows; i++) {
          var vij = data[i][j];
          if (!equalScalar(vij, 0)) {
            data[i][j] = divideScalar(data[i][j], vjj);
          }
        }
      }
    }
    for (j = 0; j < columns; j++) {
      for (i = 0; i < rows; i++) {
        if (j === 0) {
          if (i < columns) {
            udata[i] = [];
          }
          ldata[i] = [];
        }
        if (i < j) {
          if (i < columns) {
            udata[i][j] = data[i][j];
          }
          if (j < rows) {
            ldata[i][j] = 0;
          }
          continue;
        }
        if (i === j) {
          if (i < columns) {
            udata[i][j] = data[i][j];
          }
          if (j < rows) {
            ldata[i][j] = 1;
          }
          continue;
        }
        if (i < columns) {
          udata[i][j] = 0;
        }
        if (j < rows) {
          ldata[i][j] = data[i][j];
        }
      }
    }
    var l = new DenseMatrix2({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix2({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i = 0, n = p.length; i < n; i++) {
      pv[p[i]] = i;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values2 = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i, j, k2;
    var pvCo = [];
    var pvOc = [];
    for (i = 0; i < rows; i++) {
      pvCo[i] = i;
      pvOc[i] = i;
    }
    var swapIndeces = function swapIndeces2(x2, y2) {
      var kx2 = pvOc[x2];
      var ky2 = pvOc[y2];
      pvCo[kx2] = y2;
      pvCo[ky2] = x2;
      pvOc[x2] = ky2;
      pvOc[y2] = kx2;
    };
    var _loop = function _loop2() {
      var spa = new Spa();
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k2 = k0; k2 < k1; k2++) {
        i = index[k2];
        spa.set(pvCo[i], values2[k2]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k3, vkj) {
          SparseMatrix._forEachRow(k3, lvalues, lindex, lptr, function(i2, vik) {
            if (i2 > k3) {
              spa.accumulate(i2, unaryMinus(multiplyScalar(vik, vkj)));
            }
          });
        });
      }
      var pi4 = j;
      var vjj = spa.get(j);
      var pabsv = abs3(vjj);
      spa.forEach(j + 1, rows - 1, function(x2, v) {
        var absv = abs3(v);
        if (larger(absv, pabsv)) {
          pi4 = x2;
          pabsv = absv;
          vjj = v;
        }
      });
      if (j !== pi4) {
        SparseMatrix._swapRows(j, pi4, lsize[1], lvalues, lindex, lptr);
        SparseMatrix._swapRows(j, pi4, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi4);
        swapIndeces(j, pi4);
      }
      spa.forEach(0, rows - 1, function(x2, v) {
        if (x2 <= j) {
          uvalues.push(v);
          uindex.push(x2);
        } else {
          v = divideScalar(v, vjj);
          if (!equalScalar(v, 0)) {
            lvalues.push(v);
            lindex.push(x2);
          }
        }
      });
    };
    for (j = 0; j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
var name228 = "qr";
var dependencies228 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"];
var createQr = /* @__PURE__ */ factory(name228, dependencies228, (_ref) => {
  var {
    typed: typed3,
    matrix,
    zeros: zeros2,
    identity: identity5,
    isZero,
    equal,
    sign: sign4,
    sqrt: sqrt5,
    conj,
    unaryMinus,
    addScalar,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    complex
  } = _ref;
  return _extends(typed3(name228, {
    DenseMatrix: function DenseMatrix2(m) {
      return _denseQR(m);
    },
    SparseMatrix: function SparseMatrix(m) {
      return _sparseQR(m);
    },
    Array: function Array2(a2) {
      var m = matrix(a2);
      var r = _denseQR(m);
      return {
        Q: r.Q.valueOf(),
        R: r.R.valueOf()
      };
    }
  }), {
    _denseQRimpl
  });
  function _denseQRimpl(m) {
    var rows = m._size[0];
    var cols = m._size[1];
    var Q2 = identity5([rows], "dense");
    var Qdata = Q2._data;
    var R = m.clone();
    var Rdata = R._data;
    var i, j, k2;
    var w = zeros2([rows], "");
    for (k2 = 0; k2 < Math.min(cols, rows); ++k2) {
      var pivot = Rdata[k2][k2];
      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign4(pivot));
      var conjSgn = conj(sgn);
      var alphaSquared = 0;
      for (i = k2; i < rows; i++) {
        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k2], conj(Rdata[i][k2])));
      }
      var alpha = multiplyScalar(sgn, sqrt5(alphaSquared));
      if (!isZero(alpha)) {
        var u1 = subtractScalar(pivot, alpha);
        w[k2] = 1;
        for (i = k2 + 1; i < rows; i++) {
          w[i] = divideScalar(Rdata[i][k2], u1);
        }
        var tau4 = unaryMinus(conj(divideScalar(u1, alpha)));
        var s2 = void 0;
        for (j = k2; j < cols; j++) {
          s2 = 0;
          for (i = k2; i < rows; i++) {
            s2 = addScalar(s2, multiplyScalar(conj(w[i]), Rdata[i][j]));
          }
          s2 = multiplyScalar(s2, tau4);
          for (i = k2; i < rows; i++) {
            Rdata[i][j] = multiplyScalar(subtractScalar(Rdata[i][j], multiplyScalar(w[i], s2)), conjSgn);
          }
        }
        for (i = 0; i < rows; i++) {
          s2 = 0;
          for (j = k2; j < rows; j++) {
            s2 = addScalar(s2, multiplyScalar(Qdata[i][j], w[j]));
          }
          s2 = multiplyScalar(s2, tau4);
          for (j = k2; j < rows; ++j) {
            Qdata[i][j] = divideScalar(subtractScalar(Qdata[i][j], multiplyScalar(s2, conj(w[j]))), conjSgn);
          }
        }
      }
    }
    return {
      Q: Q2,
      R,
      toString: function toString() {
        return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
      }
    };
  }
  function _denseQR(m) {
    var ret = _denseQRimpl(m);
    var Rdata = ret.R._data;
    if (m._data.length > 0) {
      var zero3 = Rdata[0][0].type === "Complex" ? complex(0) : 0;
      for (var i = 0; i < Rdata.length; ++i) {
        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
          Rdata[i][j] = zero3;
        }
      }
    }
    return ret;
  }
  function _sparseQR(m) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
function csPermute(a2, pinv, q, values2) {
  var avalues = a2._values;
  var aindex = a2._index;
  var aptr = a2._ptr;
  var asize = a2._size;
  var adt = a2._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values2 && a2._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k2 = 0; k2 < n; k2++) {
    cptr[k2] = nz;
    var j = q ? q[k2] : k2;
    for (var t03 = aptr[j], t13 = aptr[j + 1], t = t03; t < t13; t++) {
      var r = pinv ? pinv[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a2.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
function csTdfs(j, k2, w, head, next, post, stack) {
  var top2 = 0;
  w[stack] = j;
  while (top2 >= 0) {
    var p = w[stack + top2];
    var i = w[head + p];
    if (i === -1) {
      top2--;
      post[k2++] = p;
    } else {
      w[head + p] = w[next + i];
      ++top2;
      w[stack + top2] = i;
    }
  }
  return k2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  var k2 = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack = 2 * n;
  for (j = 0; j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1; j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0; j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k2 = csTdfs(j, k2, w, head, next, post, stack);
  }
  return post;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
function csEtree(a2, ata) {
  if (!a2) {
    return null;
  }
  var aindex = a2._index;
  var aptr = a2._ptr;
  var asize = a2._size;
  var m = asize[0];
  var n = asize[1];
  var parent = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i, inext;
  if (ata) {
    for (i = 0; i < m; i++) {
      w[prev + i] = -1;
    }
  }
  for (var k2 = 0; k2 < n; k2++) {
    parent[k2] = -1;
    w[ancestor + k2] = -1;
    for (var p0 = aptr[k2], p1 = aptr[k2 + 1], p = p0; p < p1; p++) {
      var r = aindex[p];
      i = ata ? w[prev + r] : r;
      for (; i !== -1 && i < k2; i = inext) {
        inext = w[ancestor + i];
        w[ancestor + i] = k2;
        if (inext === -1) {
          parent[i] = k2;
        }
      }
      if (ata) {
        w[prev + r] = k2;
      }
    }
  }
  return parent;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
function csFkeep(a2, callback, other) {
  var avalues = a2._values;
  var aindex = a2._index;
  var aptr = a2._ptr;
  var asize = a2._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0; j < n; j++) {
    var p = aptr[j];
    aptr[j] = nz;
    for (; p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
function csFlip(i) {
  return -i - 2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
var name229 = "csAmd";
var dependencies229 = ["add", "multiply", "transpose"];
var createCsAmd = /* @__PURE__ */ factory(name229, dependencies229, (_ref) => {
  var {
    add: add2,
    multiply,
    transpose
  } = _ref;
  return function csAmd(order, a2) {
    if (!a2 || order <= 0 || order > 3) {
      return null;
    }
    var asize = a2._size;
    var m = asize[0];
    var n = asize[1];
    var lemax = 0;
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    var cm = _createTargetMatrix(order, a2, m, n, dense);
    csFkeep(cm, _diag, null);
    var cindex = cm._index;
    var cptr = cm._ptr;
    var cnz = cptr[n];
    var P3 = [];
    var W = [];
    var len = 0;
    var nv = n + 1;
    var next = 2 * (n + 1);
    var head = 3 * (n + 1);
    var elen = 4 * (n + 1);
    var degree = 5 * (n + 1);
    var w = 6 * (n + 1);
    var hhead = 7 * (n + 1);
    var last = P3;
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
    var mindeg = 0;
    var i, j, k2, k1, k22, e3, pj, ln2, nvi, pk, eln, p1, p2, pn, h, d;
    while (nel < n) {
      for (k2 = -1; mindeg < n && (k2 = W[head + mindeg]) === -1; mindeg++)
        ;
      if (W[next + k2] !== -1) {
        last[W[next + k2]] = -1;
      }
      W[head + mindeg] = W[next + k2];
      var elenk = W[elen + k2];
      var nvk = W[nv + k2];
      nel += nvk;
      var dk = 0;
      W[nv + k2] = -nvk;
      var p = cptr[k2];
      var pk1 = elenk === 0 ? p : cnz;
      var pk2 = pk1;
      for (k1 = 1; k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          e3 = k2;
          pj = p;
          ln2 = W[len + k2] - elenk;
        } else {
          e3 = cindex[p++];
          pj = cptr[e3];
          ln2 = W[len + e3];
        }
        for (k22 = 1; k22 <= ln2; k22++) {
          i = cindex[pj++];
          if ((nvi = W[nv + i]) <= 0) {
            continue;
          }
          dk += nvi;
          W[nv + i] = -nvi;
          cindex[pk2++] = i;
          if (W[next + i] !== -1) {
            last[W[next + i]] = last[i];
          }
          if (last[i] !== -1) {
            W[next + last[i]] = W[next + i];
          } else {
            W[head + W[degree + i]] = W[next + i];
          }
        }
        if (e3 !== k2) {
          cptr[e3] = csFlip(k2);
          W[w + e3] = 0;
        }
      }
      if (elenk !== 0) {
        cnz = pk2;
      }
      W[degree + k2] = dk;
      cptr[k2] = pk1;
      W[len + k2] = pk2 - pk1;
      W[elen + k2] = -2;
      mark = _wclear(mark, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i = cindex[pk];
        if ((eln = W[elen + i]) <= 0) {
          continue;
        }
        nvi = -W[nv + i];
        var wnvi = mark - nvi;
        for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {
          e3 = cindex[p];
          if (W[w + e3] >= mark) {
            W[w + e3] -= nvi;
          } else if (W[w + e3] !== 0) {
            W[w + e3] = W[degree + e3] + wnvi;
          }
        }
      }
      for (pk = pk1; pk < pk2; pk++) {
        i = cindex[pk];
        p1 = cptr[i];
        p2 = p1 + W[elen + i] - 1;
        pn = p1;
        for (h = 0, d = 0, p = p1; p <= p2; p++) {
          e3 = cindex[p];
          if (W[w + e3] !== 0) {
            var dext = W[w + e3] - mark;
            if (dext > 0) {
              d += dext;
              cindex[pn++] = e3;
              h += e3;
            } else {
              cptr[e3] = csFlip(k2);
              W[w + e3] = 0;
            }
          }
        }
        W[elen + i] = pn - p1 + 1;
        var p3 = pn;
        var p4 = p1 + W[len + i];
        for (p = p2 + 1; p < p4; p++) {
          j = cindex[p];
          var nvj = W[nv + j];
          if (nvj <= 0) {
            continue;
          }
          d += nvj;
          cindex[pn++] = j;
          h += j;
        }
        if (d === 0) {
          cptr[i] = csFlip(k2);
          nvi = -W[nv + i];
          dk -= nvi;
          nvk += nvi;
          nel += nvi;
          W[nv + i] = 0;
          W[elen + i] = -1;
        } else {
          W[degree + i] = Math.min(W[degree + i], d);
          cindex[pn] = cindex[p3];
          cindex[p3] = cindex[p1];
          cindex[p1] = k2;
          W[len + i] = pn - p1 + 1;
          h = (h < 0 ? -h : h) % n;
          W[next + i] = W[hhead + h];
          W[hhead + h] = i;
          last[i] = h;
        }
      }
      W[degree + k2] = dk;
      lemax = Math.max(lemax, dk);
      mark = _wclear(mark + lemax, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i = cindex[pk];
        if (W[nv + i] >= 0) {
          continue;
        }
        h = last[i];
        i = W[hhead + h];
        W[hhead + h] = -1;
        for (; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
          ln2 = W[len + i];
          eln = W[elen + i];
          for (p = cptr[i] + 1; p <= cptr[i] + ln2 - 1; p++) {
            W[w + cindex[p]] = mark;
          }
          var jlast = i;
          for (j = W[next + i]; j !== -1; ) {
            var ok = W[len + j] === ln2 && W[elen + j] === eln;
            for (p = cptr[j] + 1; ok && p <= cptr[j] + ln2 - 1; p++) {
              if (W[w + cindex[p]] !== mark) {
                ok = 0;
              }
            }
            if (ok) {
              cptr[j] = csFlip(i);
              W[nv + i] += W[nv + j];
              W[nv + j] = 0;
              W[elen + j] = -1;
              j = W[next + j];
              W[next + jlast] = j;
            } else {
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      for (p = pk1, pk = pk1; pk < pk2; pk++) {
        i = cindex[pk];
        if ((nvi = -W[nv + i]) <= 0) {
          continue;
        }
        W[nv + i] = nvi;
        d = W[degree + i] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] !== -1) {
          last[W[head + d]] = i;
        }
        W[next + i] = W[head + d];
        last[i] = -1;
        W[head + d] = i;
        mindeg = Math.min(mindeg, d);
        W[degree + i] = d;
        cindex[p++] = i;
      }
      W[nv + k2] = nvk;
      if ((W[len + k2] = p - pk1) === 0) {
        cptr[k2] = -1;
        W[w + k2] = 0;
      }
      if (elenk !== 0) {
        cnz = p;
      }
    }
    for (i = 0; i < n; i++) {
      cptr[i] = csFlip(cptr[i]);
    }
    for (j = 0; j <= n; j++) {
      W[head + j] = -1;
    }
    for (j = n; j >= 0; j--) {
      if (W[nv + j] > 0) {
        continue;
      }
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    for (e3 = n; e3 >= 0; e3--) {
      if (W[nv + e3] <= 0) {
        continue;
      }
      if (cptr[e3] !== -1) {
        W[next + e3] = W[head + cptr[e3]];
        W[head + cptr[e3]] = e3;
      }
    }
    for (k2 = 0, i = 0; i <= n; i++) {
      if (cptr[i] === -1) {
        k2 = csTdfs(i, k2, W, head, next, P3, w);
      }
    }
    P3.splice(P3.length - 1, 1);
    return P3;
  };
  function _createTargetMatrix(order, a2, m, n, dense) {
    var at = transpose(a2);
    if (order === 1 && n === m) {
      return add2(a2, at);
    }
    if (order === 2) {
      var tindex = at._index;
      var tptr = at._ptr;
      var p2 = 0;
      for (var j = 0; j < m; j++) {
        var p = tptr[j];
        tptr[j] = p2;
        if (tptr[j + 1] - p > dense) {
          continue;
        }
        for (var p1 = tptr[j + 1]; p < p1; p++) {
          tindex[p2++] = tindex[p];
        }
      }
      tptr[m] = p2;
      a2 = transpose(at);
      return multiply(at, a2);
    }
    return multiply(at, a2);
  }
  function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
    for (var k2 = 0; k2 < n; k2++) {
      W[len + k2] = cptr[k2 + 1] - cptr[k2];
    }
    W[len + n] = 0;
    for (var i = 0; i <= n; i++) {
      W[head + i] = -1;
      last[i] = -1;
      W[next + i] = -1;
      W[hhead + i] = -1;
      W[nv + i] = 1;
      W[w + i] = 1;
      W[elen + i] = 0;
      W[degree + i] = W[len + i];
    }
    var mark = _wclear(0, 0, W, w, n);
    W[elen + n] = -2;
    cptr[n] = -1;
    W[w + n] = 0;
    return mark;
  }
  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
    var nel = 0;
    for (var i = 0; i < n; i++) {
      var d = W[degree + i];
      if (d === 0) {
        W[elen + i] = -2;
        nel++;
        cptr[i] = -1;
        W[w + i] = 0;
      } else if (d > dense) {
        W[nv + i] = 0;
        W[elen + i] = -1;
        nel++;
        cptr[i] = csFlip(n);
        W[nv + n]++;
      } else {
        var h = W[head + d];
        if (h !== -1) {
          last[h] = i;
        }
        W[next + i] = W[head + d];
        W[head + d] = i;
      }
    }
    return nel;
  }
  function _wclear(mark, lemax, W, w, n) {
    if (mark < 2 || mark + lemax < 0) {
      for (var k2 = 0; k2 < n; k2++) {
        if (W[w + k2] !== 0) {
          W[w + k2] = 1;
        }
      }
      mark = 2;
    }
    return mark;
  }
  function _diag(i, j) {
    return i !== j;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
  var s2, sparent;
  var jleaf = 0;
  var q;
  if (i <= j || w[first + j] <= w[maxfirst + i]) {
    return -1;
  }
  w[maxfirst + i] = w[first + j];
  var jprev = w[prevleaf + i];
  w[prevleaf + i] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i;
  } else {
    jleaf = 2;
    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q])
      ;
    for (s2 = jprev; s2 !== q; s2 = sparent) {
      sparent = w[ancestor + s2];
      w[ancestor + s2] = q;
    }
  }
  return {
    jleaf,
    q
  };
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
var name230 = "csCounts";
var dependencies230 = ["transpose"];
var createCsCounts = /* @__PURE__ */ factory(name230, dependencies230, (_ref) => {
  var {
    transpose
  } = _ref;
  return function(a2, parent, post, ata) {
    if (!a2 || !parent || !post) {
      return null;
    }
    var asize = a2._size;
    var m = asize[0];
    var n = asize[1];
    var i, j, k2, J, p, p0, p1;
    var s2 = 4 * n + (ata ? n + m + 1 : 0);
    var w = [];
    var ancestor = 0;
    var maxfirst = n;
    var prevleaf = 2 * n;
    var first = 3 * n;
    var head = 4 * n;
    var next = 5 * n + 1;
    for (k2 = 0; k2 < s2; k2++) {
      w[k2] = -1;
    }
    var colcount = [];
    var at = transpose(a2);
    var tindex = at._index;
    var tptr = at._ptr;
    for (k2 = 0; k2 < n; k2++) {
      j = post[k2];
      colcount[j] = w[first + j] === -1 ? 1 : 0;
      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
        w[first + j] = k2;
      }
    }
    if (ata) {
      for (k2 = 0; k2 < n; k2++) {
        w[post[k2]] = k2;
      }
      for (i = 0; i < m; i++) {
        for (k2 = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {
          k2 = Math.min(k2, w[tindex[p]]);
        }
        w[next + i] = w[head + k2];
        w[head + k2] = i;
      }
    }
    for (i = 0; i < n; i++) {
      w[ancestor + i] = i;
    }
    for (k2 = 0; k2 < n; k2++) {
      j = post[k2];
      if (parent[j] !== -1) {
        colcount[parent[j]]--;
      }
      for (J = ata ? w[head + k2] : j; J !== -1; J = ata ? w[next + J] : -1) {
        for (p = tptr[J]; p < tptr[J + 1]; p++) {
          i = tindex[p];
          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);
          if (r.jleaf >= 1) {
            colcount[j]++;
          }
          if (r.jleaf === 2) {
            colcount[r.q]--;
          }
        }
      }
      if (parent[j] !== -1) {
        w[ancestor + j] = parent[j];
      }
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        colcount[parent[j]] += colcount[j];
      }
    }
    return colcount;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
var name231 = "csSqr";
var dependencies231 = ["add", "multiply", "transpose"];
var createCsSqr = /* @__PURE__ */ factory(name231, dependencies231, (_ref) => {
  var {
    add: add2,
    multiply,
    transpose
  } = _ref;
  var csAmd = createCsAmd({
    add: add2,
    multiply,
    transpose
  });
  var csCounts = createCsCounts({
    transpose
  });
  return function csSqr(order, a2, qr) {
    var aptr = a2._ptr;
    var asize = a2._size;
    var n = asize[1];
    var k2;
    var s2 = {};
    s2.q = csAmd(order, a2);
    if (order && !s2.q) {
      return null;
    }
    if (qr) {
      var c2 = order ? csPermute(a2, null, s2.q, 0) : a2;
      s2.parent = csEtree(c2, 1);
      var post = csPost(s2.parent, n);
      s2.cp = csCounts(c2, s2.parent, post, 1);
      if (c2 && s2.parent && s2.cp && _vcount(c2, s2)) {
        for (s2.unz = 0, k2 = 0; k2 < n; k2++) {
          s2.unz += s2.cp[k2];
        }
      }
    } else {
      s2.unz = 4 * aptr[n] + n;
      s2.lnz = s2.unz;
    }
    return s2;
  };
  function _vcount(a2, s2) {
    var aptr = a2._ptr;
    var aindex = a2._index;
    var asize = a2._size;
    var m = asize[0];
    var n = asize[1];
    s2.pinv = [];
    s2.leftmost = [];
    var parent = s2.parent;
    var pinv = s2.pinv;
    var leftmost = s2.leftmost;
    var w = [];
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    var i, k2, p, p0, p1;
    for (k2 = 0; k2 < n; k2++) {
      w[head + k2] = -1;
      w[tail + k2] = -1;
      w[nque + k2] = 0;
    }
    for (i = 0; i < m; i++) {
      leftmost[i] = -1;
    }
    for (k2 = n - 1; k2 >= 0; k2--) {
      for (p0 = aptr[k2], p1 = aptr[k2 + 1], p = p0; p < p1; p++) {
        leftmost[aindex[p]] = k2;
      }
    }
    for (i = m - 1; i >= 0; i--) {
      pinv[i] = -1;
      k2 = leftmost[i];
      if (k2 === -1) {
        continue;
      }
      if (w[nque + k2]++ === 0) {
        w[tail + k2] = i;
      }
      w[next + i] = w[head + k2];
      w[head + k2] = i;
    }
    s2.lnz = 0;
    s2.m2 = m;
    for (k2 = 0; k2 < n; k2++) {
      i = w[head + k2];
      s2.lnz++;
      if (i < 0) {
        i = s2.m2++;
      }
      pinv[i] = k2;
      if (--nque[k2] <= 0) {
        continue;
      }
      s2.lnz += w[nque + k2];
      var pa = parent[k2];
      if (pa !== -1) {
        if (w[nque + pa] === 0) {
          w[tail + pa] = w[tail + k2];
        }
        w[next + w[tail + k2]] = w[head + pa];
        w[head + pa] = w[next + i];
        w[nque + pa] += w[nque + k2];
      }
    }
    for (i = 0; i < m; i++) {
      if (pinv[i] < 0) {
        pinv[i] = k2++;
      }
    }
    return true;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
function csMarked(w, j) {
  return w[j] < 0;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
function csUnflip(i) {
  return i < 0 ? csFlip(i) : i;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
function csDfs(j, g, top2, xi, pinv) {
  var index = g._index;
  var ptr = g._ptr;
  var size = g._size;
  var n = size[1];
  var i, p, p2;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv ? pinv[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
      i = index[p];
      if (csMarked(ptr, i)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top2] = j;
    }
  }
  return top2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
function csReach(g, b, k2, xi, pinv) {
  var gptr = g._ptr;
  var gsize = g._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p, p0, p1;
  var top2 = n;
  for (p0 = bptr[k2], p1 = bptr[k2 + 1], p = p0; p < p1; p++) {
    var i = bindex[p];
    if (!csMarked(gptr, i)) {
      top2 = csDfs(i, g, top2, xi, pinv);
    }
  }
  for (p = top2; p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
var name232 = "csSpsolve";
var dependencies232 = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = /* @__PURE__ */ factory(name232, dependencies232, (_ref) => {
  var {
    divideScalar,
    multiply,
    subtract
  } = _ref;
  return function csSpsolve(g, b, k2, xi, x2, pinv, lo) {
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    var n = gsize[1];
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var p, p0, p1, q;
    var top2 = csReach(g, b, k2, xi, pinv);
    for (p = top2; p < n; p++) {
      x2[xi[p]] = 0;
    }
    for (p0 = bptr[k2], p1 = bptr[k2 + 1], p = p0; p < p1; p++) {
      x2[bindex[p]] = bvalues[p];
    }
    for (var px = top2; px < n; px++) {
      var j = xi[px];
      var J = pinv ? pinv[j] : j;
      if (J < 0) {
        continue;
      }
      p0 = gptr[J];
      p1 = gptr[J + 1];
      x2[j] = divideScalar(x2[j], gvalues[lo ? p0 : p1 - 1]);
      p = lo ? p0 + 1 : p0;
      q = lo ? p1 : p1 - 1;
      for (; p < q; p++) {
        var i = gindex[p];
        x2[i] = subtract(x2[i], multiply(gvalues[p], x2[j]));
      }
    }
    return top2;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
var name233 = "csLu";
var dependencies233 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
var createCsLu = /* @__PURE__ */ factory(name233, dependencies233, (_ref) => {
  var {
    abs: abs3,
    divideScalar,
    multiply,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  } = _ref;
  var csSpsolve = createCsSpsolve({
    divideScalar,
    multiply,
    subtract
  });
  return function csLu(m, s2, tol) {
    if (!m) {
      return null;
    }
    var size = m._size;
    var n = size[1];
    var q;
    var lnz = 100;
    var unz = 100;
    if (s2) {
      q = s2.q;
      lnz = s2.lnz || lnz;
      unz = s2.unz || unz;
    }
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var L = new SparseMatrix({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var U = new SparseMatrix({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    var pinv = [];
    var i, p;
    var x2 = [];
    var xi = [];
    for (i = 0; i < n; i++) {
      x2[i] = 0;
      pinv[i] = -1;
      lptr[i + 1] = 0;
    }
    lnz = 0;
    unz = 0;
    for (var k2 = 0; k2 < n; k2++) {
      lptr[k2] = lnz;
      uptr[k2] = unz;
      var col = q ? q[k2] : k2;
      var top2 = csSpsolve(L, m, col, xi, x2, pinv, 1);
      var ipiv = -1;
      var a2 = -1;
      for (p = top2; p < n; p++) {
        i = xi[p];
        if (pinv[i] < 0) {
          var xabs = abs3(x2[i]);
          if (larger(xabs, a2)) {
            a2 = xabs;
            ipiv = i;
          }
        } else {
          uindex[unz] = pinv[i];
          uvalues[unz++] = x2[i];
        }
      }
      if (ipiv === -1 || a2 <= 0) {
        return null;
      }
      if (pinv[col] < 0 && largerEq(abs3(x2[col]), multiply(a2, tol))) {
        ipiv = col;
      }
      var pivot = x2[ipiv];
      uindex[unz] = k2;
      uvalues[unz++] = pivot;
      pinv[ipiv] = k2;
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      for (p = top2; p < n; p++) {
        i = xi[p];
        if (pinv[i] < 0) {
          lindex[lnz] = i;
          lvalues[lnz++] = divideScalar(x2[i], pivot);
        }
        x2[i] = 0;
      }
    }
    lptr[n] = lnz;
    uptr[n] = unz;
    for (p = 0; p < lnz; p++) {
      lindex[p] = pinv[lindex[p]];
    }
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);
    return {
      L,
      U,
      pinv
    };
  };
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
var name234 = "slu";
var dependencies234 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
var createSlu = /* @__PURE__ */ factory(name234, dependencies234, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    add: add2,
    multiply,
    transpose,
    divideScalar,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  } = _ref;
  var csSqr = createCsSqr({
    add: add2,
    multiply,
    transpose
  });
  var csLu = createCsLu({
    abs: abs3,
    divideScalar,
    multiply,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  });
  return typed3(name234, {
    "SparseMatrix, number, number": function SparseMatrixNumberNumber(a2, order, threshold2) {
      if (!isInteger(order) || order < 0 || order > 3) {
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      }
      if (threshold2 < 0 || threshold2 > 1) {
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      }
      var s2 = csSqr(order, a2, false);
      var f = csLu(a2, s2, threshold2);
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s2.q,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
        }
      };
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
function csIpvec(p, b) {
  var k2;
  var n = b.length;
  var x2 = [];
  if (p) {
    for (k2 = 0; k2 < n; k2++) {
      x2[p[k2]] = b[k2];
    }
  } else {
    for (k2 = 0; k2 < n; k2++) {
      x2[k2] = b[k2];
    }
  }
  return x2;
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
var name235 = "lusolve";
var dependencies235 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
var createLusolve = /* @__PURE__ */ factory(name235, dependencies235, (_ref) => {
  var {
    typed: typed3,
    matrix,
    lup,
    slu,
    usolve,
    lsolve,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name235, {
    "Array, Array | Matrix": function ArrayArrayMatrix(a2, b) {
      a2 = matrix(a2);
      var d = lup(a2);
      var x2 = _lusolve(d.L, d.U, d.p, null, b);
      return x2.valueOf();
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a2, b) {
      var d = lup(a2);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a2, b) {
      var d = lup(a2);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a2, b, order, threshold2) {
      var d = slu(a2, order, threshold2);
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },
    "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  function _toMatrix(a2) {
    if (isMatrix(a2)) {
      return a2;
    }
    if (isArray(a2)) {
      return matrix(a2);
    }
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function _lusolve(l, u, p, q, b) {
    l = _toMatrix(l);
    u = _toMatrix(u);
    if (p) {
      b = solveValidation(l, b, true);
      b._data = csIpvec(p, b._data);
    }
    var y2 = lsolve(l, b);
    var x2 = usolve(u, y2);
    if (q) {
      x2._data = csIpvec(q, x2._data);
    }
    return x2;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js
var name236 = "polynomialRoot";
var dependencies236 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
var createPolynomialRoot = /* @__PURE__ */ factory(name236, dependencies236, (_ref) => {
  var {
    typed: typed3,
    isZero,
    equalScalar,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    sqrt: sqrt5,
    unaryMinus,
    cbrt: cbrt4,
    typeOf: typeOf2,
    im,
    re: re2
  } = _ref;
  return typed3(name236, {
    "number|Complex, ...number|Complex": (constant, restCoeffs) => {
      var coeffs = [constant, ...restCoeffs];
      while (coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])) {
        coeffs.pop();
      }
      if (coeffs.length < 2) {
        throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
      }
      switch (coeffs.length) {
        case 2:
          return [unaryMinus(divide2(coeffs[0], coeffs[1]))];
        case 3: {
          var [c2, b, a2] = coeffs;
          var denom = multiply(2, a2);
          var d1 = multiply(b, b);
          var d2 = multiply(4, a2, c2);
          if (equalScalar(d1, d2))
            return [divide2(unaryMinus(b), denom)];
          var discriminant = sqrt5(subtract(d1, d2));
          return [divide2(subtract(discriminant, b), denom), divide2(subtract(unaryMinus(discriminant), b), denom)];
        }
        case 4: {
          var [d, _c, _b, _a] = coeffs;
          var _denom = unaryMinus(multiply(3, _a));
          var D0_1 = multiply(_b, _b);
          var D0_2 = multiply(3, _a, _c);
          var D1_1 = add2(multiply(2, _b, _b, _b), multiply(27, _a, _a, d));
          var D1_2 = multiply(9, _a, _b, _c);
          if (equalScalar(D0_1, D0_2) && equalScalar(D1_1, D1_2)) {
            return [divide2(_b, _denom)];
          }
          var Delta0 = subtract(D0_1, D0_2);
          var Delta1 = subtract(D1_1, D1_2);
          var discriminant1 = add2(multiply(18, _a, _b, _c, d), multiply(_b, _b, _c, _c));
          var discriminant2 = add2(multiply(4, _b, _b, _b, d), multiply(4, _a, _c, _c, _c), multiply(27, _a, _a, d, d));
          if (equalScalar(discriminant1, discriminant2)) {
            return [
              divide2(subtract(multiply(4, _a, _b, _c), add2(multiply(9, _a, _a, d), multiply(_b, _b, _b))), multiply(_a, Delta0)),
              // simple root
              divide2(subtract(multiply(9, _a, d), multiply(_b, _c)), multiply(2, Delta0))
              // double root
            ];
          }
          var Ccubed;
          if (equalScalar(D0_1, D0_2)) {
            Ccubed = Delta1;
          } else {
            Ccubed = divide2(add2(Delta1, sqrt5(subtract(multiply(Delta1, Delta1), multiply(4, Delta0, Delta0, Delta0)))), 2);
          }
          var allRoots = true;
          var rawRoots = cbrt4(Ccubed, allRoots).toArray().map((C2) => divide2(add2(_b, C2, divide2(Delta0, C2)), _denom));
          return rawRoots.map((r) => {
            if (typeOf2(r) === "Complex" && equalScalar(re2(r), re2(r) + im(r))) {
              return re2(r);
            }
            return r;
          });
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
      }
    }
  });
});

// node_modules/mathjs/lib/esm/expression/Help.js
var name237 = "Help";
var dependencies237 = ["parse"];
var createHelpClass = /* @__PURE__ */ factory(name237, dependencies237, (_ref) => {
  var {
    parse
  } = _ref;
  function Help(doc) {
    if (!(this instanceof Help)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (!doc)
      throw new Error('Argument "doc" missing');
    this.doc = doc;
  }
  Help.prototype.type = "Help";
  Help.prototype.isHelp = true;
  Help.prototype.toString = function() {
    var doc = this.doc || {};
    var desc = "\n";
    if (doc.name) {
      desc += "Name: " + doc.name + "\n\n";
    }
    if (doc.category) {
      desc += "Category: " + doc.category + "\n\n";
    }
    if (doc.description) {
      desc += "Description:\n    " + doc.description + "\n\n";
    }
    if (doc.syntax) {
      desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
    }
    if (doc.examples) {
      desc += "Examples:\n";
      var scope = {};
      for (var i = 0; i < doc.examples.length; i++) {
        var expr = doc.examples[i];
        desc += "    " + expr + "\n";
        var res = void 0;
        try {
          res = parse(expr).compile().evaluate(scope);
        } catch (e3) {
          res = e3;
        }
        if (res !== void 0 && !isHelp(res)) {
          desc += "        " + format3(res, {
            precision: 14
          }) + "\n";
        }
      }
      desc += "\n";
    }
    if (doc.mayThrow && doc.mayThrow.length) {
      desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
    }
    if (doc.seealso && doc.seealso.length) {
      desc += "See also: " + doc.seealso.join(", ") + "\n";
    }
    return desc;
  };
  Help.prototype.toJSON = function() {
    var obj = clone(this.doc);
    obj.mathjs = "Help";
    return obj;
  };
  Help.fromJSON = function(json) {
    var doc = {};
    Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
      doc[prop] = json[prop];
    });
    return new Help(doc);
  };
  Help.prototype.valueOf = Help.prototype.toString;
  return Help;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/chain/Chain.js
var name238 = "Chain";
var dependencies238 = ["?on", "math", "typed"];
var createChainClass = /* @__PURE__ */ factory(name238, dependencies238, (_ref) => {
  var {
    on,
    math,
    typed: typed3
  } = _ref;
  function Chain(value) {
    if (!(this instanceof Chain)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (isChain(value)) {
      this.value = value.value;
    } else {
      this.value = value;
    }
  }
  Chain.prototype.type = "Chain";
  Chain.prototype.isChain = true;
  Chain.prototype.done = function() {
    return this.value;
  };
  Chain.prototype.valueOf = function() {
    return this.value;
  };
  Chain.prototype.toString = function() {
    return format3(this.value);
  };
  Chain.prototype.toJSON = function() {
    return {
      mathjs: "Chain",
      value: this.value
    };
  };
  Chain.fromJSON = function(json) {
    return new Chain(json.value);
  };
  function createProxy(name310, fn) {
    if (typeof fn === "function") {
      Chain.prototype[name310] = chainify(fn);
    }
  }
  function createLazyProxy(name310, resolver) {
    lazy(Chain.prototype, name310, function outerResolver() {
      var fn = resolver();
      if (typeof fn === "function") {
        return chainify(fn);
      }
      return void 0;
    });
  }
  function chainify(fn) {
    return function() {
      if (arguments.length === 0) {
        return new Chain(fn(this.value));
      }
      var args = [this.value];
      for (var i = 0; i < arguments.length; i++) {
        args[i + 1] = arguments[i];
      }
      if (typed3.isTypedFunction(fn)) {
        var sigObject = typed3.resolve(fn, args);
        if (sigObject.params.length === 1) {
          throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
        }
        return new Chain(sigObject.implementation.apply(fn, args));
      }
      return new Chain(fn.apply(fn, args));
    };
  }
  Chain.createProxy = function(arg0, arg1) {
    if (typeof arg0 === "string") {
      createProxy(arg0, arg1);
    } else {
      var _loop = function _loop2(_name2) {
        if (hasOwnProperty(arg0, _name2) && excludedNames[_name2] === void 0) {
          createLazyProxy(_name2, () => arg0[_name2]);
        }
      };
      for (var _name in arg0) {
        _loop(_name);
      }
    }
  };
  var excludedNames = {
    expression: true,
    docs: true,
    type: true,
    classes: true,
    json: true,
    error: true,
    isChain: true
    // conflicts with the property isChain of a Chain instance
  };
  Chain.createProxy(math);
  if (on) {
    on("import", function(name310, resolver, path2) {
      if (!path2) {
        createLazyProxy(name310, resolver);
      }
    });
  }
  return Chain;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
var eDocs = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
var falseDocs = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
var iDocs = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
var InfinityDocs = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
var LN10Docs = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
var LN2Docs = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
var LOG10EDocs = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
var LOG2EDocs = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
var NaNDocs = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
var nullDocs = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
var phiDocs = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
var piDocs = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
var SQRT12Docs = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
var SQRT2Docs = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
var tauDocs = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
var trueDocs = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
var versionDocs = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
var bignumberDocs = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
  seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
var booleanDocs = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
  seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
var complexDocs = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
var createUnitDocs = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
  seealso: ["unit", "splitUnit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
var fractionDocs = {
  name: "fraction",
  category: "Construction",
  syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
var indexDocs = {
  name: "index",
  category: "Construction",
  syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
  description: "Create an index to get or replace a subset of a matrix",
  examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
  seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
var matrixDocs = {
  name: "matrix",
  category: "Construction",
  syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
  description: "Create a matrix.",
  examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
var numberDocs = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
  seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
var sparseDocs = {
  name: "sparse",
  category: "Construction",
  syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
  description: "Create a sparse matrix.",
  examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
var splitUnitDocs = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
var stringDocs = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
var unitDocs = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
var configDocs = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
var importDocs = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
var typedDocs = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
var derivativeDocs = {
  name: "derivative",
  category: "Algebra",
  syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
  seealso: ["simplify", "parse", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js
var leafCountDocs = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
  seealso: ["simplify"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
var lsolveDocs = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
var lsolveAllDocs = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
var lupDocs = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
var lusolveDocs = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/polynomialRoot.js
var polynomialRootDocs = {
  name: "polynomialRoot",
  category: "Algebra",
  syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
  description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
  examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
  seealso: ["cbrt", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
var qrDocs = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
var rationalizeDocs = {
  name: "rationalize",
  category: "Algebra",
  syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
  seealso: ["simplify"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js
var resolveDocs = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
var simplifyDocs = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
  seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyConstant.js
var simplifyConstantDocs = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
  seealso: ["simplify", "simplifyCore", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js
var simplifyCoreDocs = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
var sluDocs = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js
var symbolicEqualDocs = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
  seealso: ["simplify", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
var usolveDocs = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
var usolveAllDocs = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
var absDocs = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
var addDocs = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
  seealso: ["subtract"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
var cbrtDocs = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
  seealso: ["square", "sqrt", "cube", "multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
var ceilDocs = {
  name: "ceil",
  category: "Arithmetic",
  syntax: ["ceil(x)"],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
  seealso: ["floor", "fix", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
var cubeDocs = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
var divideDocs = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
  seealso: ["multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
var dotDivideDocs = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
var dotMultiplyDocs = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
var dotPowDocs = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
var expDocs = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
  seealso: ["expm", "expm1", "pow", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
var expmDocs = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
var expm1Docs = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
var fixDocs = {
  name: "fix",
  category: "Arithmetic",
  syntax: ["fix(x)"],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
  seealso: ["ceil", "floor", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
var floorDocs = {
  name: "floor",
  category: "Arithmetic",
  syntax: ["floor(x)"],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
  seealso: ["ceil", "fix", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
var gcdDocs = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
var hypotDocs = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenusa of a list with values. ",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js
var invmodDocs = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
  examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
  seealso: ["gcd", "xgcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
var lcmDocs = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
var logDocs = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
  seealso: ["exp", "log1p", "log2", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
var log10Docs = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
  seealso: ["exp", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
var log1pDocs = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
  seealso: ["exp", "log", "log2", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
var log2Docs = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
var modDocs = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
  seealso: ["divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
var multiplyDocs = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
  seealso: ["divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
var normDocs = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
var nthRootDocs = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
var nthRootsDocs = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
var powDocs = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
var roundDocs = {
  name: "round",
  category: "Arithmetic",
  syntax: ["round(x)", "round(x, n)"],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)"],
  seealso: ["ceil", "floor", "fix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
var signDocs = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
var sqrtDocs = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
var sqrtmDocs = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[33, 24], [48, 57]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/sylvester.js
var sylvesterDocs = {
  name: "sylvester",
  category: "Algebra",
  syntax: ["sylvester(A,B,C)"],
  description: "Solves the real-valued Sylvester equation AX+XB=C for X",
  examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
  seealso: ["schur", "lyap"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/schur.js
var schurDocs = {
  name: "schur",
  category: "Algebra",
  syntax: ["schur(A)"],
  description: "Performs a real Schur decomposition of the real matrix A = UTU'",
  examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
  seealso: ["lyap", "sylvester"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lyap.js
var lyapDocs = {
  name: "lyap",
  category: "Algebra",
  syntax: ["lyap(A,Q)"],
  description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
  examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
  seealso: ["schur", "sylvester"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
var squareDocs = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
var subtractDocs = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
var unaryMinusDocs = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
var unaryPlusDocs = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
var xgcdDocs = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
var bitAndDocs = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
var bitNotDocs = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
var bitOrDocs = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
var bitXorDocs = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
var leftShiftDocs = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
var rightArithShiftDocs = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
var rightLogShiftDocs = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
var bellNumbersDocs = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
var catalanDocs = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
var compositionDocs = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
var stirlingS2Docs = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
var argDocs = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
var conjDocs = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
var imDocs = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
var reDocs = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
var evaluateDocs = {
  name: "evaluate",
  category: "Expression",
  syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
  description: "Evaluate an expression or an array with expressions.",
  examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
var helpDocs = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
var distanceDocs = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
var intersectDocs = {
  name: "intersect",
  category: "Geometry",
  syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
  description: "Computes the intersection point of lines and/or planes.",
  examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
var andDocs = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
var notDocs = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
var orDocs = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
var xorDocs = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
var columnDocs = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
var concatDocs = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
  seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
var countDocs = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
  seealso: ["size"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
var crossDocs = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
  seealso: ["multiply", "dot"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
var ctransposeDocs = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
var detDocs = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
var diagDocs = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
  seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
var diffDocs = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
  examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
  seealso: ["subtract", "partitionSelect"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
var dotDocs = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
var eigsDocs = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and eigenvectors of a real symmetric matrix",
  examples: ["eigs([[5, 2.3], [2.3, 1]])"],
  seealso: ["inv"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
var filterDocs = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
  seealso: ["sort", "map", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
var flattenDocs = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
var forEachDocs = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
  seealso: ["map", "sort", "filter"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
var getMatrixDataTypeDocs = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
  examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
  seealso: ["matrix", "sparse", "typeOf"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
var identityDocs = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
  seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
var invDocs = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js
var pinvDocs = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the Moore\u2013Penrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
var kronDocs = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the kronecker product of 2 matrices or vectors.",
  examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
  seealso: ["multiply", "dot", "cross"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
var mapDocs = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
  examples: ["map([1, 2, 3], square)"],
  seealso: ["filter", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js
var matrixFromColumnsDocs = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js
var matrixFromFunctionDocs = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js
var matrixFromRowsDocs = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
var onesDocs = {
  name: "ones",
  category: "Matrix",
  syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
  description: "Create a matrix containing ones.",
  examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
var partitionSelectDocs = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
  seealso: ["sort"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
var rangeDocs = {
  name: "range",
  category: "Type",
  syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
var reshapeDocs = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
  seealso: ["size", "squeeze", "resize"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
var resizeDocs = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
  seealso: ["size", "subset", "squeeze", "reshape"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
var rotateDocs = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
  seealso: ["matrix", "rotationMatrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
var rotationMatrixDocs = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
  seealso: ["cos", "sin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
var rowDocs = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
var sizeDocs = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
  seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
var sortDocs = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
  seealso: ["map", "filter", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
var squeezeDocs = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
var subsetDocs = {
  name: "subset",
  category: "Matrix",
  syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
  description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
  examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
var traceDocs = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
var transposeDocs = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
var zerosDocs = {
  name: "zeros",
  category: "Matrix",
  syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
  description: "Create a matrix containing zeros.",
  examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js
var fftDocs = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js
var ifftDocs = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
var combinationsDocs = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
var combinationsWithRepDocs = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
var factorialDocs = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
var gammaDocs = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js
var lgammaDocs = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
  seealso: ["gamma"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
var kldivergenceDocs = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
var multinomialDocs = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
var permutationsDocs = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
var pickRandomDocs = {
  name: "pickRandom",
  category: "Probability",
  syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
  description: "Pick a random entry from a given array.",
  examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
  seealso: ["random", "randomInt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
var randomDocs = {
  name: "random",
  category: "Probability",
  syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
var randomIntDocs = {
  name: "randomInt",
  category: "Probability",
  syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
var compareDocs = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
var compareNaturalDocs = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
var compareTextDocs = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
var deepEqualDocs = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
var equalDocs = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
  seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
var equalTextDocs = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
var largerDocs = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
  examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
var largerEqDocs = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
var smallerDocs = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
var smallerEqDocs = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
var unequalDocs = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
  seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
var setCartesianDocs = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
var setDifferenceDocs = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
var setDistinctDocs = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
var setIntersectDocs = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
var setIsSubsetDocs = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
var setMultiplicityDocs = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
  seealso: ["setDistinct", "setSize"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
var setPowersetDocs = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
var setSizeDocs = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
var setSymDifferenceDocs = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
var setUnionDocs = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/zpk2tf.js
var zpk2tfDocs = {
  name: "zpk2tf",
  category: "Signal",
  syntax: ["zpk2tf(z, p, k)"],
  description: "Compute the transfer function of a zero-pole-gain model.",
  examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/freqz.js
var freqzDocs = {
  name: "freqz",
  category: "Signal",
  syntax: ["freqz(b, a)", "freqz(b, a, w)"],
  description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
  examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
var erfDocs = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/zeta.js
var zetaDocs = {
  name: "zeta",
  category: "Special",
  syntax: ["zeta(s)"],
  description: "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
  examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
var madDocs = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
var maxDocs = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
  description: "Compute the maximum value of a list of values.",
  examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
var meanDocs = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
var medianDocs = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
var minDocs = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
  description: "Compute the minimum value of a list of values.",
  examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
var modeDocs = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
var prodDocs = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
var quantileSeqDocs = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
  description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
  examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
var stdDocs = {
  name: "std",
  category: "Statistics",
  syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js
var cumSumDocs = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
var sumDocs = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
var varianceDocs = {
  name: "variance",
  category: "Statistics",
  syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/corr.js
var corrDocs = {
  name: "corr",
  category: "Statistics",
  syntax: ["corr(A,B)"],
  description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
  examples: ["corr([2, 4, 6, 8],[1, 2, 3, 6])", "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
var acosDocs = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
var acoshDocs = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
var acotDocs = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
var acothDocs = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
var acscDocs = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
var acschDocs = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
var asecDocs = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
var asechDocs = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
var asinDocs = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
var asinhDocs = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
var atanDocs = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
var atan2Docs = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
  seealso: ["sin", "cos", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
var atanhDocs = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
var cosDocs = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["acos", "sin", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
var coshDocs = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
var cotDocs = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
var cothDocs = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
var cscDocs = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
var cschDocs = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
var secDocs = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
var sechDocs = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
var sinDocs = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["asin", "cos", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
var sinhDocs = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
var tanDocs = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
var tanhDocs = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
var toDocs = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
var binDocs = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
var cloneDocs = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
  examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
var formatDocs = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
var hasNumericValueDocs = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
  examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
var hexDocs = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
var isIntegerDocs = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
var isNaNDocs = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
var isNegativeDocs = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
var isNumericDocs = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
var isPositiveDocs = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
var isPrimeDocs = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
var isZeroDocs = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
var numericDocs = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
  examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
  seealso: ["number", "fraction", "bignumber", "string", "format"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
var octDocs = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js
var printDocs = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $1, $2, $3", [6, 9, 4])'],
  seealso: ["format"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
var typeOfDocs = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
  seealso: ["getMatrixDataType"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/numeric/solveODE.js
var solveODEDocs = {
  name: "solveODE",
  category: "Numeric",
  syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
  description: "Numerical Integration of Ordinary Differential Equations.",
  examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
  seealso: ["derivative", "simplifyCore"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
var embeddedDocs = {
  // construction functions
  bignumber: bignumberDocs,
  boolean: booleanDocs,
  complex: complexDocs,
  createUnit: createUnitDocs,
  fraction: fractionDocs,
  index: indexDocs,
  matrix: matrixDocs,
  number: numberDocs,
  sparse: sparseDocs,
  splitUnit: splitUnitDocs,
  string: stringDocs,
  unit: unitDocs,
  // constants
  e: eDocs,
  E: eDocs,
  false: falseDocs,
  i: iDocs,
  Infinity: InfinityDocs,
  LN2: LN2Docs,
  LN10: LN10Docs,
  LOG2E: LOG2EDocs,
  LOG10E: LOG10EDocs,
  NaN: NaNDocs,
  null: nullDocs,
  pi: piDocs,
  PI: piDocs,
  phi: phiDocs,
  SQRT1_2: SQRT12Docs,
  SQRT2: SQRT2Docs,
  tau: tauDocs,
  true: trueDocs,
  version: versionDocs,
  // physical constants
  // TODO: more detailed docs for physical constants
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb's constant",
    examples: ["coulomb"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: {
    description: "Borh magneton",
    examples: ["bohrMagneton"]
  },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  // josephson: {description: 'Josephson constant', examples: ['josephson']},
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: {
    description: "Von Klitzing constant",
    examples: ["klitzing"]
  },
  bohrRadius: {
    description: "Borh radius",
    examples: ["bohrRadius"]
  },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: {
    description: "Electron mass",
    examples: ["electronMass"]
  },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: {
    description: "Hartree energy",
    examples: ["hartreeEnergy"]
  },
  protonMass: {
    description: "Proton mass",
    examples: ["protonMass"]
  },
  deuteronMass: {
    description: "Deuteron Mass",
    examples: ["deuteronMass"]
  },
  neutronMass: {
    description: "Neutron mass",
    examples: ["neutronMass"]
  },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: {
    description: "Rydberg constant",
    examples: ["rydberg"]
  },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: {
    description: "Efimov factor",
    examples: ["efimovFactor"]
  },
  atomicMass: {
    description: "Atomic mass constant",
    examples: ["atomicMass"]
  },
  avogadro: {
    description: "Avogadro's number",
    examples: ["avogadro"]
  },
  boltzmann: {
    description: "Boltzmann constant",
    examples: ["boltzmann"]
  },
  faraday: {
    description: "Faraday constant",
    examples: ["faraday"]
  },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: {
    description: "Gas constant",
    examples: ["gasConstant"]
  },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
  molarMass: {
    description: "Molar mass constant",
    examples: ["molarMass"]
  },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: {
    description: "Planck length",
    examples: ["planckLength"]
  },
  planckMass: {
    description: "Planck mass",
    examples: ["planckMass"]
  },
  planckTime: {
    description: "Planck time",
    examples: ["planckTime"]
  },
  planckCharge: {
    description: "Planck charge",
    examples: ["planckCharge"]
  },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  // functions - algebra
  derivative: derivativeDocs,
  lsolve: lsolveDocs,
  lsolveAll: lsolveAllDocs,
  lup: lupDocs,
  lusolve: lusolveDocs,
  leafCount: leafCountDocs,
  polynomialRoot: polynomialRootDocs,
  resolve: resolveDocs,
  simplify: simplifyDocs,
  simplifyConstant: simplifyConstantDocs,
  simplifyCore: simplifyCoreDocs,
  symbolicEqual: symbolicEqualDocs,
  rationalize: rationalizeDocs,
  slu: sluDocs,
  usolve: usolveDocs,
  usolveAll: usolveAllDocs,
  qr: qrDocs,
  // functions - arithmetic
  abs: absDocs,
  add: addDocs,
  cbrt: cbrtDocs,
  ceil: ceilDocs,
  cube: cubeDocs,
  divide: divideDocs,
  dotDivide: dotDivideDocs,
  dotMultiply: dotMultiplyDocs,
  dotPow: dotPowDocs,
  exp: expDocs,
  expm: expmDocs,
  expm1: expm1Docs,
  fix: fixDocs,
  floor: floorDocs,
  gcd: gcdDocs,
  hypot: hypotDocs,
  lcm: lcmDocs,
  log: logDocs,
  log2: log2Docs,
  log1p: log1pDocs,
  log10: log10Docs,
  mod: modDocs,
  multiply: multiplyDocs,
  norm: normDocs,
  nthRoot: nthRootDocs,
  nthRoots: nthRootsDocs,
  pow: powDocs,
  round: roundDocs,
  sign: signDocs,
  sqrt: sqrtDocs,
  sqrtm: sqrtmDocs,
  square: squareDocs,
  subtract: subtractDocs,
  unaryMinus: unaryMinusDocs,
  unaryPlus: unaryPlusDocs,
  xgcd: xgcdDocs,
  invmod: invmodDocs,
  // functions - bitwise
  bitAnd: bitAndDocs,
  bitNot: bitNotDocs,
  bitOr: bitOrDocs,
  bitXor: bitXorDocs,
  leftShift: leftShiftDocs,
  rightArithShift: rightArithShiftDocs,
  rightLogShift: rightLogShiftDocs,
  // functions - combinatorics
  bellNumbers: bellNumbersDocs,
  catalan: catalanDocs,
  composition: compositionDocs,
  stirlingS2: stirlingS2Docs,
  // functions - core
  config: configDocs,
  import: importDocs,
  typed: typedDocs,
  // functions - complex
  arg: argDocs,
  conj: conjDocs,
  re: reDocs,
  im: imDocs,
  // functions - expression
  evaluate: evaluateDocs,
  help: helpDocs,
  // functions - geometry
  distance: distanceDocs,
  intersect: intersectDocs,
  // functions - logical
  and: andDocs,
  not: notDocs,
  or: orDocs,
  xor: xorDocs,
  // functions - matrix
  concat: concatDocs,
  count: countDocs,
  cross: crossDocs,
  column: columnDocs,
  ctranspose: ctransposeDocs,
  det: detDocs,
  diag: diagDocs,
  diff: diffDocs,
  dot: dotDocs,
  getMatrixDataType: getMatrixDataTypeDocs,
  identity: identityDocs,
  filter: filterDocs,
  flatten: flattenDocs,
  forEach: forEachDocs,
  inv: invDocs,
  pinv: pinvDocs,
  eigs: eigsDocs,
  kron: kronDocs,
  matrixFromFunction: matrixFromFunctionDocs,
  matrixFromRows: matrixFromRowsDocs,
  matrixFromColumns: matrixFromColumnsDocs,
  map: mapDocs,
  ones: onesDocs,
  partitionSelect: partitionSelectDocs,
  range: rangeDocs,
  resize: resizeDocs,
  reshape: reshapeDocs,
  rotate: rotateDocs,
  rotationMatrix: rotationMatrixDocs,
  row: rowDocs,
  size: sizeDocs,
  sort: sortDocs,
  squeeze: squeezeDocs,
  subset: subsetDocs,
  trace: traceDocs,
  transpose: transposeDocs,
  zeros: zerosDocs,
  fft: fftDocs,
  ifft: ifftDocs,
  sylvester: sylvesterDocs,
  schur: schurDocs,
  lyap: lyapDocs,
  // functions - numeric
  solveODE: solveODEDocs,
  // functions - probability
  combinations: combinationsDocs,
  combinationsWithRep: combinationsWithRepDocs,
  // distribution: distributionDocs,
  factorial: factorialDocs,
  gamma: gammaDocs,
  kldivergence: kldivergenceDocs,
  lgamma: lgammaDocs,
  multinomial: multinomialDocs,
  permutations: permutationsDocs,
  pickRandom: pickRandomDocs,
  random: randomDocs,
  randomInt: randomIntDocs,
  // functions - relational
  compare: compareDocs,
  compareNatural: compareNaturalDocs,
  compareText: compareTextDocs,
  deepEqual: deepEqualDocs,
  equal: equalDocs,
  equalText: equalTextDocs,
  larger: largerDocs,
  largerEq: largerEqDocs,
  smaller: smallerDocs,
  smallerEq: smallerEqDocs,
  unequal: unequalDocs,
  // functions - set
  setCartesian: setCartesianDocs,
  setDifference: setDifferenceDocs,
  setDistinct: setDistinctDocs,
  setIntersect: setIntersectDocs,
  setIsSubset: setIsSubsetDocs,
  setMultiplicity: setMultiplicityDocs,
  setPowerset: setPowersetDocs,
  setSize: setSizeDocs,
  setSymDifference: setSymDifferenceDocs,
  setUnion: setUnionDocs,
  // functions - signal
  zpk2tf: zpk2tfDocs,
  freqz: freqzDocs,
  // functions - special
  erf: erfDocs,
  zeta: zetaDocs,
  // functions - statistics
  cumsum: cumSumDocs,
  mad: madDocs,
  max: maxDocs,
  mean: meanDocs,
  median: medianDocs,
  min: minDocs,
  mode: modeDocs,
  prod: prodDocs,
  quantileSeq: quantileSeqDocs,
  std: stdDocs,
  sum: sumDocs,
  variance: varianceDocs,
  corr: corrDocs,
  // functions - trigonometry
  acos: acosDocs,
  acosh: acoshDocs,
  acot: acotDocs,
  acoth: acothDocs,
  acsc: acscDocs,
  acsch: acschDocs,
  asec: asecDocs,
  asech: asechDocs,
  asin: asinDocs,
  asinh: asinhDocs,
  atan: atanDocs,
  atanh: atanhDocs,
  atan2: atan2Docs,
  cos: cosDocs,
  cosh: coshDocs,
  cot: cotDocs,
  coth: cothDocs,
  csc: cscDocs,
  csch: cschDocs,
  sec: secDocs,
  sech: sechDocs,
  sin: sinDocs,
  sinh: sinhDocs,
  tan: tanDocs,
  tanh: tanhDocs,
  // functions - units
  to: toDocs,
  // functions - utils
  clone: cloneDocs,
  format: formatDocs,
  bin: binDocs,
  oct: octDocs,
  hex: hexDocs,
  isNaN: isNaNDocs,
  isInteger: isIntegerDocs,
  isNegative: isNegativeDocs,
  isNumeric: isNumericDocs,
  hasNumericValue: hasNumericValueDocs,
  isPositive: isPositiveDocs,
  isPrime: isPrimeDocs,
  isZero: isZeroDocs,
  print: printDocs,
  typeOf: typeOfDocs,
  numeric: numericDocs
};

// node_modules/mathjs/lib/esm/expression/function/help.js
var name239 = "help";
var dependencies239 = ["typed", "mathWithTransform", "Help"];
var createHelp = /* @__PURE__ */ factory(name239, dependencies239, (_ref) => {
  var {
    typed: typed3,
    mathWithTransform,
    Help
  } = _ref;
  return typed3(name239, {
    any: function any(search) {
      var prop;
      var searchName = search;
      if (typeof search !== "string") {
        for (prop in mathWithTransform) {
          if (hasOwnProperty(mathWithTransform, prop) && search === mathWithTransform[prop]) {
            searchName = prop;
            break;
          }
        }
      }
      var doc = getSafeProperty(embeddedDocs, searchName);
      if (!doc) {
        var searchText = typeof searchName === "function" ? searchName.name : searchName;
        throw new Error('No documentation found on "' + searchText + '"');
      }
      return new Help(doc);
    }
  });
});

// node_modules/mathjs/lib/esm/type/chain/function/chain.js
var name240 = "chain";
var dependencies240 = ["typed", "Chain"];
var createChain = /* @__PURE__ */ factory(name240, dependencies240, (_ref) => {
  var {
    typed: typed3,
    Chain
  } = _ref;
  return typed3(name240, {
    "": function _() {
      return new Chain();
    },
    any: function any(value) {
      return new Chain(value);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/det.js
var name241 = "det";
var dependencies241 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"];
var createDet = /* @__PURE__ */ factory(name241, dependencies241, (_ref) => {
  var {
    typed: typed3,
    matrix,
    subtractScalar,
    multiply,
    divideScalar,
    isZero,
    unaryMinus
  } = _ref;
  return typed3(name241, {
    any: function any(x2) {
      return clone(x2);
    },
    "Array | Matrix": function det(x2) {
      var size;
      if (isMatrix(x2)) {
        size = x2.size();
      } else if (Array.isArray(x2)) {
        x2 = matrix(x2);
        size = x2.size();
      } else {
        size = [];
      }
      switch (size.length) {
        case 0:
          return clone(x2);
        case 1:
          if (size[0] === 1) {
            return clone(x2.valueOf()[0]);
          }
          if (size[0] === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
          }
        case 2: {
          var rows = size[0];
          var cols = size[1];
          if (rows === cols) {
            return _det(x2.clone().valueOf(), rows, cols);
          }
          if (cols === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
      }
    }
  });
  function _det(matrix2, rows, cols) {
    if (rows === 1) {
      return clone(matrix2[0][0]);
    } else if (rows === 2) {
      return subtractScalar(multiply(matrix2[0][0], matrix2[1][1]), multiply(matrix2[1][0], matrix2[0][1]));
    } else {
      var negated = false;
      var rowIndices = new Array(rows).fill(0).map((_, i2) => i2);
      for (var k2 = 0; k2 < rows; k2++) {
        var k_ = rowIndices[k2];
        if (isZero(matrix2[k_][k2])) {
          var _k = void 0;
          for (_k = k2 + 1; _k < rows; _k++) {
            if (!isZero(matrix2[rowIndices[_k]][k2])) {
              k_ = rowIndices[_k];
              rowIndices[_k] = rowIndices[k2];
              rowIndices[k2] = k_;
              negated = !negated;
              break;
            }
          }
          if (_k === rows)
            return matrix2[k_][k2];
        }
        var piv = matrix2[k_][k2];
        var piv_ = k2 === 0 ? 1 : matrix2[rowIndices[k2 - 1]][k2 - 1];
        for (var i = k2 + 1; i < rows; i++) {
          var i_ = rowIndices[i];
          for (var j = k2 + 1; j < rows; j++) {
            matrix2[i_][j] = divideScalar(subtractScalar(multiply(matrix2[i_][j], piv), multiply(matrix2[i_][k2], matrix2[k_][j])), piv_);
          }
        }
      }
      var det = matrix2[rowIndices[rows - 1]][rows - 1];
      return negated ? unaryMinus(det) : det;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/inv.js
var name242 = "inv";
var dependencies242 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = /* @__PURE__ */ factory(name242, dependencies242, (_ref) => {
  var {
    typed: typed3,
    matrix,
    divideScalar,
    addScalar,
    multiply,
    unaryMinus,
    det,
    identity: identity5,
    abs: abs3
  } = _ref;
  return typed3(name242, {
    "Array | Matrix": function ArrayMatrix(x2) {
      var size = isMatrix(x2) ? x2.size() : arraySize(x2);
      switch (size.length) {
        case 1:
          if (size[0] === 1) {
            if (isMatrix(x2)) {
              return matrix([divideScalar(1, x2.valueOf()[0])]);
            } else {
              return [divideScalar(1, x2[0])];
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
          }
        case 2: {
          var rows = size[0];
          var cols = size[1];
          if (rows === cols) {
            if (isMatrix(x2)) {
              return matrix(_inv(x2.valueOf(), rows, cols), x2.storage());
            } else {
              return _inv(x2, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
      }
    },
    any: function any(x2) {
      return divideScalar(1, x2);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s2, f, value, temp;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar(1, value)]];
    } else if (rows === 2) {
      var d = det(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
    } else {
      var A2 = mat.concat();
      for (r = 0; r < rows; r++) {
        A2[r] = A2[r].concat();
      }
      var B2 = identity5(rows).valueOf();
      for (var c2 = 0; c2 < cols; c2++) {
        var ABig = abs3(A2[c2][c2]);
        var rBig = c2;
        r = c2 + 1;
        while (r < rows) {
          if (abs3(A2[r][c2]) > ABig) {
            ABig = abs3(A2[r][c2]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c2) {
          temp = A2[c2];
          A2[c2] = A2[r];
          A2[r] = temp;
          temp = B2[c2];
          B2[c2] = B2[r];
          B2[r] = temp;
        }
        var Ac = A2[c2];
        var Bc = B2[c2];
        for (r = 0; r < rows; r++) {
          var Ar = A2[r];
          var Br = B2[r];
          if (r !== c2) {
            if (Ar[c2] !== 0) {
              f = divideScalar(unaryMinus(Ar[c2]), Ac[c2]);
              for (s2 = c2; s2 < cols; s2++) {
                Ar[s2] = addScalar(Ar[s2], multiply(f, Ac[s2]));
              }
              for (s2 = 0; s2 < cols; s2++) {
                Br[s2] = addScalar(Br[s2], multiply(f, Bc[s2]));
              }
            }
          } else {
            f = Ac[c2];
            for (s2 = c2; s2 < cols; s2++) {
              Ar[s2] = divideScalar(Ar[s2], f);
            }
            for (s2 = 0; s2 < cols; s2++) {
              Br[s2] = divideScalar(Br[s2], f);
            }
          }
        }
      }
      return B2;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/pinv.js
var name243 = "pinv";
var dependencies243 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
var createPinv = /* @__PURE__ */ factory(name243, dependencies243, (_ref) => {
  var {
    typed: typed3,
    matrix,
    inv,
    deepEqual,
    equal,
    dotDivide,
    dot,
    ctranspose,
    divideScalar,
    multiply,
    add: add2,
    Complex: Complex3
  } = _ref;
  return typed3(name243, {
    "Array | Matrix": function ArrayMatrix(x2) {
      var size = isMatrix(x2) ? x2.size() : arraySize(x2);
      switch (size.length) {
        case 1:
          if (_isZeros(x2))
            return ctranspose(x2);
          if (size[0] === 1) {
            return inv(x2);
          } else {
            return dotDivide(ctranspose(x2), dot(x2, x2));
          }
        case 2: {
          if (_isZeros(x2))
            return ctranspose(x2);
          var rows = size[0];
          var cols = size[1];
          if (rows === cols) {
            try {
              return inv(x2);
            } catch (err) {
              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
              } else {
                throw err;
              }
            }
          }
          if (isMatrix(x2)) {
            return matrix(_pinv(x2.valueOf(), rows, cols), x2.storage());
          } else {
            return _pinv(x2, rows, cols);
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
      }
    },
    any: function any(x2) {
      if (equal(x2, 0))
        return clone(x2);
      return divideScalar(1, x2);
    }
  });
  function _pinv(mat, rows, cols) {
    var {
      C: C2,
      F
    } = _rankFact(mat, rows, cols);
    var Cpinv = multiply(inv(multiply(ctranspose(C2), C2)), ctranspose(C2));
    var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));
    return multiply(Fpinv, Cpinv);
  }
  function _rref(mat, rows, cols) {
    var M = clone(mat);
    var lead = 0;
    for (var r = 0; r < rows; r++) {
      if (cols <= lead) {
        return M;
      }
      var i = r;
      while (_isZero(M[i][lead])) {
        i++;
        if (rows === i) {
          i = r;
          lead++;
          if (cols === lead) {
            return M;
          }
        }
      }
      [M[i], M[r]] = [M[r], M[i]];
      var val = M[r][lead];
      for (var j = 0; j < cols; j++) {
        M[r][j] = dotDivide(M[r][j], val);
      }
      for (var _i = 0; _i < rows; _i++) {
        if (_i === r)
          continue;
        val = M[_i][lead];
        for (var _j = 0; _j < cols; _j++) {
          M[_i][_j] = add2(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));
        }
      }
      lead++;
    }
    return M;
  }
  function _rankFact(mat, rows, cols) {
    var rref = _rref(mat, rows, cols);
    var C2 = mat.map((_, i) => _.filter((_2, j) => j < rows && !_isZero(dot(rref[j], rref[j]))));
    var F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));
    return {
      C: C2,
      F
    };
  }
  function _isZero(x2) {
    return equal(add2(x2, Complex3(1, 1)), add2(0, Complex3(1, 1)));
  }
  function _isZeros(arr) {
    return deepEqual(add2(arr, Complex3(1, 1)), add2(multiply(arr, 0), Complex3(1, 1)));
  }
});

// node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
function createComplexEigs(_ref) {
  var {
    addScalar,
    subtract,
    flatten: flatten2,
    multiply,
    multiplyScalar,
    divideScalar,
    sqrt: sqrt5,
    abs: abs3,
    bignumber,
    diag,
    inv,
    qr,
    usolve,
    usolveAll,
    equal,
    complex,
    larger,
    smaller,
    matrixFromColumns,
    dot
  } = _ref;
  function complexEigs(arr, N, prec, type, findVectors) {
    if (findVectors === void 0) {
      findVectors = true;
    }
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values: values2,
      C: C2
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    var vectors;
    if (findVectors) {
      vectors = findEigenvectors(arr, N, C2, R, values2, prec, type);
      vectors = matrixFromColumns(...vectors);
    }
    return {
      values: values2,
      vectors
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber(0) : 0;
    var one2 = big ? bignumber(1) : cplx ? complex(1) : 1;
    var realone = big ? bignumber(1) : 1;
    var radix = big ? bignumber(10) : 2;
    var radixSq = multiplyScalar(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one2);
    }
    var last = false;
    while (!last) {
      last = true;
      for (var i = 0; i < N; i++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0; j < N; j++) {
          if (i === j)
            continue;
          var c2 = abs3(arr[i][j]);
          colNorm = addScalar(colNorm, c2);
          rowNorm = addScalar(rowNorm, c2);
        }
        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
          var f = realone;
          var _c = colNorm;
          var rowDivRadix = divideScalar(rowNorm, radix);
          var rowMulRadix = multiplyScalar(rowNorm, radix);
          while (smaller(_c, rowDivRadix)) {
            _c = multiplyScalar(_c, radixSq);
            f = multiplyScalar(f, radix);
          }
          while (larger(_c, rowMulRadix)) {
            _c = divideScalar(_c, radixSq);
            f = divideScalar(f, radix);
          }
          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));
          if (condition) {
            last = false;
            var g = divideScalar(1, f);
            for (var _j = 0; _j < N; _j++) {
              if (i === _j) {
                continue;
              }
              arr[i][_j] = multiplyScalar(arr[i][_j], f);
              arr[_j][i] = multiplyScalar(arr[_j][i], g);
            }
            if (findVectors) {
              Rdiag[i] = multiplyScalar(Rdiag[i], f);
            }
          }
        }
      }
    }
    return diag(Rdiag);
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero3 = big ? bignumber(0) : cplx ? complex(0) : 0;
    if (big) {
      prec = bignumber(prec);
    }
    for (var i = 0; i < N - 2; i++) {
      var maxIndex = 0;
      var max4 = zero3;
      for (var j = i + 1; j < N; j++) {
        var el = arr[j][i];
        if (smaller(abs3(max4), abs3(el))) {
          max4 = el;
          maxIndex = j;
        }
      }
      if (smaller(abs3(max4), prec)) {
        continue;
      }
      if (maxIndex !== i + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i + 1];
        arr[i + 1] = tmp1;
        for (var _j2 = 0; _j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i + 1];
          arr[_j2][i + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i + 1];
          R[i + 1] = tmp3;
        }
      }
      for (var _j3 = i + 2; _j3 < N; _j3++) {
        var n = divideScalar(arr[_j3][i], max4);
        if (n === 0) {
          continue;
        }
        for (var k2 = 0; k2 < N; k2++) {
          arr[_j3][k2] = subtract(arr[_j3][k2], multiplyScalar(n, arr[i + 1][k2]));
        }
        for (var _k = 0; _k < N; _k++) {
          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0; _k2 < N; _k2++) {
            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A2, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one2 = big ? bignumber(1) : cplx ? complex(1) : 1;
    if (big) {
      prec = bignumber(prec);
    }
    var arr = clone(A2);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag(Array(N).fill(one2)) : void 0;
    var Qpartial = findVectors ? diag(Array(n).fill(one2)) : void 0;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k2 = 0;
      for (var i = 0; i < n; i++) {
        arr[i][i] = subtract(arr[i][i], k2);
      }
      var {
        Q: Q2,
        R
      } = qr(arr);
      arr = multiply(R, Q2);
      for (var _i = 0; _i < n; _i++) {
        arr[_i][_i] = addScalar(arr[_i][_i], k2);
      }
      if (findVectors) {
        Qpartial = multiply(Qpartial, Q2);
      }
      if (n === 1 || smaller(abs3(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag(Array(n - 1).fill(one2));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0; _i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller(abs3(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag(Array(n - 2).fill(one2));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0; _i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a2, b) => +subtract(abs3(a2), abs3(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C2 = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : void 0;
    return {
      values: lambdas,
      C: C2
    };
  }
  function findEigenvectors(A2, N, C2, R, values2, prec, type) {
    var Cinv = inv(C2);
    var U = multiply(Cinv, A2, C2);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero3 = big ? bignumber(0) : cplx ? complex(0) : 0;
    var one2 = big ? bignumber(1) : cplx ? complex(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var \u03BB of values2) {
      var i = indexOf(uniqueValues, \u03BB, equal);
      if (i === -1) {
        uniqueValues.push(\u03BB);
        multiplicities.push(1);
      } else {
        multiplicities[i] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero3);
    var E2 = diag(Array(N).fill(one2));
    var failedLambdas = [];
    var _loop = function _loop2() {
      var \u03BB2 = uniqueValues[_i4];
      var S = subtract(U, multiply(\u03BB2, E2));
      var solutions = usolveAll(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i4]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec == null) {
          failedLambdas.push(\u03BB2);
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply(inv(R), C2);
      solutions = solutions.map((v) => multiply(correction, v));
      vectors.push(...solutions.map((v) => flatten2(v)));
    };
    for (var _i4 = 0; _i4 < len; _i4++) {
      _loop();
    }
    if (failedLambdas.length !== 0) {
      var err = new Error("Failed to find eigenvectors for the following eigenvalues: " + failedLambdas.join(", "));
      err.values = values2;
      err.vectors = vectors;
      throw err;
    }
    return vectors;
  }
  function eigenvalues2x2(a2, b, c2, d) {
    var trA = addScalar(a2, d);
    var detA = subtract(multiplyScalar(a2, d), multiplyScalar(b, c2));
    var x2 = multiplyScalar(trA, 0.5);
    var y2 = multiplyScalar(sqrt5(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
    return [addScalar(x2, y2), subtract(x2, y2)];
  }
  function jordanBase2x2(a2, b, c2, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero3 = big ? bignumber(0) : cplx ? complex(0) : 0;
    var one2 = big ? bignumber(1) : cplx ? complex(1) : 1;
    if (smaller(abs3(c2), prec)) {
      return [[one2, zero3], [zero3, one2]];
    }
    if (larger(abs3(subtract(l1, l2)), prec)) {
      return [[subtract(l1, d), subtract(l2, d)], [c2, c2]];
    }
    var na = subtract(a2, l1);
    var nb = subtract(b, l1);
    var nc = subtract(c2, l1);
    var nd = subtract(d, l1);
    if (smaller(abs3(nb), prec)) {
      return [[na, one2], [nc, zero3]];
    } else {
      return [[nb, zero3], [nd, one2]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i = 0; i < arr.length; i++) {
      arr[i].push(...Array(N - arr[i].length).fill(0));
    }
    for (var _i5 = arr.length; _i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i = 0; i < N; i++) {
      M[i] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub2 of arr) {
      var n = sub2.length;
      for (var _i6 = 0; _i6 < n; _i6++) {
        for (var j = 0; j < n; j++) {
          M[I + _i6][I + j] = sub2[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (var i = 0; i < arr.length; i++) {
      if (fn(arr[i], el)) {
        return i;
      }
    }
    return -1;
  }
  function inverseIterate(A2, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber(1e3) : 1e3;
    var b;
    var i = 0;
    while (true) {
      b = randomOrthogonalVector(N, orthog, type);
      b = usolve(A2, b);
      if (larger(norm(b), largeNum)) {
        break;
      }
      if (++i >= 5) {
        return null;
      }
    }
    i = 0;
    while (true) {
      var c2 = usolve(A2, b);
      if (smaller(norm(orthogonalComplement(b, [c2])), prec)) {
        break;
      }
      if (++i >= 10) {
        return null;
      }
      b = normalize2(c2);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber(n));
    }
    if (cplx) {
      v = v.map((n) => complex(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize2(v, type);
  }
  function orthogonalComplement(v, orthog) {
    for (var w of orthog) {
      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
    }
    return v;
  }
  function norm(v) {
    return abs3(sqrt5(dot(v, v)));
  }
  function normalize2(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one2 = big ? bignumber(1) : cplx ? complex(1) : 1;
    return multiply(divideScalar(one2, norm(v)), v);
  }
  return complexEigs;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js
function createRealSymmetric(_ref) {
  var {
    config: config4,
    addScalar,
    subtract,
    abs: abs3,
    atan: atan3,
    cos: cos3,
    sin: sin3,
    multiplyScalar,
    inv,
    bignumber,
    multiply,
    add: add2
  } = _ref;
  function main(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config4.epsilon;
    var type = arguments.length > 3 ? arguments[3] : void 0;
    if (type === "number") {
      return diag(arr, prec);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag(x2, precision) {
    var N = x2.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i = 0; i < N; i++) {
      Sij[i] = createArray(N, 0);
      Sij[i][i] = 1;
    }
    var Vab = getAij(x2);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x2[_i][_i], x2[j][j], x2[_i][j]);
      x2 = x1(x2, psi, _i, j);
      Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x2);
    }
    var Ei = createArray(N, 0);
    for (var _i2 = 0; _i2 < N; _i2++) {
      Ei[_i2] = x2[_i2][_i2];
    }
    return sorting(clone(Ei), clone(Sij));
  }
  function diagBig(x2, precision) {
    var N = x2.length;
    var e0 = abs3(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i = 0; i < N; i++) {
      Sij[i] = createArray(N, 0);
      Sij[i][i] = 1;
    }
    var Vab = getAijBig(x2);
    while (abs3(Vab[1]) >= abs3(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x2[_i3][_i3], x2[j][j], x2[_i3][j]);
      x2 = x1Big(x2, psi, _i3, j);
      Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x2);
    }
    var Ei = createArray(N, 0);
    for (var _i4 = 0; _i4 < N; _i4++) {
      Ei[_i4] = x2[_i4][_i4];
    }
    return sorting(clone(Ei), clone(Sij));
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config4.epsilon) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract(ajj, aii);
    if (abs3(denom) <= config4.epsilon) {
      return bignumber(-1).acos().div(4);
    } else {
      return multiplyScalar(0.5, atan3(multiply(2, aij, inv(denom))));
    }
  }
  function Sij1(Sij, theta, i, j) {
    var N = Sij.length;
    var c2 = Math.cos(theta);
    var s2 = Math.sin(theta);
    var Ski = createArray(N, 0);
    var Skj = createArray(N, 0);
    for (var k2 = 0; k2 < N; k2++) {
      Ski[k2] = c2 * Sij[k2][i] - s2 * Sij[k2][j];
      Skj[k2] = s2 * Sij[k2][i] + c2 * Sij[k2][j];
    }
    for (var _k = 0; _k < N; _k++) {
      Sij[_k][i] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i, j) {
    var N = Sij.length;
    var c2 = cos3(theta);
    var s2 = sin3(theta);
    var Ski = createArray(N, bignumber(0));
    var Skj = createArray(N, bignumber(0));
    for (var k2 = 0; k2 < N; k2++) {
      Ski[k2] = subtract(multiplyScalar(c2, Sij[k2][i]), multiplyScalar(s2, Sij[k2][j]));
      Skj[k2] = addScalar(multiplyScalar(s2, Sij[k2][i]), multiplyScalar(c2, Sij[k2][j]));
    }
    for (var _k2 = 0; _k2 < N; _k2++) {
      Sij[_k2][i] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i, j) {
    var N = Hij.length;
    var c2 = bignumber(cos3(theta));
    var s2 = bignumber(sin3(theta));
    var c22 = multiplyScalar(c2, c2);
    var s22 = multiplyScalar(s2, s2);
    var Aki = createArray(N, bignumber(0));
    var Akj = createArray(N, bignumber(0));
    var csHij = multiply(bignumber(2), c2, s2, Hij[i][j]);
    var Aii = addScalar(subtract(multiplyScalar(c22, Hij[i][i]), csHij), multiplyScalar(s22, Hij[j][j]));
    var Ajj = add2(multiplyScalar(s22, Hij[i][i]), csHij, multiplyScalar(c22, Hij[j][j]));
    for (var k2 = 0; k2 < N; k2++) {
      Aki[k2] = subtract(multiplyScalar(c2, Hij[i][k2]), multiplyScalar(s2, Hij[j][k2]));
      Akj[k2] = addScalar(multiplyScalar(s2, Hij[i][k2]), multiplyScalar(c2, Hij[j][k2]));
    }
    Hij[i][i] = Aii;
    Hij[j][j] = Ajj;
    Hij[i][j] = bignumber(0);
    Hij[j][i] = bignumber(0);
    for (var _k3 = 0; _k3 < N; _k3++) {
      if (_k3 !== i && _k3 !== j) {
        Hij[i][_k3] = Aki[_k3];
        Hij[_k3][i] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i, j) {
    var N = Hij.length;
    var c2 = Math.cos(theta);
    var s2 = Math.sin(theta);
    var c22 = c2 * c2;
    var s22 = s2 * s2;
    var Aki = createArray(N, 0);
    var Akj = createArray(N, 0);
    var Aii = c22 * Hij[i][i] - 2 * c2 * s2 * Hij[i][j] + s22 * Hij[j][j];
    var Ajj = s22 * Hij[i][i] + 2 * c2 * s2 * Hij[i][j] + c22 * Hij[j][j];
    for (var k2 = 0; k2 < N; k2++) {
      Aki[k2] = c2 * Hij[i][k2] - s2 * Hij[j][k2];
      Akj[k2] = s2 * Hij[i][k2] + c2 * Hij[j][k2];
    }
    Hij[i][i] = Aii;
    Hij[j][j] = Ajj;
    Hij[i][j] = 0;
    Hij[j][i] = 0;
    for (var _k4 = 0; _k4 < N; _k4++) {
      if (_k4 !== i && _k4 !== j) {
        Hij[i][_k4] = Aki[_k4];
        Hij[_k4][i] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i = 0; i < N; i++) {
      for (var j = i + 1; j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
          maxMij = Math.abs(Mij[i][j]);
          maxIJ = [i, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i = 0; i < N; i++) {
      for (var j = i + 1; j < N; j++) {
        if (abs3(maxMij) < abs3(Mij[i][j])) {
          maxMij = abs3(Mij[i][j]);
          maxIJ = [i, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E2, S) {
    var N = E2.length;
    var values2 = Array(N);
    var vectors = Array(N);
    for (var k2 = 0; k2 < N; k2++) {
      vectors[k2] = Array(N);
    }
    for (var i = 0; i < N; i++) {
      var minID = 0;
      var minE = E2[0];
      for (var j = 0; j < E2.length; j++) {
        if (abs3(E2[j]) < abs3(minE)) {
          minID = j;
          minE = E2[minID];
        }
      }
      values2[i] = E2.splice(minID, 1)[0];
      for (var _k5 = 0; _k5 < N; _k5++) {
        vectors[_k5][i] = S[_k5][minID];
        S[_k5].splice(minID, 1);
      }
    }
    return {
      values: values2,
      vectors
    };
  }
  function createArray(size, value) {
    var array2 = new Array(size);
    for (var i = 0; i < size; i++) {
      array2[i] = value;
    }
    return array2;
  }
  return main;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs.js
var name244 = "eigs";
var dependencies244 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
var createEigs = /* @__PURE__ */ factory(name244, dependencies244, (_ref) => {
  var {
    config: config4,
    typed: typed3,
    matrix,
    addScalar,
    subtract,
    equal,
    abs: abs3,
    atan: atan3,
    cos: cos3,
    sin: sin3,
    multiplyScalar,
    divideScalar,
    inv,
    bignumber,
    multiply,
    add: add2,
    larger,
    column,
    flatten: flatten2,
    number: number5,
    complex,
    sqrt: sqrt5,
    diag,
    qr,
    usolve,
    usolveAll,
    im,
    re: re2,
    smaller,
    matrixFromColumns,
    dot
  } = _ref;
  var doRealSymetric = createRealSymmetric({
    config: config4,
    addScalar,
    subtract,
    column,
    flatten: flatten2,
    equal,
    abs: abs3,
    atan: atan3,
    cos: cos3,
    sin: sin3,
    multiplyScalar,
    inv,
    bignumber,
    complex,
    multiply,
    add: add2
  });
  var doComplexEigs = createComplexEigs({
    config: config4,
    addScalar,
    subtract,
    multiply,
    multiplyScalar,
    flatten: flatten2,
    divideScalar,
    sqrt: sqrt5,
    abs: abs3,
    bignumber,
    diag,
    qr,
    inv,
    usolve,
    usolveAll,
    equal,
    complex,
    larger,
    smaller,
    matrixFromColumns,
    dot
  });
  return typed3("eigs", {
    Array: function Array2(x2) {
      var mat = matrix(x2);
      return computeValuesAndVectors(mat);
    },
    "Array, number|BigNumber": function ArrayNumberBigNumber(x2, prec) {
      var mat = matrix(x2);
      return computeValuesAndVectors(mat, prec);
    },
    Matrix: function Matrix2(mat) {
      var {
        values: values2,
        vectors
      } = computeValuesAndVectors(mat);
      return {
        values: matrix(values2),
        vectors: matrix(vectors)
      };
    },
    "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
      var {
        values: values2,
        vectors
      } = computeValuesAndVectors(mat, prec);
      return {
        values: matrix(values2),
        vectors: matrix(vectors)
      };
    }
  });
  function computeValuesAndVectors(mat, prec) {
    if (prec === void 0) {
      prec = config4.epsilon;
    }
    var size = mat.size();
    if (size.length !== 2 || size[0] !== size[1]) {
      throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
    }
    var arr = mat.toArray();
    var N = size[0];
    if (isReal(arr, N, prec)) {
      coerceReal(arr, N);
      if (isSymmetric(arr, N, prec)) {
        var _type = coerceTypes(mat, arr, N);
        return doRealSymetric(arr, N, prec, _type);
      }
    }
    var type = coerceTypes(mat, arr, N);
    return doComplexEigs(arr, N, prec, type);
  }
  function isSymmetric(arr, N, prec) {
    for (var i = 0; i < N; i++) {
      for (var j = i; j < N; j++) {
        if (larger(bignumber(abs3(subtract(arr[i][j], arr[j][i]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function isReal(arr, N, prec) {
    for (var i = 0; i < N; i++) {
      for (var j = 0; j < N; j++) {
        if (larger(bignumber(abs3(im(arr[i][j]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function coerceReal(arr, N) {
    for (var i = 0; i < N; i++) {
      for (var j = 0; j < N; j++) {
        arr[i][j] = re2(arr[i][j]);
      }
    }
  }
  function coerceTypes(mat, arr, N) {
    var type = mat.datatype();
    if (type === "number" || type === "BigNumber" || type === "Complex") {
      return type;
    }
    var hasNumber = false;
    var hasBig = false;
    var hasComplex = false;
    for (var i = 0; i < N; i++) {
      for (var j = 0; j < N; j++) {
        var el = arr[i][j];
        if (isNumber(el) || isFraction(el)) {
          hasNumber = true;
        } else if (isBigNumber(el)) {
          hasBig = true;
        } else if (isComplex(el)) {
          hasComplex = true;
        } else {
          throw TypeError("Unsupported type in Matrix: " + typeOf(el));
        }
      }
    }
    if (hasBig && hasComplex) {
      console.warn("Complex BigNumbers not supported, this operation will lose precission.");
    }
    if (hasComplex) {
      for (var _i = 0; _i < N; _i++) {
        for (var _j = 0; _j < N; _j++) {
          arr[_i][_j] = complex(arr[_i][_j]);
        }
      }
      return "Complex";
    }
    if (hasBig) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        for (var _j2 = 0; _j2 < N; _j2++) {
          arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
        }
      }
      return "BigNumber";
    }
    if (hasNumber) {
      for (var _i3 = 0; _i3 < N; _i3++) {
        for (var _j3 = 0; _j3 < N; _j3++) {
          arr[_i3][_j3] = number5(arr[_i3][_j3]);
        }
      }
      return "number";
    } else {
      throw TypeError("Matrix contains unsupported types only.");
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/expm.js
var name245 = "expm";
var dependencies245 = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = /* @__PURE__ */ factory(name245, dependencies245, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    add: add2,
    identity: identity5,
    inv,
    multiply
  } = _ref;
  return typed3(name245, {
    Matrix: function Matrix2(A2) {
      var size = A2.size();
      if (size.length !== 2 || size[0] !== size[1]) {
        throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
      }
      var n = size[0];
      var eps = 1e-15;
      var infNorm = infinityNorm(A2);
      var params = findParams(infNorm, eps);
      var q = params.q;
      var j = params.j;
      var Apos = multiply(A2, Math.pow(2, -j));
      var N = identity5(n);
      var D2 = identity5(n);
      var factor = 1;
      var AposToI = Apos;
      var alternate = -1;
      for (var i = 1; i <= q; i++) {
        if (i > 1) {
          AposToI = multiply(AposToI, Apos);
          alternate = -alternate;
        }
        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
        N = add2(N, multiply(factor, AposToI));
        D2 = add2(D2, multiply(factor * alternate, AposToI));
      }
      var R = multiply(inv(D2), N);
      for (var _i = 0; _i < j; _i++) {
        R = multiply(R, R);
      }
      return isSparseMatrix(A2) ? A2.createSparseMatrix(R) : R;
    }
  });
  function infinityNorm(A2) {
    var n = A2.size()[0];
    var infNorm = 0;
    for (var i = 0; i < n; i++) {
      var rowSum = 0;
      for (var j = 0; j < n; j++) {
        rowSum += abs3(A2.get([i, j]));
      }
      infNorm = Math.max(rowSum, infNorm);
    }
    return infNorm;
  }
  function findParams(infNorm, eps) {
    var maxSearchSize = 30;
    for (var k2 = 0; k2 < maxSearchSize; k2++) {
      for (var q = 0; q <= k2; q++) {
        var j = k2 - q;
        if (errorEstimate(infNorm, q, j) < eps) {
          return {
            q,
            j
          };
        }
      }
    }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function errorEstimate(infNorm, q, j) {
    var qfac = 1;
    for (var i = 2; i <= q; i++) {
      qfac *= i;
    }
    var twoqfac = qfac;
    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
      twoqfac *= _i2;
    }
    var twoqp1fac = twoqfac * (2 * q + 1);
    return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
var name246 = "sqrtm";
var dependencies246 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
var createSqrtm = /* @__PURE__ */ factory(name246, dependencies246, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    add: add2,
    multiply,
    map: map3,
    sqrt: sqrt5,
    subtract,
    inv,
    size,
    max: max4,
    identity: identity5
  } = _ref;
  var _maxIterations = 1e3;
  var _tolerance = 1e-6;
  function _denmanBeavers(A2) {
    var error;
    var iterations = 0;
    var Y = A2;
    var Z = identity5(size(A2));
    do {
      var Yk = Y;
      Y = multiply(0.5, add2(Yk, inv(Z)));
      Z = multiply(0.5, add2(Z, inv(Yk)));
      error = max4(abs3(subtract(Y, Yk)));
      if (error > _tolerance && ++iterations > _maxIterations) {
        throw new Error("computing square root of matrix: iterative method could not converge");
      }
    } while (error > _tolerance);
    return Y;
  }
  return typed3(name246, {
    "Array | Matrix": function ArrayMatrix(A2) {
      var size2 = isMatrix(A2) ? A2.size() : arraySize(A2);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            return map3(A2, sqrt5);
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _denmanBeavers(A2);
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional (size: " + format3(size2) + ")");
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/sylvester.js
var name247 = "sylvester";
var dependencies247 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
var createSylvester = /* @__PURE__ */ factory(name247, dependencies247, (_ref) => {
  var {
    typed: typed3,
    schur,
    matrixFromColumns,
    matrix,
    multiply,
    range: range2,
    concat: concat2,
    transpose,
    index,
    subset,
    add: add2,
    subtract,
    identity: identity5,
    lusolve,
    abs: abs3
  } = _ref;
  return typed3(name247, {
    "Matrix, Matrix, Matrix": _sylvester,
    "Array, Matrix, Matrix": function ArrayMatrixMatrix(A2, B2, C2) {
      return _sylvester(matrix(A2), B2, C2);
    },
    "Array, Array, Matrix": function ArrayArrayMatrix(A2, B2, C2) {
      return _sylvester(matrix(A2), matrix(B2), C2);
    },
    "Array, Matrix, Array": function ArrayMatrixArray(A2, B2, C2) {
      return _sylvester(matrix(A2), B2, matrix(C2));
    },
    "Matrix, Array, Matrix": function MatrixArrayMatrix(A2, B2, C2) {
      return _sylvester(A2, matrix(B2), C2);
    },
    "Matrix, Array, Array": function MatrixArrayArray(A2, B2, C2) {
      return _sylvester(A2, matrix(B2), matrix(C2));
    },
    "Matrix, Matrix, Array": function MatrixMatrixArray(A2, B2, C2) {
      return _sylvester(A2, B2, matrix(C2));
    },
    "Array, Array, Array": function ArrayArrayArray(A2, B2, C2) {
      return _sylvester(matrix(A2), matrix(B2), matrix(C2)).toArray();
    }
  });
  function _sylvester(A2, B2, C2) {
    var n = B2.size()[0];
    var m = A2.size()[0];
    var sA = schur(A2);
    var F = sA.T;
    var U = sA.U;
    var sB = schur(multiply(-1, B2));
    var G = sB.T;
    var V = sB.U;
    var D2 = multiply(multiply(transpose(U), C2), V);
    var all2 = range2(0, m);
    var y2 = [];
    var hc = (a2, b) => concat2(a2, b, 1);
    var vc = (a2, b) => concat2(a2, b, 0);
    for (var k2 = 0; k2 < n; k2++) {
      if (k2 < n - 1 && abs3(subset(G, index(k2 + 1, k2))) > 1e-5) {
        var RHS = vc(subset(D2, index(all2, k2)), subset(D2, index(all2, k2 + 1)));
        for (var j = 0; j < k2; j++) {
          RHS = add2(RHS, vc(multiply(y2[j], subset(G, index(j, k2))), multiply(y2[j], subset(G, index(j, k2 + 1)))));
        }
        var gkk = multiply(identity5(m), multiply(-1, subset(G, index(k2, k2))));
        var gmk = multiply(identity5(m), multiply(-1, subset(G, index(k2 + 1, k2))));
        var gkm = multiply(identity5(m), multiply(-1, subset(G, index(k2, k2 + 1))));
        var gmm = multiply(identity5(m), multiply(-1, subset(G, index(k2 + 1, k2 + 1))));
        var LHS = vc(hc(add2(F, gkk), gmk), hc(gkm, add2(F, gmm)));
        var yAux = lusolve(LHS, RHS);
        y2[k2] = yAux.subset(index(range2(0, m), 0));
        y2[k2 + 1] = yAux.subset(index(range2(m, 2 * m), 0));
        k2++;
      } else {
        var _RHS = subset(D2, index(all2, k2));
        for (var _j = 0; _j < k2; _j++) {
          _RHS = add2(_RHS, multiply(y2[_j], subset(G, index(_j, k2))));
        }
        var _gkk = subset(G, index(k2, k2));
        var _LHS = subtract(F, multiply(_gkk, identity5(m)));
        y2[k2] = lusolve(_LHS, _RHS);
      }
    }
    var Y = matrix(matrixFromColumns(...y2));
    var X = multiply(U, multiply(Y, transpose(V)));
    return X;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js
var name248 = "schur";
var dependencies248 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
var createSchur = /* @__PURE__ */ factory(name248, dependencies248, (_ref) => {
  var {
    typed: typed3,
    matrix,
    identity: identity5,
    multiply,
    qr,
    norm,
    subtract
  } = _ref;
  return typed3(name248, {
    Array: function Array2(X) {
      var r = _schur(matrix(X));
      return {
        U: r.U.valueOf(),
        T: r.T.valueOf()
      };
    },
    Matrix: function Matrix2(X) {
      return _schur(X);
    }
  });
  function _schur(X) {
    var n = X.size()[0];
    var A2 = X;
    var U = identity5(n);
    var k2 = 0;
    var A0;
    do {
      A0 = A2;
      var QR = qr(A2);
      var Q2 = QR.Q;
      var R = QR.R;
      A2 = multiply(R, Q2);
      U = multiply(U, Q2);
      if (k2++ > 100) {
        break;
      }
    } while (norm(subtract(A2, A0)) > 1e-4);
    return {
      U,
      T: A2
    };
  }
});

// node_modules/mathjs/lib/esm/function/algebra/lyap.js
var name249 = "lyap";
var dependencies249 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
var createLyap = /* @__PURE__ */ factory(name249, dependencies249, (_ref) => {
  var {
    typed: typed3,
    matrix,
    sylvester,
    multiply,
    transpose
  } = _ref;
  return typed3(name249, {
    "Matrix, Matrix": function MatrixMatrix(A2, Q2) {
      return sylvester(A2, transpose(A2), multiply(-1, Q2));
    },
    "Array, Matrix": function ArrayMatrix(A2, Q2) {
      return sylvester(matrix(A2), transpose(matrix(A2)), multiply(-1, Q2));
    },
    "Matrix, Array": function MatrixArray(A2, Q2) {
      return sylvester(A2, transpose(matrix(A2)), matrix(multiply(-1, Q2)));
    },
    "Array, Array": function ArrayArray(A2, Q2) {
      return sylvester(matrix(A2), transpose(matrix(A2)), matrix(multiply(-1, Q2))).toArray();
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/divide.js
var name250 = "divide";
var dependencies250 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
var createDivide = /* @__PURE__ */ factory(name250, dependencies250, (_ref) => {
  var {
    typed: typed3,
    matrix,
    multiply,
    equalScalar,
    divideScalar,
    inv
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  return typed3("divide", extend({
    // we extend the signatures of divideScalar with signatures dealing with matrices
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x2, y2) {
      return multiply(x2, inv(y2));
    },
    "DenseMatrix, any": function DenseMatrixAny(x2, y2) {
      return matAlgo14xDs(x2, y2, divideScalar, false);
    },
    "SparseMatrix, any": function SparseMatrixAny(x2, y2) {
      return matAlgo11xS0s(x2, y2, divideScalar, false);
    },
    "Array, any": function ArrayAny(x2, y2) {
      return matAlgo14xDs(matrix(x2), y2, divideScalar, false).valueOf();
    },
    "any, Array | Matrix": function anyArrayMatrix(x2, y2) {
      return multiply(x2, inv(y2));
    }
  }, divideScalar.signatures));
});

// node_modules/mathjs/lib/esm/function/geometry/distance.js
var name251 = "distance";
var dependencies251 = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"];
var createDistance = /* @__PURE__ */ factory(name251, dependencies251, (_ref) => {
  var {
    typed: typed3,
    addScalar,
    subtractScalar,
    multiplyScalar,
    divideScalar,
    deepEqual,
    sqrt: sqrt5,
    abs: abs3
  } = _ref;
  return typed3(name251, {
    "Array, Array, Array": function ArrayArrayArray(x2, y2, z) {
      if (x2.length === 2 && y2.length === 2 && z.length === 2) {
        if (!_2d(x2)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(y2)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        if (deepEqual(y2, z)) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        var xCoeff = subtractScalar(z[1], y2[1]);
        var yCoeff = subtractScalar(y2[0], z[0]);
        var constant = subtractScalar(multiplyScalar(z[0], y2[1]), multiplyScalar(y2[0], z[1]));
        return _distancePointLine2D(x2[0], x2[1], xCoeff, yCoeff, constant);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object, Object": function ObjectObjectObject(x2, y2, z) {
      if (Object.keys(x2).length === 2 && Object.keys(y2).length === 2 && Object.keys(z).length === 2) {
        if (!_2d(x2)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_2d(y2)) {
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        }
        if (!_2d(z)) {
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        }
        if (deepEqual(_objectToArray(y2), _objectToArray(z))) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        if ("pointX" in x2 && "pointY" in x2 && "lineOnePtX" in y2 && "lineOnePtY" in y2 && "lineTwoPtX" in z && "lineTwoPtY" in z) {
          var xCoeff = subtractScalar(z.lineTwoPtY, y2.lineOnePtY);
          var yCoeff = subtractScalar(y2.lineOnePtX, z.lineTwoPtX);
          var constant = subtractScalar(multiplyScalar(z.lineTwoPtX, y2.lineOnePtY), multiplyScalar(y2.lineOnePtX, z.lineTwoPtY));
          return _distancePointLine2D(x2.pointX, x2.pointY, xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Array, Array": function ArrayArray(x2, y2) {
      if (x2.length === 2 && y2.length === 3) {
        if (!_2d(x2)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y2)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine2D(x2[0], x2[1], y2[0], y2[1], y2[2]);
      } else if (x2.length === 3 && y2.length === 6) {
        if (!_3d(x2)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_parametricLine(y2)) {
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine3D(x2[0], x2[1], x2[2], y2[0], y2[1], y2[2], y2[3], y2[4], y2[5]);
      } else if (x2.length === y2.length && x2.length > 0) {
        if (!_containsOnlyNumbers(x2)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        if (!_containsOnlyNumbers(y2)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        return _euclideanDistance(x2, y2);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object": function ObjectObject(x2, y2) {
      if (Object.keys(x2).length === 2 && Object.keys(y2).length === 3) {
        if (!_2d(x2)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_3d(y2)) {
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        }
        if ("pointX" in x2 && "pointY" in x2 && "xCoeffLine" in y2 && "yCoeffLine" in y2 && "constant" in y2) {
          return _distancePointLine2D(x2.pointX, x2.pointY, y2.xCoeffLine, y2.yCoeffLine, y2.constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x2).length === 3 && Object.keys(y2).length === 6) {
        if (!_3d(x2)) {
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        }
        if (!_parametricLine(y2)) {
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        }
        if ("pointX" in x2 && "pointY" in x2 && "x0" in y2 && "y0" in y2 && "z0" in y2 && "a" in y2 && "b" in y2 && "c" in y2) {
          return _distancePointLine3D(x2.pointX, x2.pointY, x2.pointZ, y2.x0, y2.y0, y2.z0, y2.a, y2.b, y2.c);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x2).length === 2 && Object.keys(y2).length === 2) {
        if (!_2d(x2)) {
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        }
        if (!_2d(y2)) {
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        }
        if ("pointOneX" in x2 && "pointOneY" in x2 && "pointTwoX" in y2 && "pointTwoY" in y2) {
          return _euclideanDistance([x2.pointOneX, x2.pointOneY], [y2.pointTwoX, y2.pointTwoY]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x2).length === 3 && Object.keys(y2).length === 3) {
        if (!_3d(x2)) {
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        }
        if (!_3d(y2)) {
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        }
        if ("pointOneX" in x2 && "pointOneY" in x2 && "pointOneZ" in x2 && "pointTwoX" in y2 && "pointTwoY" in y2 && "pointTwoZ" in y2) {
          return _euclideanDistance([x2.pointOneX, x2.pointOneY, x2.pointOneZ], [y2.pointTwoX, y2.pointTwoY, y2.pointTwoZ]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    Array: function Array2(arr) {
      if (!_pairwise(arr)) {
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      }
      return _distancePairwise(arr);
    }
  });
  function _isNumber(a2) {
    return typeof a2 === "number" || isBigNumber(a2);
  }
  function _2d(a2) {
    if (a2.constructor !== Array) {
      a2 = _objectToArray(a2);
    }
    return _isNumber(a2[0]) && _isNumber(a2[1]);
  }
  function _3d(a2) {
    if (a2.constructor !== Array) {
      a2 = _objectToArray(a2);
    }
    return _isNumber(a2[0]) && _isNumber(a2[1]) && _isNumber(a2[2]);
  }
  function _containsOnlyNumbers(a2) {
    if (!Array.isArray(a2)) {
      a2 = _objectToArray(a2);
    }
    return a2.every(_isNumber);
  }
  function _parametricLine(a2) {
    if (a2.constructor !== Array) {
      a2 = _objectToArray(a2);
    }
    return _isNumber(a2[0]) && _isNumber(a2[1]) && _isNumber(a2[2]) && _isNumber(a2[3]) && _isNumber(a2[4]) && _isNumber(a2[5]);
  }
  function _objectToArray(o) {
    var keys = Object.keys(o);
    var a2 = [];
    for (var i = 0; i < keys.length; i++) {
      a2.push(o[keys[i]]);
    }
    return a2;
  }
  function _pairwise(a2) {
    if (a2[0].length === 2 && _isNumber(a2[0][0]) && _isNumber(a2[0][1])) {
      if (a2.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
        return false;
      }
    } else if (a2[0].length === 3 && _isNumber(a2[0][0]) && _isNumber(a2[0][1]) && _isNumber(a2[0][2])) {
      if (a2.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  function _distancePointLine2D(x2, y2, a2, b, c2) {
    var num = abs3(addScalar(addScalar(multiplyScalar(a2, x2), multiplyScalar(b, y2)), c2));
    var den = sqrt5(addScalar(multiplyScalar(a2, a2), multiplyScalar(b, b)));
    return divideScalar(num, den);
  }
  function _distancePointLine3D(x2, y2, z, x0, y0, z0, a2, b, c2) {
    var num = [subtractScalar(multiplyScalar(subtractScalar(y0, y2), c2), multiplyScalar(subtractScalar(z0, z), b)), subtractScalar(multiplyScalar(subtractScalar(z0, z), a2), multiplyScalar(subtractScalar(x0, x2), c2)), subtractScalar(multiplyScalar(subtractScalar(x0, x2), b), multiplyScalar(subtractScalar(y0, y2), a2))];
    num = sqrt5(addScalar(addScalar(multiplyScalar(num[0], num[0]), multiplyScalar(num[1], num[1])), multiplyScalar(num[2], num[2])));
    var den = sqrt5(addScalar(addScalar(multiplyScalar(a2, a2), multiplyScalar(b, b)), multiplyScalar(c2, c2)));
    return divideScalar(num, den);
  }
  function _euclideanDistance(x2, y2) {
    var vectorSize = x2.length;
    var result = 0;
    var diff = 0;
    for (var i = 0; i < vectorSize; i++) {
      diff = subtractScalar(x2[i], y2[i]);
      result = addScalar(multiplyScalar(diff, diff), result);
    }
    return sqrt5(result);
  }
  function _distancePairwise(a2) {
    var result = [];
    var pointA = [];
    var pointB = [];
    for (var i = 0; i < a2.length - 1; i++) {
      for (var j = i + 1; j < a2.length; j++) {
        if (a2[0].length === 2) {
          pointA = [a2[i][0], a2[i][1]];
          pointB = [a2[j][0], a2[j][1]];
        } else if (a2[0].length === 3) {
          pointA = [a2[i][0], a2[i][1], a2[i][2]];
          pointB = [a2[j][0], a2[j][1], a2[j][2]];
        }
        result.push(_euclideanDistance(pointA, pointB));
      }
    }
    return result;
  }
});

// node_modules/mathjs/lib/esm/function/geometry/intersect.js
var name252 = "intersect";
var dependencies252 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
var createIntersect = /* @__PURE__ */ factory(name252, dependencies252, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    abs: abs3,
    add: add2,
    addScalar,
    matrix,
    multiply,
    multiplyScalar,
    divideScalar,
    subtract,
    smaller,
    equalScalar,
    flatten: flatten2,
    isZero,
    isNumeric
  } = _ref;
  return typed3("intersect", {
    "Array, Array, Array": _AAA,
    "Array, Array, Array, Array": _AAAA,
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x2, y2, plane) {
      var arr = _AAA(x2.valueOf(), y2.valueOf(), plane.valueOf());
      return arr === null ? null : matrix(arr);
    },
    "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x2, y2, z) {
      var arr = _AAAA(w.valueOf(), x2.valueOf(), y2.valueOf(), z.valueOf());
      return arr === null ? null : matrix(arr);
    }
  });
  function _AAA(x2, y2, plane) {
    x2 = _coerceArr(x2);
    y2 = _coerceArr(y2);
    plane = _coerceArr(plane);
    if (!_3d(x2)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    }
    if (!_3d(y2)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    }
    if (!_4d(plane)) {
      throw new TypeError("Array with 4 numbers expected as third argument");
    }
    return _intersectLinePlane(x2[0], x2[1], x2[2], y2[0], y2[1], y2[2], plane[0], plane[1], plane[2], plane[3]);
  }
  function _AAAA(w, x2, y2, z) {
    w = _coerceArr(w);
    x2 = _coerceArr(x2);
    y2 = _coerceArr(y2);
    z = _coerceArr(z);
    if (w.length === 2) {
      if (!_2d(w)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      }
      if (!_2d(x2)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      }
      if (!_2d(y2)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      }
      if (!_2d(z)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect2d(w, x2, y2, z);
    } else if (w.length === 3) {
      if (!_3d(w)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(x2)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_3d(y2)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      }
      if (!_3d(z)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect3d(w[0], w[1], w[2], x2[0], x2[1], x2[2], y2[0], y2[1], y2[2], z[0], z[1], z[2]);
    } else {
      throw new TypeError("Arrays with two or thee dimensional points expected");
    }
  }
  function _coerceArr(arr) {
    if (arr.length === 1)
      return arr[0];
    if (arr.length > 1 && Array.isArray(arr[0])) {
      if (arr.every((el) => Array.isArray(el) && el.length === 1))
        return flatten2(arr);
    }
    return arr;
  }
  function _2d(x2) {
    return x2.length === 2 && isNumeric(x2[0]) && isNumeric(x2[1]);
  }
  function _3d(x2) {
    return x2.length === 3 && isNumeric(x2[0]) && isNumeric(x2[1]) && isNumeric(x2[2]);
  }
  function _4d(x2) {
    return x2.length === 4 && isNumeric(x2[0]) && isNumeric(x2[1]) && isNumeric(x2[2]) && isNumeric(x2[3]);
  }
  function _intersect2d(p1a, p1b, p2a, p2b) {
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract(o1, p1b);
    var d2 = subtract(o2, p2b);
    var det = subtract(multiplyScalar(d1[0], d2[1]), multiplyScalar(d2[0], d1[1]));
    if (isZero(det))
      return null;
    if (smaller(abs3(det), config4.epsilon)) {
      return null;
    }
    var d20o11 = multiplyScalar(d2[0], o1[1]);
    var d21o10 = multiplyScalar(d2[1], o1[0]);
    var d20o21 = multiplyScalar(d2[0], o2[1]);
    var d21o20 = multiplyScalar(d2[1], o2[0]);
    var t = divideScalar(addScalar(subtract(subtract(d20o11, d21o10), d20o21), d21o20), det);
    return add2(multiply(d1, t), o1);
  }
  function _intersect3dHelper(a2, b, c2, d, e3, f, g, h, i, j, k2, l) {
    var add1 = multiplyScalar(subtract(a2, b), subtract(c2, d));
    var add22 = multiplyScalar(subtract(e3, f), subtract(g, h));
    var add3 = multiplyScalar(subtract(i, j), subtract(k2, l));
    return addScalar(addScalar(add1, add22), add3);
  }
  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
    var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
    var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
    var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
    var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
    var numerator = subtract(multiplyScalar(d1343, d4321), multiplyScalar(d1321, d4343));
    var denominator = subtract(multiplyScalar(d2121, d4343), multiplyScalar(d4321, d4321));
    if (isZero(denominator))
      return null;
    var ta = divideScalar(numerator, denominator);
    var tb = divideScalar(addScalar(d1343, multiplyScalar(ta, d4321)), d4343);
    var pax = addScalar(x1, multiplyScalar(ta, subtract(x2, x1)));
    var pay = addScalar(y1, multiplyScalar(ta, subtract(y2, y1)));
    var paz = addScalar(z1, multiplyScalar(ta, subtract(z2, z1)));
    var pbx = addScalar(x3, multiplyScalar(tb, subtract(x4, x3)));
    var pby = addScalar(y3, multiplyScalar(tb, subtract(y4, y3)));
    var pbz = addScalar(z3, multiplyScalar(tb, subtract(z4, z3)));
    if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
      return [pax, pay, paz];
    } else {
      return null;
    }
  }
  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x3, y3, z, c2) {
    var x1x = multiplyScalar(x1, x3);
    var x2x = multiplyScalar(x2, x3);
    var y1y = multiplyScalar(y1, y3);
    var y2y = multiplyScalar(y2, y3);
    var z1z = multiplyScalar(z1, z);
    var z2z = multiplyScalar(z2, z);
    var numerator = subtract(subtract(subtract(c2, x1x), y1y), z1z);
    var denominator = subtract(subtract(subtract(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y), z1z);
    var t = divideScalar(numerator, denominator);
    var px = addScalar(x1, multiplyScalar(t, subtract(x2, x1)));
    var py = addScalar(y1, multiplyScalar(t, subtract(y2, y1)));
    var pz = addScalar(z1, multiplyScalar(t, subtract(z2, z1)));
    return [px, py, pz];
  }
});

// node_modules/mathjs/lib/esm/function/statistics/sum.js
var name253 = "sum";
var dependencies253 = ["typed", "config", "add", "numeric"];
var createSum = /* @__PURE__ */ factory(name253, dependencies253, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    add: add2,
    numeric: numeric2
  } = _ref;
  return typed3(name253, {
    // sum([a, b, c, d, ...])
    "Array | Matrix": _sum,
    // sum([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": _nsumDim,
    // sum(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function sum");
      }
      return _sum(args);
    }
  });
  function _sum(array2) {
    var sum3;
    deepForEach(array2, function(value) {
      try {
        sum3 = sum3 === void 0 ? value : add2(sum3, value);
      } catch (err) {
        throw improveErrorMessage(err, "sum", value);
      }
    });
    if (sum3 === void 0) {
      sum3 = numeric2(0, config4.number);
    }
    if (typeof sum3 === "string") {
      sum3 = numeric2(sum3, config4.number);
    }
    return sum3;
  }
  function _nsumDim(array2, dim) {
    try {
      var sum3 = reduce(array2, dim, add2);
      return sum3;
    } catch (err) {
      throw improveErrorMessage(err, "sum");
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/cumsum.js
var name254 = "cumsum";
var dependencies254 = ["typed", "add", "unaryPlus"];
var createCumSum = /* @__PURE__ */ factory(name254, dependencies254, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    unaryPlus
  } = _ref;
  return typed3(name254, {
    // sum([a, b, c, d, ...])
    Array: _cumsum,
    Matrix: function Matrix2(matrix) {
      return matrix.create(_cumsum(matrix.valueOf()));
    },
    // sum([a, b, c, d, ...], dim)
    "Array, number | BigNumber": _ncumSumDim,
    "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix, dim) {
      return matrix.create(_ncumSumDim(matrix.valueOf(), dim));
    },
    // cumsum(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("All values expected to be scalar in function cumsum");
      }
      return _cumsum(args);
    }
  });
  function _cumsum(array2) {
    try {
      return _cumsummap(array2);
    } catch (err) {
      throw improveErrorMessage(err, name254);
    }
  }
  function _cumsummap(array2) {
    if (array2.length === 0) {
      return [];
    }
    var sums = [unaryPlus(array2[0])];
    for (var i = 1; i < array2.length; ++i) {
      sums.push(add2(sums[i - 1], array2[i]));
    }
    return sums;
  }
  function _ncumSumDim(array2, dim) {
    var size = arraySize(array2);
    if (dim < 0 || dim >= size.length) {
      throw new IndexError(dim, size.length);
    }
    try {
      return _cumsumDimensional(array2, dim);
    } catch (err) {
      throw improveErrorMessage(err, name254);
    }
  }
  function _cumsumDimensional(mat, dim) {
    var i, ret, tran;
    if (dim <= 0) {
      var initialValue = mat[0][0];
      if (!Array.isArray(initialValue)) {
        return _cumsummap(mat);
      } else {
        tran = _switch(mat);
        ret = [];
        for (i = 0; i < tran.length; i++) {
          ret[i] = _cumsumDimensional(tran[i], dim - 1);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i = 0; i < mat.length; i++) {
        ret[i] = _cumsumDimensional(mat[i], dim - 1);
      }
      return ret;
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/mean.js
var name255 = "mean";
var dependencies255 = ["typed", "add", "divide"];
var createMean = /* @__PURE__ */ factory(name255, dependencies255, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    divide: divide2
  } = _ref;
  return typed3(name255, {
    // mean([a, b, c, d, ...])
    "Array | Matrix": _mean,
    // mean([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": _nmeanDim,
    // mean(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function mean");
      }
      return _mean(args);
    }
  });
  function _nmeanDim(array2, dim) {
    try {
      var sum3 = reduce(array2, dim, add2);
      var s2 = Array.isArray(array2) ? arraySize(array2) : array2.size();
      return divide2(sum3, s2[dim]);
    } catch (err) {
      throw improveErrorMessage(err, "mean");
    }
  }
  function _mean(array2) {
    var sum3;
    var num = 0;
    deepForEach(array2, function(value) {
      try {
        sum3 = sum3 === void 0 ? value : add2(sum3, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "mean", value);
      }
    });
    if (num === 0) {
      throw new Error("Cannot calculate the mean of an empty array");
    }
    return divide2(sum3, num);
  }
});

// node_modules/mathjs/lib/esm/function/statistics/median.js
var name256 = "median";
var dependencies256 = ["typed", "add", "divide", "compare", "partitionSelect"];
var createMedian = /* @__PURE__ */ factory(name256, dependencies256, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    divide: divide2,
    compare,
    partitionSelect
  } = _ref;
  function _median(array2) {
    try {
      array2 = flatten(array2.valueOf());
      var num = array2.length;
      if (num === 0) {
        throw new Error("Cannot calculate median of an empty array");
      }
      if (num % 2 === 0) {
        var mid = num / 2 - 1;
        var right2 = partitionSelect(array2, mid + 1);
        var left2 = array2[mid];
        for (var i = 0; i < mid; ++i) {
          if (compare(array2[i], left2) > 0) {
            left2 = array2[i];
          }
        }
        return middle2(left2, right2);
      } else {
        var m = partitionSelect(array2, (num - 1) / 2);
        return middle(m);
      }
    } catch (err) {
      throw improveErrorMessage(err, "median");
    }
  }
  var middle = typed3({
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
      return value;
    }
  });
  var middle2 = typed3({
    "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left2, right2) {
      return divide2(add2(left2, right2), 2);
    }
  });
  return typed3(name256, {
    // median([a, b, c, d, ...])
    "Array | Matrix": _median,
    // median([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array2, dim) {
      throw new Error("median(A, dim) is not yet supported");
    },
    // median(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function median");
      }
      return _median(args);
    }
  });
});

// node_modules/mathjs/lib/esm/function/statistics/mad.js
var name257 = "mad";
var dependencies257 = ["typed", "abs", "map", "median", "subtract"];
var createMad = /* @__PURE__ */ factory(name257, dependencies257, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    map: map3,
    median,
    subtract
  } = _ref;
  return typed3(name257, {
    // mad([a, b, c, d, ...])
    "Array | Matrix": _mad,
    // mad(a, b, c, d, ...)
    "...": function _(args) {
      return _mad(args);
    }
  });
  function _mad(array2) {
    array2 = flatten(array2.valueOf());
    if (array2.length === 0) {
      throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
    }
    try {
      var med = median(array2);
      return median(map3(array2, function(value) {
        return abs3(subtract(value, med));
      }));
    } catch (err) {
      if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
        throw new TypeError(err.message.replace("median", "mad"));
      } else {
        throw improveErrorMessage(err, "mad");
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/variance.js
var DEFAULT_NORMALIZATION = "unbiased";
var name258 = "variance";
var dependencies258 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVariance = /* @__PURE__ */ factory(name258, dependencies258, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    apply,
    isNaN: isNaN2
  } = _ref;
  return typed3(name258, {
    // variance([a, b, c, d, ...])
    "Array | Matrix": function ArrayMatrix(array2) {
      return _var(array2, DEFAULT_NORMALIZATION);
    },
    // variance([a, b, c, d, ...], normalization)
    "Array | Matrix, string": _var,
    // variance([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array2, dim) {
      return _varDim(array2, dim, DEFAULT_NORMALIZATION);
    },
    // variance([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": _varDim,
    // variance(a, b, c, d, ...)
    "...": function _(args) {
      return _var(args, DEFAULT_NORMALIZATION);
    }
  });
  function _var(array2, normalization) {
    var sum3;
    var num = 0;
    if (array2.length === 0) {
      throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
    }
    deepForEach(array2, function(value) {
      try {
        sum3 = sum3 === void 0 ? value : add2(sum3, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "variance", value);
      }
    });
    if (num === 0)
      throw new Error("Cannot calculate variance of an empty array");
    var mean = divide2(sum3, num);
    sum3 = void 0;
    deepForEach(array2, function(value) {
      var diff = subtract(value, mean);
      sum3 = sum3 === void 0 ? multiply(diff, diff) : add2(sum3, multiply(diff, diff));
    });
    if (isNaN2(sum3)) {
      return sum3;
    }
    switch (normalization) {
      case "uncorrected":
        return divide2(sum3, num);
      case "biased":
        return divide2(sum3, num + 1);
      case "unbiased": {
        var zero3 = isBigNumber(sum3) ? sum3.mul(0) : 0;
        return num === 1 ? zero3 : divide2(sum3, num - 1);
      }
      default:
        throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
  function _varDim(array2, dim, normalization) {
    try {
      if (array2.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      return apply(array2, dim, (x2) => _var(x2, normalization));
    } catch (err) {
      throw improveErrorMessage(err, "variance");
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
var name259 = "quantileSeq";
var dependencies259 = ["typed", "?bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
var createQuantileSeq = /* @__PURE__ */ factory(name259, dependencies259, (_ref) => {
  var {
    typed: typed3,
    bignumber,
    add: add2,
    subtract,
    divide: divide2,
    multiply,
    partitionSelect,
    compare,
    isInteger: isInteger2,
    smaller,
    smallerEq,
    larger
  } = _ref;
  var apply = createApply({
    typed: typed3,
    isInteger: isInteger2
  });
  return typed3(name259, {
    "Array | Matrix, number | BigNumber": (data, p) => _quantileSeqProbNumber(data, p, false),
    "Array | Matrix, number | BigNumber, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),
    "Array | Matrix, number | BigNumber, boolean": _quantileSeqProbNumber,
    "Array | Matrix, number | BigNumber, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),
    "Array | Matrix, Array | Matrix": (data, p) => _quantileSeqProbCollection(data, p, false),
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),
    "Array | Matrix, Array | Matrix, boolean": _quantileSeqProbCollection,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)
  });
  function _quantileSeqDim(data, prob, sorted, dim, fn) {
    return apply(data, dim, (x2) => fn(x2, prob, sorted));
  }
  function _quantileSeqProbNumber(data, probOrN, sorted) {
    var probArr;
    var dataArr = data.valueOf();
    if (smaller(probOrN, 0)) {
      throw new Error("N/prob must be non-negative");
    }
    if (smallerEq(probOrN, 1)) {
      return isNumber(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber(_quantileSeq(dataArr, probOrN, sorted));
    }
    if (larger(probOrN, 1)) {
      if (!isInteger2(probOrN)) {
        throw new Error("N must be a positive integer");
      }
      if (larger(probOrN, 4294967295)) {
        throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
      }
      var nPlusOne = add2(probOrN, 1);
      probArr = [];
      for (var i = 0; smaller(i, probOrN); i++) {
        var prob = divide2(i + 1, nPlusOne);
        probArr.push(_quantileSeq(dataArr, prob, sorted));
      }
      return isNumber(probOrN) ? probArr : bignumber(probArr);
    }
  }
  function _quantileSeqProbCollection(data, probOrN, sorted) {
    var dataArr = data.valueOf();
    var probOrNArr = probOrN.valueOf();
    var probArr = [];
    for (var i = 0; i < probOrNArr.length; ++i) {
      probArr.push(_quantileSeq(dataArr, probOrNArr[i], sorted));
    }
    return probArr;
  }
  function _quantileSeq(array2, prob, sorted) {
    var flat = flatten(array2);
    var len = flat.length;
    if (len === 0) {
      throw new Error("Cannot calculate quantile of an empty sequence");
    }
    var index = isNumber(prob) ? prob * (len - 1) : prob.times(len - 1);
    var integerPart = isNumber(prob) ? Math.floor(index) : index.floor().toNumber();
    var fracPart = isNumber(prob) ? index % 1 : index.minus(integerPart);
    if (isInteger2(index)) {
      return sorted ? flat[index] : partitionSelect(flat, isNumber(prob) ? index : index.valueOf());
    }
    var left2;
    var right2;
    if (sorted) {
      left2 = flat[integerPart];
      right2 = flat[integerPart + 1];
    } else {
      right2 = partitionSelect(flat, integerPart + 1);
      left2 = flat[integerPart];
      for (var i = 0; i < integerPart; ++i) {
        if (compare(flat[i], left2) > 0) {
          left2 = flat[i];
        }
      }
    }
    return add2(multiply(left2, subtract(1, fracPart)), multiply(right2, fracPart));
  }
});

// node_modules/mathjs/lib/esm/function/statistics/std.js
var name260 = "std";
var dependencies260 = ["typed", "map", "sqrt", "variance"];
var createStd = /* @__PURE__ */ factory(name260, dependencies260, (_ref) => {
  var {
    typed: typed3,
    map: map3,
    sqrt: sqrt5,
    variance
  } = _ref;
  return typed3(name260, {
    // std([a, b, c, d, ...])
    "Array | Matrix": _std,
    // std([a, b, c, d, ...], normalization)
    "Array | Matrix, string": _std,
    // std([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": _std,
    // std([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": _std,
    // std(a, b, c, d, ...)
    "...": function _(args) {
      return _std(args);
    }
  });
  function _std(array2, normalization) {
    if (array2.length === 0) {
      throw new SyntaxError("Function std requires one or more parameters (0 provided)");
    }
    try {
      var v = variance.apply(null, arguments);
      if (isCollection(v)) {
        return map3(v, sqrt5);
      } else {
        return sqrt5(v);
      }
    } catch (err) {
      if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
        throw new TypeError(err.message.replace(" variance", " std"));
      } else {
        throw err;
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/corr.js
var name261 = "corr";
var dependencies261 = ["typed", "matrix", "mean", "sqrt", "sum", "add", "subtract", "multiply", "pow", "divide"];
var createCorr = /* @__PURE__ */ factory(name261, dependencies261, (_ref) => {
  var {
    typed: typed3,
    matrix,
    sqrt: sqrt5,
    sum: sum3,
    add: add2,
    subtract,
    multiply,
    pow: pow3,
    divide: divide2
  } = _ref;
  return typed3(name261, {
    "Array, Array": function ArrayArray(A2, B2) {
      return _corr(A2, B2);
    },
    "Matrix, Matrix": function MatrixMatrix(A2, B2) {
      var res = _corr(A2.toArray(), B2.toArray());
      return Array.isArray(res) ? matrix(res) : res;
    }
  });
  function _corr(A2, B2) {
    var correlations = [];
    if (Array.isArray(A2[0]) && Array.isArray(B2[0])) {
      if (A2.length !== B2.length) {
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");
      }
      for (var i = 0; i < A2.length; i++) {
        if (A2[i].length !== B2[i].length) {
          throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
        }
        correlations.push(correlation(A2[i], B2[i]));
      }
      return correlations;
    } else {
      if (A2.length !== B2.length) {
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
      }
      return correlation(A2, B2);
    }
  }
  function correlation(A2, B2) {
    var n = A2.length;
    var sumX = sum3(A2);
    var sumY = sum3(B2);
    var sumXY = A2.reduce((acc, x2, index) => add2(acc, multiply(x2, B2[index])), 0);
    var sumXSquare = sum3(A2.map((x2) => pow3(x2, 2)));
    var sumYSquare = sum3(B2.map((y2) => pow3(y2, 2)));
    var numerator = subtract(multiply(n, sumXY), multiply(sumX, sumY));
    var denominator = sqrt5(multiply(subtract(multiply(n, sumXSquare), pow3(sumX, 2)), subtract(multiply(n, sumYSquare), pow3(sumY, 2))));
    return divide2(numerator, denominator);
  }
});

// node_modules/mathjs/lib/esm/function/probability/combinations.js
var name262 = "combinations";
var dependencies262 = ["typed"];
var createCombinations = /* @__PURE__ */ factory(name262, dependencies262, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name262, {
    "number, number": combinationsNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k2) {
      var BigNumber2 = n.constructor;
      var result, i;
      var nMinusk = n.minus(k2);
      var one2 = new BigNumber2(1);
      if (!isPositiveInteger(n) || !isPositiveInteger(k2)) {
        throw new TypeError("Positive integer value expected in function combinations");
      }
      if (k2.gt(n)) {
        throw new TypeError("k must be less than n in function combinations");
      }
      result = one2;
      if (k2.lt(nMinusk)) {
        for (i = one2; i.lte(nMinusk); i = i.plus(one2)) {
          result = result.times(k2.plus(i)).dividedBy(i);
        }
      } else {
        for (i = one2; i.lte(k2); i = i.plus(one2)) {
          result = result.times(nMinusk.plus(i)).dividedBy(i);
        }
      }
      return result;
    }
    // TODO: implement support for collection in combinations
  });
});
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}

// node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
var name263 = "combinationsWithRep";
var dependencies263 = ["typed"];
var createCombinationsWithRep = /* @__PURE__ */ factory(name263, dependencies263, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name263, {
    "number, number": function numberNumber(n, k2) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (!isInteger(k2) || k2 < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n < 1) {
        throw new TypeError("k must be less than or equal to n + k - 1");
      }
      if (k2 < n - 1) {
        var _prodrange = product2(n, n + k2 - 1);
        return _prodrange / product2(1, k2);
      }
      var prodrange = product2(k2 + 1, n + k2 - 1);
      return prodrange / product2(1, n - 1);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k2) {
      var BigNumber2 = n.constructor;
      var result, i;
      var one2 = new BigNumber2(1);
      var nMinusOne = n.minus(one2);
      if (!isPositiveInteger2(n) || !isPositiveInteger2(k2)) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n.lt(one2)) {
        throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
      }
      result = one2;
      if (k2.lt(nMinusOne)) {
        for (i = one2; i.lte(nMinusOne); i = i.plus(one2)) {
          result = result.times(k2.plus(i)).dividedBy(i);
        }
      } else {
        for (i = one2; i.lte(k2); i = i.plus(one2)) {
          result = result.times(nMinusOne.plus(i)).dividedBy(i);
        }
      }
      return result;
    }
  });
});
function isPositiveInteger2(n) {
  return n.isInteger() && n.gte(0);
}

// node_modules/mathjs/lib/esm/function/probability/gamma.js
var name264 = "gamma";
var dependencies264 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
var createGamma = /* @__PURE__ */ factory(name264, dependencies264, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    multiplyScalar,
    pow: pow3,
    BigNumber: _BigNumber,
    Complex: Complex3
  } = _ref;
  function gammaComplex(n) {
    if (n.im === 0) {
      return gammaNumber(n.re);
    }
    if (n.re < 0.5) {
      var _t = new Complex3(1 - n.re, -n.im);
      var r = new Complex3(Math.PI * n.re, Math.PI * n.im);
      return new Complex3(Math.PI).div(r.sin()).div(gammaComplex(_t));
    }
    n = new Complex3(n.re - 1, n.im);
    var x2 = new Complex3(gammaP[0], 0);
    for (var i = 1; i < gammaP.length; ++i) {
      var gammaPval = new Complex3(gammaP[i], 0);
      x2 = x2.add(gammaPval.div(n.add(i)));
    }
    var t = new Complex3(n.re + gammaG + 0.5, n.im);
    var twoPiSqrt = Math.sqrt(2 * Math.PI);
    var tpow = t.pow(n.add(0.5));
    var expt = t.neg().exp();
    return x2.mul(twoPiSqrt).mul(tpow).mul(expt);
  }
  return typed3(name264, {
    number: gammaNumber,
    Complex: gammaComplex,
    BigNumber: function BigNumber2(n) {
      if (n.isInteger()) {
        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
      }
      if (!n.isFinite()) {
        return new _BigNumber(n.isNegative() ? NaN : Infinity);
      }
      throw new Error("Integer BigNumber expected");
    }
  });
  function bigFactorial(n) {
    if (n < 8) {
      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
    }
    var precision = config4.precision + (Math.log(n.toNumber()) | 0);
    var Big = _BigNumber.clone({
      precision
    });
    if (n % 2 === 1) {
      return n.times(bigFactorial(new _BigNumber(n - 1)));
    }
    var p = n;
    var prod = new Big(n);
    var sum3 = n.toNumber();
    while (p > 2) {
      p -= 2;
      sum3 += p;
      prod = prod.times(sum3);
    }
    return new _BigNumber(prod.toPrecision(_BigNumber.precision));
  }
});

// node_modules/mathjs/lib/esm/function/probability/lgamma.js
var name265 = "lgamma";
var dependencies265 = ["Complex", "typed"];
var createLgamma = /* @__PURE__ */ factory(name265, dependencies265, (_ref) => {
  var {
    Complex: Complex3,
    typed: typed3
  } = _ref;
  var SMALL_RE = 7;
  var SMALL_IM = 7;
  var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
  return typed3(name265, {
    number: lgammaNumber,
    Complex: lgammaComplex,
    BigNumber: function BigNumber2() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function lgammaComplex(n) {
    var TWOPI = 6.283185307179586;
    var LOGPI = 1.1447298858494002;
    var REFLECTION = 0.1;
    if (n.isNaN()) {
      return new Complex3(NaN, NaN);
    } else if (n.im === 0) {
      return new Complex3(lgammaNumber(n.re), 0);
    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
      return lgammaStirling(n);
    } else if (n.re <= REFLECTION) {
      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
      var a2 = n.mul(Math.PI).sin().log();
      var b = lgammaComplex(new Complex3(1 - n.re, -n.im));
      return new Complex3(LOGPI, tmp).sub(a2).sub(b);
    } else if (n.im >= 0) {
      return lgammaRecurrence(n);
    } else {
      return lgammaRecurrence(n.conjugate()).conjugate();
    }
  }
  function lgammaStirling(z) {
    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
    var rz = new Complex3(1, 0).div(z);
    var rzz = rz.div(z);
    var a2 = coeffs[0];
    var b = coeffs[1];
    var r = 2 * rzz.re;
    var s2 = rzz.re * rzz.re + rzz.im * rzz.im;
    for (var i = 2; i < 8; i++) {
      var tmp = b;
      b = -s2 * a2 + coeffs[i];
      a2 = r * a2 + tmp;
    }
    var rightPart = rz.mul(rzz.mul(a2).add(b));
    return leftPart.add(rightPart);
  }
  function lgammaRecurrence(z) {
    var signflips = 0;
    var sb = 0;
    var shiftprod = z;
    z = z.add(1);
    while (z.re <= SMALL_RE) {
      shiftprod = shiftprod.mul(z);
      var nsb = shiftprod.im < 0 ? 1 : 0;
      if (nsb !== 0 && sb === 0)
        signflips++;
      sb = nsb;
      z = z.add(1);
    }
    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex3(0, signflips * 2 * Math.PI * 1));
  }
});

// node_modules/mathjs/lib/esm/function/probability/factorial.js
var name266 = "factorial";
var dependencies266 = ["typed", "gamma"];
var createFactorial = /* @__PURE__ */ factory(name266, dependencies266, (_ref) => {
  var {
    typed: typed3,
    gamma: gamma2
  } = _ref;
  return typed3(name266, {
    number: function number5(n) {
      if (n < 0) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n + 1);
    },
    BigNumber: function BigNumber2(n) {
      if (n.isNegative()) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n.plus(1));
    },
    "Array | Matrix": typed3.referToSelf((self2) => (n) => deepMap(n, self2))
  });
});

// node_modules/mathjs/lib/esm/function/probability/kldivergence.js
var name267 = "kldivergence";
var dependencies267 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
var createKldivergence = /* @__PURE__ */ factory(name267, dependencies267, (_ref) => {
  var {
    typed: typed3,
    matrix,
    divide: divide2,
    sum: sum3,
    multiply,
    map: map3,
    dotDivide,
    log: log4,
    isNumeric
  } = _ref;
  return typed3(name267, {
    "Array, Array": function ArrayArray(q, p) {
      return _kldiv(matrix(q), matrix(p));
    },
    "Matrix, Array": function MatrixArray(q, p) {
      return _kldiv(q, matrix(p));
    },
    "Array, Matrix": function ArrayMatrix(q, p) {
      return _kldiv(matrix(q), p);
    },
    "Matrix, Matrix": function MatrixMatrix(q, p) {
      return _kldiv(q, p);
    }
  });
  function _kldiv(q, p) {
    var plength = p.size().length;
    var qlength = q.size().length;
    if (plength > 1) {
      throw new Error("first object must be one dimensional");
    }
    if (qlength > 1) {
      throw new Error("second object must be one dimensional");
    }
    if (plength !== qlength) {
      throw new Error("Length of two vectors must be equal");
    }
    var sumq = sum3(q);
    if (sumq === 0) {
      throw new Error("Sum of elements in first object must be non zero");
    }
    var sump = sum3(p);
    if (sump === 0) {
      throw new Error("Sum of elements in second object must be non zero");
    }
    var qnorm = divide2(q, sum3(q));
    var pnorm = divide2(p, sum3(p));
    var result = sum3(multiply(qnorm, map3(dotDivide(qnorm, pnorm), (x2) => log4(x2))));
    if (isNumeric(result)) {
      return result;
    } else {
      return Number.NaN;
    }
  }
});

// node_modules/mathjs/lib/esm/function/probability/multinomial.js
var name268 = "multinomial";
var dependencies268 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
var createMultinomial = /* @__PURE__ */ factory(name268, dependencies268, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    divide: divide2,
    multiply,
    factorial,
    isInteger: isInteger2,
    isPositive
  } = _ref;
  return typed3(name268, {
    "Array | Matrix": function ArrayMatrix(a2) {
      var sum3 = 0;
      var denom = 1;
      deepForEach(a2, function(ai) {
        if (!isInteger2(ai) || !isPositive(ai)) {
          throw new TypeError("Positive integer value expected in function multinomial");
        }
        sum3 = add2(sum3, ai);
        denom = multiply(denom, factorial(ai));
      });
      return divide2(factorial(sum3), denom);
    }
  });
});

// node_modules/mathjs/lib/esm/function/probability/permutations.js
var name269 = "permutations";
var dependencies269 = ["typed", "factorial"];
var createPermutations = /* @__PURE__ */ factory(name269, dependencies269, (_ref) => {
  var {
    typed: typed3,
    factorial
  } = _ref;
  return typed3(name269, {
    "number | BigNumber": factorial,
    "number, number": function numberNumber(n, k2) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (!isInteger(k2) || k2 < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k2 > n) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      return product2(n - k2 + 1, n);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k2) {
      var result, i;
      if (!isPositiveInteger3(n) || !isPositiveInteger3(k2)) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k2.gt(n)) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      var one2 = n.mul(0).add(1);
      result = one2;
      for (i = n.minus(k2).plus(1); i.lte(n); i = i.plus(1)) {
        result = result.times(i);
      }
      return result;
    }
    // TODO: implement support for collection in permutations
  });
});
function isPositiveInteger3(n) {
  return n.isInteger() && n.gte(0);
}

// node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
var import_seedrandom = __toESM(require_seedrandom2(), 1);
var singletonRandom = /* @__PURE__ */ (0, import_seedrandom.default)(Date.now());
function createRng(randomSeed) {
  var random2;
  function setSeed(seed) {
    random2 = seed === null ? singletonRandom : (0, import_seedrandom.default)(String(seed));
  }
  setSeed(randomSeed);
  function rng() {
    return random2();
  }
  return rng;
}

// node_modules/mathjs/lib/esm/function/probability/pickRandom.js
var name270 = "pickRandom";
var dependencies270 = ["typed", "config", "?on"];
var createPickRandom = /* @__PURE__ */ factory(name270, dependencies270, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    on
  } = _ref;
  var rng = createRng(config4.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed3(name270, {
    "Array | Matrix": function ArrayMatrix(possibles) {
      return _pickRandom(possibles, {});
    },
    "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
      return _pickRandom(possibles, options);
    },
    "Array | Matrix, number": function ArrayMatrixNumber(possibles, number5) {
      return _pickRandom(possibles, {
        number: number5
      });
    },
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
      return _pickRandom(possibles, {
        weights
      });
    },
    "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number5) {
      return _pickRandom(possibles, {
        number: number5,
        weights
      });
    },
    "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number5, weights) {
      return _pickRandom(possibles, {
        number: number5,
        weights
      });
    }
  });
  function _pickRandom(possibles, _ref2) {
    var {
      number: number5,
      weights,
      elementWise = true
    } = _ref2;
    var single = typeof number5 === "undefined";
    if (single) {
      number5 = 1;
    }
    var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
    possibles = possibles.valueOf();
    if (weights) {
      weights = weights.valueOf();
    }
    if (elementWise === true) {
      possibles = flatten(possibles);
      weights = flatten(weights);
    }
    var totalWeights = 0;
    if (typeof weights !== "undefined") {
      if (weights.length !== possibles.length) {
        throw new Error("Weights must have the same length as possibles");
      }
      for (var i = 0, len = weights.length; i < len; i++) {
        if (!isNumber(weights[i]) || weights[i] < 0) {
          throw new Error("Weights must be an array of positive numbers");
        }
        totalWeights += weights[i];
      }
    }
    var length = possibles.length;
    var result = [];
    var pick;
    while (result.length < number5) {
      if (typeof weights === "undefined") {
        pick = possibles[Math.floor(rng() * length)];
      } else {
        var randKey = rng() * totalWeights;
        for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
          randKey -= weights[_i];
          if (randKey < 0) {
            pick = possibles[_i];
            break;
          }
        }
      }
      result.push(pick);
    }
    return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
  }
});

// node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
function randomMatrix(size, random2) {
  var data = [];
  size = size.slice(0);
  if (size.length > 1) {
    for (var i = 0, length = size.shift(); i < length; i++) {
      data.push(randomMatrix(size, random2));
    }
  } else {
    for (var _i = 0, _length = size.shift(); _i < _length; _i++) {
      data.push(random2());
    }
  }
  return data;
}

// node_modules/mathjs/lib/esm/function/probability/random.js
var name271 = "random";
var dependencies271 = ["typed", "config", "?on"];
var createRandom = /* @__PURE__ */ factory(name271, dependencies271, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    on
  } = _ref;
  var rng = createRng(config4.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed3(name271, {
    "": () => _random(0, 1),
    number: (max4) => _random(0, max4),
    "number, number": (min4, max4) => _random(min4, max4),
    "Array | Matrix": (size) => _randomMatrix(size, 0, 1),
    "Array | Matrix, number": (size, max4) => _randomMatrix(size, 0, max4),
    "Array | Matrix, number, number": (size, min4, max4) => _randomMatrix(size, min4, max4)
  });
  function _randomMatrix(size, min4, max4) {
    var res = randomMatrix(size.valueOf(), () => _random(min4, max4));
    return isMatrix(size) ? size.create(res) : res;
  }
  function _random(min4, max4) {
    return min4 + rng() * (max4 - min4);
  }
});

// node_modules/mathjs/lib/esm/function/probability/randomInt.js
var name272 = "randomInt";
var dependencies272 = ["typed", "config", "?on"];
var createRandomInt = /* @__PURE__ */ factory(name272, dependencies272, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    on
  } = _ref;
  var rng = createRng(config4.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed3(name272, {
    "": () => _randomInt(0, 1),
    number: (max4) => _randomInt(0, max4),
    "number, number": (min4, max4) => _randomInt(min4, max4),
    "Array | Matrix": (size) => _randomIntMatrix(size, 0, 1),
    "Array | Matrix, number": (size, max4) => _randomIntMatrix(size, 0, max4),
    "Array | Matrix, number, number": (size, min4, max4) => _randomIntMatrix(size, min4, max4)
  });
  function _randomIntMatrix(size, min4, max4) {
    var res = randomMatrix(size.valueOf(), () => _randomInt(min4, max4));
    return isMatrix(size) ? size.create(res) : res;
  }
  function _randomInt(min4, max4) {
    return Math.floor(min4 + rng() * (max4 - min4));
  }
});

// node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
var name273 = "stirlingS2";
var dependencies273 = ["typed", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
var createStirlingS2 = /* @__PURE__ */ factory(name273, dependencies273, (_ref) => {
  var {
    typed: typed3,
    addScalar,
    subtractScalar,
    multiplyScalar,
    divideScalar,
    pow: pow3,
    factorial,
    combinations,
    isNegative,
    isInteger: isInteger2,
    number: number5,
    bignumber,
    larger
  } = _ref;
  var smallCache = [];
  var bigCache = [];
  return typed3(name273, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k2) {
      if (!isInteger2(n) || isNegative(n) || !isInteger2(k2) || isNegative(k2)) {
        throw new TypeError("Non-negative integer value expected in function stirlingS2");
      } else if (larger(k2, n)) {
        throw new TypeError("k must be less than or equal to n in function stirlingS2");
      }
      var big = !(isNumber(n) && isNumber(k2));
      var cache = big ? bigCache : smallCache;
      var make = big ? bignumber : number5;
      var nn = number5(n);
      var nk = number5(k2);
      if (cache[nn] && cache[nn].length > nk) {
        return cache[nn][nk];
      }
      for (var m = 0; m <= nn; ++m) {
        if (!cache[m]) {
          cache[m] = [m === 0 ? make(1) : make(0)];
        }
        if (m === 0)
          continue;
        var row = cache[m];
        var prev = cache[m - 1];
        for (var i = row.length; i <= m && i <= nk; ++i) {
          if (i === m) {
            row[i] = 1;
          } else {
            row[i] = addScalar(multiplyScalar(make(i), prev[i]), prev[i - 1]);
          }
        }
      }
      return cache[nn][nk];
    }
  });
});

// node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
var name274 = "bellNumbers";
var dependencies274 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
var createBellNumbers = /* @__PURE__ */ factory(name274, dependencies274, (_ref) => {
  var {
    typed: typed3,
    addScalar,
    isNegative,
    isInteger: isInteger2,
    stirlingS2
  } = _ref;
  return typed3(name274, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger2(n) || isNegative(n)) {
        throw new TypeError("Non-negative integer value expected in function bellNumbers");
      }
      var result = 0;
      for (var i = 0; i <= n; i++) {
        result = addScalar(result, stirlingS2(n, i));
      }
      return result;
    }
  });
});

// node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
var name275 = "catalan";
var dependencies275 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
var createCatalan = /* @__PURE__ */ factory(name275, dependencies275, (_ref) => {
  var {
    typed: typed3,
    addScalar,
    divideScalar,
    multiplyScalar,
    combinations,
    isNegative,
    isInteger: isInteger2
  } = _ref;
  return typed3(name275, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger2(n) || isNegative(n)) {
        throw new TypeError("Non-negative integer value expected in function catalan");
      }
      return divideScalar(combinations(multiplyScalar(n, 2), n), addScalar(n, 1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/combinatorics/composition.js
var name276 = "composition";
var dependencies276 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
var createComposition = /* @__PURE__ */ factory(name276, dependencies276, (_ref) => {
  var {
    typed: typed3,
    addScalar,
    combinations,
    isPositive,
    isNegative,
    isInteger: isInteger2,
    larger
  } = _ref;
  return typed3(name276, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k2) {
      if (!isInteger2(n) || !isPositive(n) || !isInteger2(k2) || !isPositive(k2)) {
        throw new TypeError("Positive integer value expected in function composition");
      } else if (larger(k2, n)) {
        throw new TypeError("k must be less than or equal to n in function composition");
      }
      return combinations(addScalar(n, -1), addScalar(k2, -1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/leafCount.js
var name277 = "leafCount";
var dependencies277 = ["parse", "typed"];
var createLeafCount = /* @__PURE__ */ factory(name277, dependencies277, (_ref) => {
  var {
    parse,
    typed: typed3
  } = _ref;
  function countLeaves(node) {
    var count = 0;
    node.forEach((n) => {
      count += countLeaves(n);
    });
    return count || 1;
  }
  return typed3(name277, {
    Node: function Node(expr) {
      return countLeaves(expr);
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js
function isNumericNode(x2) {
  return isConstantNode(x2) || isOperatorNode(x2) && x2.isUnary() && isConstantNode(x2.args[0]);
}
function isConstantExpression(x2) {
  if (isConstantNode(x2)) {
    return true;
  }
  if ((isFunctionNode(x2) || isOperatorNode(x2)) && x2.args.every(isConstantExpression)) {
    return true;
  }
  if (isParenthesisNode(x2) && isConstantExpression(x2.content)) {
    return true;
  }
  return false;
}

// node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
function ownKeys3(e3, r) {
  var t = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e3);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e3) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e3, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e3;
}
var name278 = "simplifyUtil";
var dependencies278 = ["FunctionNode", "OperatorNode", "SymbolNode"];
var createUtil = /* @__PURE__ */ factory(name278, dependencies278, (_ref) => {
  var {
    FunctionNode,
    OperatorNode,
    SymbolNode
  } = _ref;
  var T = true;
  var F = false;
  var defaultName = "defaultF";
  var defaultContext = {
    /*      */
    add: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /**/
    unaryPlus: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /* */
    subtract: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    /* */
    multiply: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /*   */
    divide: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    /*    */
    paren: {
      trivial: T,
      total: T,
      commutative: T,
      associative: F
    },
    /* */
    defaultF: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    }
  };
  var realContext = {
    divide: {
      total: F
    },
    log: {
      total: F
    }
  };
  var positiveContext = {
    subtract: {
      total: F
    },
    abs: {
      trivial: T
    },
    log: {
      total: T
    }
  };
  function hasProperty(nodeOrName, property) {
    var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
    var name310 = defaultName;
    if (typeof nodeOrName === "string") {
      name310 = nodeOrName;
    } else if (isOperatorNode(nodeOrName)) {
      name310 = nodeOrName.fn.toString();
    } else if (isFunctionNode(nodeOrName)) {
      name310 = nodeOrName.name;
    } else if (isParenthesisNode(nodeOrName)) {
      name310 = "paren";
    }
    if (hasOwnProperty(context, name310)) {
      var properties2 = context[name310];
      if (hasOwnProperty(properties2, property)) {
        return properties2[property];
      }
      if (hasOwnProperty(defaultContext, name310)) {
        return defaultContext[name310][property];
      }
    }
    if (hasOwnProperty(context, defaultName)) {
      var _properties = context[defaultName];
      if (hasOwnProperty(_properties, property)) {
        return _properties[property];
      }
      return defaultContext[defaultName][property];
    }
    if (hasOwnProperty(defaultContext, name310)) {
      var _properties2 = defaultContext[name310];
      if (hasOwnProperty(_properties2, property)) {
        return _properties2[property];
      }
    }
    return defaultContext[defaultName][property];
  }
  function isCommutative(node) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
    return hasProperty(node, "commutative", context);
  }
  function isAssociative(node) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
    return hasProperty(node, "associative", context);
  }
  function mergeContext(primary, secondary) {
    var merged = _objectSpread3({}, primary);
    for (var prop in secondary) {
      if (hasOwnProperty(primary, prop)) {
        merged[prop] = _objectSpread3(_objectSpread3({}, secondary[prop]), primary[prop]);
      } else {
        merged[prop] = secondary[prop];
      }
    }
    return merged;
  }
  function flatten2(node, context) {
    if (!node.args || node.args.length === 0) {
      return node;
    }
    node.args = allChildren(node, context);
    for (var i = 0; i < node.args.length; i++) {
      flatten2(node.args[i], context);
    }
  }
  function allChildren(node, context) {
    var op;
    var children2 = [];
    var findChildren = function findChildren2(node2) {
      for (var i = 0; i < node2.args.length; i++) {
        var child = node2.args[i];
        if (isOperatorNode(child) && op === child.op) {
          findChildren2(child);
        } else {
          children2.push(child);
        }
      }
    };
    if (isAssociative(node, context)) {
      op = node.op;
      findChildren(node);
      return children2;
    } else {
      return node.args;
    }
  }
  function unflattenr(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i = 0; i < l; i++) {
      unflattenr(node.args[i], context);
    }
    if (l > 2 && isAssociative(node, context)) {
      var curnode = node.args.pop();
      while (node.args.length > 0) {
        curnode = makeNode([node.args.pop(), curnode]);
      }
      node.args = curnode.args;
    }
  }
  function unflattenl(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i = 0; i < l; i++) {
      unflattenl(node.args[i], context);
    }
    if (l > 2 && isAssociative(node, context)) {
      var curnode = node.args.shift();
      while (node.args.length > 0) {
        curnode = makeNode([curnode, node.args.shift()]);
      }
      node.args = curnode.args;
    }
  }
  function createMakeNodeFunction(node) {
    if (isOperatorNode(node)) {
      return function(args) {
        try {
          return new OperatorNode(node.op, node.fn, args, node.implicit);
        } catch (err) {
          console.error(err);
          return [];
        }
      };
    } else {
      return function(args) {
        return new FunctionNode(new SymbolNode(node.name), args);
      };
    }
  }
  return {
    createMakeNodeFunction,
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten2,
    allChildren,
    unflattenr,
    unflattenl,
    defaultContext,
    realContext,
    positiveContext
  };
});

// node_modules/mathjs/lib/esm/function/algebra/simplify.js
var name279 = "simplify";
var dependencies279 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplify = /* @__PURE__ */ factory(name279, dependencies279, (_ref) => {
  var {
    config: config4,
    typed: typed3,
    parse,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    pow: pow3,
    isZero,
    equal,
    resolve,
    simplifyConstant,
    simplifyCore,
    fraction,
    bignumber,
    mathWithTransform,
    matrix,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  } = _ref;
  var {
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten2,
    unflattenr,
    unflattenl,
    createMakeNodeFunction,
    defaultContext,
    realContext,
    positiveContext
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  typed3.addConversion({
    from: "Object",
    to: "Map",
    convert: createMap
  });
  var simplify = typed3("simplify", {
    Node: _simplify,
    "Node, Map": (expr, scope) => _simplify(expr, false, scope),
    "Node, Map, Object": (expr, scope, options) => _simplify(expr, false, scope, options),
    "Node, Array": _simplify,
    "Node, Array, Map": _simplify,
    "Node, Array, Map, Object": _simplify
  });
  typed3.removeConversion({
    from: "Object",
    to: "Map",
    convert: createMap
  });
  simplify.defaultContext = defaultContext;
  simplify.realContext = realContext;
  simplify.positiveContext = positiveContext;
  function removeParens(node) {
    return node.transform(function(node2, path2, parent) {
      return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
    });
  }
  var SUPPORTED_CONSTANTS = {
    true: true,
    false: true,
    e: true,
    i: true,
    Infinity: true,
    LN2: true,
    LN10: true,
    LOG2E: true,
    LOG10E: true,
    NaN: true,
    phi: true,
    pi: true,
    SQRT1_2: true,
    SQRT2: true,
    tau: true
    // null: false,
    // undefined: false,
    // version: false,
  };
  simplify.rules = [
    simplifyCore,
    // { l: 'n+0', r: 'n' },     // simplifyCore
    // { l: 'n^0', r: '1' },     // simplifyCore
    // { l: '0*n', r: '0' },     // simplifyCore
    // { l: 'n/n', r: '1'},      // simplifyCore
    // { l: 'n^1', r: 'n' },     // simplifyCore
    // { l: '+n1', r:'n1' },     // simplifyCore
    // { l: 'n--n1', r:'n+n1' }, // simplifyCore
    {
      l: "log(e)",
      r: "1"
    },
    // temporary rules
    // Note initially we tend constants to the right because like-term
    // collection prefers the left, and we would rather collect nonconstants
    {
      s: "n-n1 -> n+-n1",
      // temporarily replace 'subtract' so we can further flatten the 'add' operator
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n-n -> 0",
      // partial alternative when we can't always subtract
      assuming: {
        subtract: {
          total: false
        }
      }
    },
    {
      s: "-(cl*v) -> v * (-cl)",
      // make non-constant terms positive
      assuming: {
        multiply: {
          commutative: true
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(cl*v) -> (-cl) * v",
      // non-commutative version, part 1
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(v*cl) -> v * (-cl)",
      // non-commutative version, part 2
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      l: "-(n1/n2)",
      r: "-n1/n2"
    },
    {
      l: "-v",
      r: "v * (-1)"
    },
    // finish making non-constant terms positive
    {
      l: "(n1 + n2)*(-1)",
      r: "n1*(-1) + n2*(-1)",
      repeat: true
    },
    // expand negations to achieve as much sign cancellation as possible
    {
      l: "n/n1^n2",
      r: "n*n1^-n2"
    },
    // temporarily replace 'divide' so we can further flatten the 'multiply' operator
    {
      l: "n/n1",
      r: "n*n1^-1"
    },
    {
      s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    // expand nested exponentiation
    {
      s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
      assuming: {
        divide: {
          total: true
        }
      }
      // 1/(1/n) = n needs 1/n to exist
    },
    // collect like factors; into a sum, only do this for nonconstants
    {
      l: " vd   * ( vd   * n1 + n2)",
      r: "vd^2       * n1 +  vd   * n2"
    },
    {
      s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
      assuming: {
        divide: {
          total: true
        }
      }
      // v*1/v = v^(1+-1) needs 1/v
    },
    {
      s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: "n*n",
      r: "n^2"
    },
    {
      s: "n * n^n1 -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        }
      }
      // n*1/n = n^(-1+1) needs 1/n
    },
    {
      s: "n^n1 * n^n2 -> n^(n1+n2)",
      assuming: {
        divide: {
          total: true
        }
      }
      // ditto for n^2*1/n^2
    },
    // Unfortunately, to deal with more complicated cancellations, it
    // becomes necessary to simplify constants twice per pass. It's not
    // terribly expensive compared to matching rules, so this should not
    // pose a performance problem.
    simplifyConstant,
    // First: before collecting like terms
    // collect like terms
    {
      s: "n+n -> 2*n",
      assuming: {
        add: {
          total: true
        }
      }
      // 2 = 1 + 1 needs to exist
    },
    {
      l: "n+-n",
      r: "0"
    },
    {
      l: "vd*n + vd",
      r: "vd*(n+1)"
    },
    // NOTE: leftmost position is special:
    {
      l: "n3*n1 + n3*n2",
      r: "n3*(n1+n2)"
    },
    // All sub-monomials tried there.
    {
      l: "n3^(-n4)*n1 +   n3  * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
    },
    {
      l: "n3^(-n4)*n1 + n3^n5 * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
    },
    // noncommutative additional cases (term collection & factoring)
    {
      s: "n*vd + vd -> (n+1)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "vd + n*vd -> (1+n)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n^n1 * n -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n*cd + cd",
      r: "(n+1)*cd"
    },
    {
      s: "cd*n + cd -> cd*(n+1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "cd + cd*n -> cd*(1+n)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    simplifyConstant,
    // Second: before returning expressions to "standard form"
    // make factors positive (and undo 'make non-constant terms positive')
    {
      s: "(-n)*n1 -> -(n*n1)",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n1*(-n) -> -(n1*n)",
      // in case * non-commutative
      assuming: {
        subtract: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    // final ordering of constants
    {
      s: "ce+ve -> ve+ce",
      assuming: {
        add: {
          commutative: true
        }
      },
      imposeContext: {
        add: {
          commutative: false
        }
      }
    },
    {
      s: "vd*cd -> cd*vd",
      assuming: {
        multiply: {
          commutative: true
        }
      },
      imposeContext: {
        multiply: {
          commutative: false
        }
      }
    },
    // undo temporary rules
    // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
    {
      l: "n+-n1",
      r: "n-n1"
    },
    // undo replace 'subtract'
    {
      l: "n+-(n1)",
      r: "n-(n1)"
    },
    {
      s: "n*(n1^-1) -> n/n1",
      // undo replace 'divide'; for * commutative
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n*n1^-n2 -> n/n1^n2",
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n^-1 -> 1/n",
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      l: "n^1",
      r: "n"
    },
    // can be produced by power cancellation
    {
      s: "n*(n1/n2) -> (n*n1)/n2",
      // '*' before '/'
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      s: "n-(n1+n2) -> n-n1-n2",
      // '-' before '+'
      assuming: {
        addition: {
          associative: true,
          commutative: true
        }
      }
    },
    // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
    // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
    // simplifyConstant can leave an extra factor of 1, which can always
    // be eliminated, since the identity always commutes
    {
      l: "1*n",
      r: "n",
      imposeContext: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n1/(n2/n3) -> (n1*n3)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      l: "n1/(-n2)",
      r: "-n1/n2"
    }
  ];
  function _canonicalizeRule(ruleObject, context) {
    var newRule = {};
    if (ruleObject.s) {
      var lr = ruleObject.s.split("->");
      if (lr.length === 2) {
        newRule.l = lr[0];
        newRule.r = lr[1];
      } else {
        throw SyntaxError("Could not parse rule: " + ruleObject.s);
      }
    } else {
      newRule.l = ruleObject.l;
      newRule.r = ruleObject.r;
    }
    newRule.l = removeParens(parse(newRule.l));
    newRule.r = removeParens(parse(newRule.r));
    for (var prop of ["imposeContext", "repeat", "assuming"]) {
      if (prop in ruleObject) {
        newRule[prop] = ruleObject[prop];
      }
    }
    if (ruleObject.evaluate) {
      newRule.evaluate = parse(ruleObject.evaluate);
    }
    if (isAssociative(newRule.l, context)) {
      var nonCommutative = !isCommutative(newRule.l, context);
      var leftExpandsym;
      if (nonCommutative)
        leftExpandsym = _getExpandPlaceholderSymbol();
      var makeNode = createMakeNodeFunction(newRule.l);
      var expandsym = _getExpandPlaceholderSymbol();
      newRule.expanded = {};
      newRule.expanded.l = makeNode([newRule.l, expandsym]);
      flatten2(newRule.expanded.l, context);
      unflattenr(newRule.expanded.l, context);
      newRule.expanded.r = makeNode([newRule.r, expandsym]);
      if (nonCommutative) {
        newRule.expandedNC1 = {};
        newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
        newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
        newRule.expandedNC2 = {};
        newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
        newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
      }
    }
    return newRule;
  }
  function _buildRules(rules, context) {
    var ruleSet = [];
    for (var i = 0; i < rules.length; i++) {
      var rule = rules[i];
      var newRule = void 0;
      var ruleType = typeof rule;
      switch (ruleType) {
        case "string":
          rule = {
            s: rule
          };
        case "object":
          newRule = _canonicalizeRule(rule, context);
          break;
        case "function":
          newRule = rule;
          break;
        default:
          throw TypeError("Unsupported type of rule: " + ruleType);
      }
      ruleSet.push(newRule);
    }
    return ruleSet;
  }
  var _lastsym = 0;
  function _getExpandPlaceholderSymbol() {
    return new SymbolNode("_p" + _lastsym++);
  }
  function _simplify(expr, rules) {
    var scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createEmptyMap();
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var debug = options.consoleDebug;
    rules = _buildRules(rules || simplify.rules, options.context);
    var res = resolve(expr, scope);
    res = removeParens(res);
    var visited = {};
    var str = res.toString({
      parenthesis: "all"
    });
    while (!visited[str]) {
      visited[str] = true;
      _lastsym = 0;
      var laststr = str;
      if (debug)
        console.log("Working on: ", str);
      for (var i = 0; i < rules.length; i++) {
        var rulestr = "";
        if (typeof rules[i] === "function") {
          res = rules[i](res, options);
          if (debug)
            rulestr = rules[i].name;
        } else {
          flatten2(res, options.context);
          res = applyRule(res, rules[i], options.context);
          if (debug) {
            rulestr = "".concat(rules[i].l.toString(), " -> ").concat(rules[i].r.toString());
          }
        }
        if (debug) {
          var newstr = res.toString({
            parenthesis: "all"
          });
          if (newstr !== laststr) {
            console.log("Applying", rulestr, "produced", newstr);
            laststr = newstr;
          }
        }
        unflattenl(res, options.context);
      }
      str = res.toString({
        parenthesis: "all"
      });
    }
    return res;
  }
  function mapRule(nodes, rule, context) {
    var resNodes = nodes;
    if (nodes) {
      for (var i = 0; i < nodes.length; ++i) {
        var newNode = applyRule(nodes[i], rule, context);
        if (newNode !== nodes[i]) {
          if (resNodes === nodes) {
            resNodes = nodes.slice();
          }
          resNodes[i] = newNode;
        }
      }
    }
    return resNodes;
  }
  function applyRule(node, rule, context) {
    if (rule.assuming) {
      for (var symbol in rule.assuming) {
        for (var property in rule.assuming[symbol]) {
          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
            return node;
          }
        }
      }
    }
    var mergedContext = mergeContext(rule.imposeContext, context);
    var res = node;
    if (res instanceof OperatorNode || res instanceof FunctionNode) {
      var newArgs = mapRule(res.args, rule, context);
      if (newArgs !== res.args) {
        res = res.clone();
        res.args = newArgs;
      }
    } else if (res instanceof ParenthesisNode) {
      if (res.content) {
        var newContent = applyRule(res.content, rule, context);
        if (newContent !== res.content) {
          res = new ParenthesisNode(newContent);
        }
      }
    } else if (res instanceof ArrayNode) {
      var newItems = mapRule(res.items, rule, context);
      if (newItems !== res.items) {
        res = new ArrayNode(newItems);
      }
    } else if (res instanceof AccessorNode) {
      var newObj = res.object;
      if (res.object) {
        newObj = applyRule(res.object, rule, context);
      }
      var newIndex = res.index;
      if (res.index) {
        newIndex = applyRule(res.index, rule, context);
      }
      if (newObj !== res.object || newIndex !== res.index) {
        res = new AccessorNode(newObj, newIndex);
      }
    } else if (res instanceof IndexNode) {
      var newDims = mapRule(res.dimensions, rule, context);
      if (newDims !== res.dimensions) {
        res = new IndexNode(newDims);
      }
    } else if (res instanceof ObjectNode) {
      var changed = false;
      var newProps = {};
      for (var prop in res.properties) {
        newProps[prop] = applyRule(res.properties[prop], rule, context);
        if (newProps[prop] !== res.properties[prop]) {
          changed = true;
        }
      }
      if (changed) {
        res = new ObjectNode(newProps);
      }
    }
    var repl = rule.r;
    var matches = _ruleMatch(rule.l, res, mergedContext)[0];
    if (!matches && rule.expanded) {
      repl = rule.expanded.r;
      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
    }
    if (!matches && rule.expandedNC1) {
      repl = rule.expandedNC1.r;
      matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
      if (!matches) {
        repl = rule.expandedNC2.r;
        matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
      }
    }
    if (matches) {
      var implicit2 = res.implicit;
      res = repl.clone();
      if (implicit2 && "implicit" in repl) {
        res.implicit = true;
      }
      res = res.transform(function(node2) {
        if (node2.isSymbolNode && hasOwnProperty(matches.placeholders, node2.name)) {
          return matches.placeholders[node2.name].clone();
        } else {
          return node2;
        }
      });
    }
    if (rule.repeat && res !== node) {
      res = applyRule(res, rule, context);
    }
    return res;
  }
  function getSplits(node, context) {
    var res = [];
    var right2, rightArgs;
    var makeNode = createMakeNodeFunction(node);
    if (isCommutative(node, context)) {
      for (var i = 0; i < node.args.length; i++) {
        rightArgs = node.args.slice(0);
        rightArgs.splice(i, 1);
        right2 = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([node.args[i], right2]));
      }
    } else {
      for (var _i = 1; _i < node.args.length; _i++) {
        var left2 = node.args[0];
        if (_i > 1) {
          left2 = makeNode(node.args.slice(0, _i));
        }
        rightArgs = node.args.slice(_i);
        right2 = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([left2, right2]));
      }
    }
    return res;
  }
  function mergeMatch(match1, match2) {
    var res = {
      placeholders: {}
    };
    if (!match1.placeholders && !match2.placeholders) {
      return res;
    } else if (!match1.placeholders) {
      return match2;
    } else if (!match2.placeholders) {
      return match1;
    }
    for (var key in match1.placeholders) {
      if (hasOwnProperty(match1.placeholders, key)) {
        res.placeholders[key] = match1.placeholders[key];
        if (hasOwnProperty(match2.placeholders, key)) {
          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
            return null;
          }
        }
      }
    }
    for (var _key in match2.placeholders) {
      if (hasOwnProperty(match2.placeholders, _key)) {
        res.placeholders[_key] = match2.placeholders[_key];
      }
    }
    return res;
  }
  function combineChildMatches(list1, list2) {
    var res = [];
    if (list1.length === 0 || list2.length === 0) {
      return res;
    }
    var merged;
    for (var i1 = 0; i1 < list1.length; i1++) {
      for (var i2 = 0; i2 < list2.length; i2++) {
        merged = mergeMatch(list1[i1], list2[i2]);
        if (merged) {
          res.push(merged);
        }
      }
    }
    return res;
  }
  function mergeChildMatches(childMatches) {
    if (childMatches.length === 0) {
      return childMatches;
    }
    var sets = childMatches.reduce(combineChildMatches);
    var uniqueSets = [];
    var unique = {};
    for (var i = 0; i < sets.length; i++) {
      var s2 = JSON.stringify(sets[i]);
      if (!unique[s2]) {
        unique[s2] = true;
        uniqueSets.push(sets[i]);
      }
    }
    return uniqueSets;
  }
  function _ruleMatch(rule, node, context, isSplit) {
    var res = [{
      placeholders: {}
    }];
    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
      if (rule instanceof OperatorNode) {
        if (rule.op !== node.op || rule.fn !== node.fn) {
          return [];
        }
      } else if (rule instanceof FunctionNode) {
        if (rule.name !== node.name) {
          return [];
        }
      }
      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
        var childMatches = [];
        for (var i = 0; i < rule.args.length; i++) {
          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);
          if (childMatch.length === 0) {
            break;
          }
          childMatches.push(childMatch);
        }
        if (childMatches.length !== rule.args.length) {
          if (!isCommutative(node, context) || // exact match in order needed
          rule.args.length === 1) {
            return [];
          }
          if (rule.args.length > 2) {
            throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
          }
          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
          if (leftMatch.length === 0) {
            return [];
          }
          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
          if (rightMatch.length === 0) {
            return [];
          }
          childMatches = [leftMatch, rightMatch];
        }
        res = mergeChildMatches(childMatches);
      } else if (node.args.length >= 2 && rule.args.length === 2) {
        var splits = getSplits(node, context);
        var splitMatches = [];
        for (var _i2 = 0; _i2 < splits.length; _i2++) {
          var matchSet = _ruleMatch(rule, splits[_i2], context, true);
          splitMatches = splitMatches.concat(matchSet);
        }
        return splitMatches;
      } else if (rule.args.length > 2) {
        throw Error("Unexpected non-binary associative function: " + rule.toString());
      } else {
        return [];
      }
    } else if (rule instanceof SymbolNode) {
      if (rule.name.length === 0) {
        throw new Error("Symbol in rule has 0 length...!?");
      }
      if (SUPPORTED_CONSTANTS[rule.name]) {
        if (rule.name !== node.name) {
          return [];
        }
      } else {
        switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
          case "n":
          case "_p":
            res[0].placeholders[rule.name] = node;
            break;
          case "c":
          case "cl":
            if (isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "v":
            if (!isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vl":
            if (isSymbolNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "cd":
            if (isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vd":
            if (!isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ce":
            if (isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ve":
            if (!isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          default:
            throw new Error("Invalid symbol in rule: " + rule.name);
        }
      }
    } else if (rule instanceof ConstantNode) {
      if (!equal(rule.value, node.value)) {
        return [];
      }
    } else {
      return [];
    }
    return res;
  }
  function _exactMatch(p, q) {
    if (p instanceof ConstantNode && q instanceof ConstantNode) {
      if (!equal(p.value, q.value)) {
        return false;
      }
    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
      if (p.name !== q.name) {
        return false;
      }
    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
      if (p instanceof OperatorNode) {
        if (p.op !== q.op || p.fn !== q.fn) {
          return false;
        }
      } else if (p instanceof FunctionNode) {
        if (p.name !== q.name) {
          return false;
        }
      }
      if (p.args.length !== q.args.length) {
        return false;
      }
      for (var i = 0; i < p.args.length; i++) {
        if (!_exactMatch(p.args[i], q.args[i])) {
          return false;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  return simplify;
});

// node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js
var name280 = "simplifyConstant";
var dependencies280 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
var createSimplifyConstant = /* @__PURE__ */ factory(name280, dependencies280, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    mathWithTransform,
    matrix,
    fraction,
    bignumber,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    SymbolNode
  } = _ref;
  var {
    isCommutative,
    isAssociative,
    allChildren,
    createMakeNodeFunction
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  var simplifyConstant = typed3("simplifyConstant", {
    Node: (node) => _ensureNode(foldFraction(node, {})),
    "Node, Object": function NodeObject(expr, options) {
      return _ensureNode(foldFraction(expr, options));
    }
  });
  function _removeFractions(thing) {
    if (isFraction(thing)) {
      return thing.valueOf();
    }
    if (thing instanceof Array) {
      return thing.map(_removeFractions);
    }
    if (isMatrix(thing)) {
      return matrix(_removeFractions(thing.valueOf()));
    }
    return thing;
  }
  function _eval(fnname, args, options) {
    try {
      return mathWithTransform[fnname].apply(null, args);
    } catch (ignore) {
      args = args.map(_removeFractions);
      return _toNumber(mathWithTransform[fnname].apply(null, args), options);
    }
  }
  var _toNode = typed3({
    Fraction: _fractionToNode,
    number: function number5(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode(-n));
      }
      return new ConstantNode(n);
    },
    BigNumber: function BigNumber2(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode(-n));
      }
      return new ConstantNode(n);
    },
    Complex: function Complex3(s2) {
      throw new Error("Cannot convert Complex number to Node");
    },
    string: function string(s2) {
      return new ConstantNode(s2);
    },
    Matrix: function Matrix2(m) {
      return new ArrayNode(m.valueOf().map((e3) => _toNode(e3)));
    }
  });
  function _ensureNode(thing) {
    if (isNode(thing)) {
      return thing;
    }
    return _toNode(thing);
  }
  function _exactFraction(n, options) {
    var exactFractions = options && options.exactFractions !== false;
    if (exactFractions && isFinite(n) && fraction) {
      var f = fraction(n);
      var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
        return f;
      }
    }
    return n;
  }
  var _toNumber = typed3({
    "string, Object": function stringObject(s2, options) {
      if (config4.number === "BigNumber") {
        if (bignumber === void 0) {
          noBignumber();
        }
        return bignumber(s2);
      } else if (config4.number === "Fraction") {
        if (fraction === void 0) {
          noFraction();
        }
        return fraction(s2);
      } else {
        var n = parseFloat(s2);
        return _exactFraction(n, options);
      }
    },
    "Fraction, Object": function FractionObject(s2, options) {
      return s2;
    },
    // we don't need options here
    "BigNumber, Object": function BigNumberObject(s2, options) {
      return s2;
    },
    // we don't need options here
    "number, Object": function numberObject(s2, options) {
      return _exactFraction(s2, options);
    },
    "Complex, Object": function ComplexObject(s2, options) {
      if (s2.im !== 0) {
        return s2;
      }
      return _exactFraction(s2.re, options);
    },
    "Matrix, Object": function MatrixObject(s2, options) {
      return matrix(_exactFraction(s2.valueOf()));
    },
    "Array, Object": function ArrayObject(s2, options) {
      return s2.map(_exactFraction);
    }
  });
  function unaryMinusNode(n) {
    return new OperatorNode("-", "unaryMinus", [n]);
  }
  function _fractionToNode(f) {
    var n;
    var vn = f.s * f.n;
    if (vn < 0) {
      n = new OperatorNode("-", "unaryMinus", [new ConstantNode(-vn)]);
    } else {
      n = new ConstantNode(vn);
    }
    if (f.d === 1) {
      return n;
    }
    return new OperatorNode("/", "divide", [n, new ConstantNode(f.d)]);
  }
  function _foldAccessor(obj, index, options) {
    if (!isIndexNode(index)) {
      return new AccessorNode(_ensureNode(obj), _ensureNode(index));
    }
    if (isArrayNode(obj) || isMatrix(obj)) {
      var remainingDims = Array.from(index.dimensions);
      while (remainingDims.length > 0) {
        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
          var first = _toNumber(remainingDims.shift().value, options);
          if (isArrayNode(obj)) {
            obj = obj.items[first - 1];
          } else {
            obj = obj.valueOf()[first - 1];
            if (obj instanceof Array) {
              obj = matrix(obj);
            }
          }
        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
          var second2 = _toNumber(remainingDims[1].value, options);
          var tryItems = [];
          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
          for (var item of fromItems) {
            if (isArrayNode(item)) {
              tryItems.push(item.items[second2 - 1]);
            } else if (isMatrix(obj)) {
              tryItems.push(item[second2 - 1]);
            } else {
              break;
            }
          }
          if (tryItems.length === fromItems.length) {
            if (isArrayNode(obj)) {
              obj = new ArrayNode(tryItems);
            } else {
              obj = matrix(tryItems);
            }
            remainingDims.splice(1, 1);
          } else {
            break;
          }
        } else {
          break;
        }
      }
      if (remainingDims.length === index.dimensions.length) {
        return new AccessorNode(_ensureNode(obj), index);
      }
      if (remainingDims.length > 0) {
        index = new IndexNode(remainingDims);
        return new AccessorNode(_ensureNode(obj), index);
      }
      return obj;
    }
    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {
      var key = index.dimensions[0].value;
      if (key in obj.properties) {
        return obj.properties[key];
      }
      return new ConstantNode();
    }
    return new AccessorNode(_ensureNode(obj), index);
  }
  function foldOp(fn, args, makeNode, options) {
    var first = args.shift();
    var reduction = args.reduce((sofar, next) => {
      if (!isNode(next)) {
        var last = sofar.pop();
        if (isNode(last)) {
          return [last, next];
        }
        try {
          sofar.push(_eval(fn, [last, next], options));
          return sofar;
        } catch (ignoreandcontinue) {
          sofar.push(last);
        }
      }
      sofar.push(_ensureNode(sofar.pop()));
      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
      return [makeNode([newtree, _ensureNode(next)])];
    }, [first]);
    if (reduction.length === 1) {
      return reduction[0];
    }
    return makeNode([reduction[0], _toNode(reduction[1])]);
  }
  function foldFraction(node, options) {
    switch (node.type) {
      case "SymbolNode":
        return node;
      case "ConstantNode":
        switch (typeof node.value) {
          case "number":
            return _toNumber(node.value, options);
          case "string":
            return node.value;
          default:
            if (!isNaN(node.value))
              return _toNumber(node.value, options);
        }
        return node;
      case "FunctionNode":
        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
          return node;
        }
        {
          var operatorFunctions = ["add", "multiply"];
          if (operatorFunctions.indexOf(node.name) === -1) {
            var args = node.args.map((arg) => foldFraction(arg, options));
            if (!args.some(isNode)) {
              try {
                return _eval(node.name, args, options);
              } catch (ignoreandcontinue) {
              }
            }
            if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
              var sz = [];
              var section = args[0];
              while (isArrayNode(section)) {
                sz.push(section.items.length);
                section = section.items[0];
              }
              return matrix(sz);
            }
            return new FunctionNode(node.name, args.map(_ensureNode));
          } else {
          }
        }
      case "OperatorNode": {
        var fn = node.fn.toString();
        var _args;
        var res;
        var makeNode = createMakeNodeFunction(node);
        if (isOperatorNode(node) && node.isUnary()) {
          _args = [foldFraction(node.args[0], options)];
          if (!isNode(_args[0])) {
            res = _eval(fn, _args, options);
          } else {
            res = makeNode(_args);
          }
        } else if (isAssociative(node, options.context)) {
          _args = allChildren(node, options.context);
          _args = _args.map((arg) => foldFraction(arg, options));
          if (isCommutative(fn, options.context)) {
            var consts = [];
            var vars = [];
            for (var i = 0; i < _args.length; i++) {
              if (!isNode(_args[i])) {
                consts.push(_args[i]);
              } else {
                vars.push(_args[i]);
              }
            }
            if (consts.length > 1) {
              res = foldOp(fn, consts, makeNode, options);
              vars.unshift(res);
              res = foldOp(fn, vars, makeNode, options);
            } else {
              res = foldOp(fn, _args, makeNode, options);
            }
          } else {
            res = foldOp(fn, _args, makeNode, options);
          }
        } else {
          _args = node.args.map((arg) => foldFraction(arg, options));
          res = foldOp(fn, _args, makeNode, options);
        }
        return res;
      }
      case "ParenthesisNode":
        return foldFraction(node.content, options);
      case "AccessorNode":
        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
      case "ArrayNode": {
        var foldItems = node.items.map((item) => foldFraction(item, options));
        if (foldItems.some(isNode)) {
          return new ArrayNode(foldItems.map(_ensureNode));
        }
        return matrix(foldItems);
      }
      case "IndexNode": {
        return new IndexNode(node.dimensions.map((n) => simplifyConstant(n, options)));
      }
      case "ObjectNode": {
        var foldProps = {};
        for (var prop in node.properties) {
          foldProps[prop] = simplifyConstant(node.properties[prop], options);
        }
        return new ObjectNode(foldProps);
      }
      case "AssignmentNode":
      case "BlockNode":
      case "FunctionAssignmentNode":
      case "RangeNode":
      case "ConditionalNode":
      default:
        throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
    }
  }
  return simplifyConstant;
});

// node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js
var name281 = "simplifyCore";
var dependencies281 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplifyCore = /* @__PURE__ */ factory(name281, dependencies281, (_ref) => {
  var {
    typed: typed3,
    parse,
    equal,
    isZero,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    pow: pow3,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  } = _ref;
  var node0 = new ConstantNode(0);
  var node1 = new ConstantNode(1);
  var nodeT = new ConstantNode(true);
  var nodeF = new ConstantNode(false);
  function isAlwaysBoolean(node) {
    return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
  }
  var {
    hasProperty,
    isCommutative
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  function _simplifyCore(nodeToSimplify) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var context = options ? options.context : void 0;
    if (hasProperty(nodeToSimplify, "trivial", context)) {
      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
        return _simplifyCore(nodeToSimplify.args[0], options);
      }
      var simpChild = false;
      var childCount = 0;
      nodeToSimplify.forEach((c2) => {
        ++childCount;
        if (childCount === 1) {
          simpChild = _simplifyCore(c2, options);
        }
      });
      if (childCount === 1) {
        return simpChild;
      }
    }
    var node = nodeToSimplify;
    if (isFunctionNode(node)) {
      var op = getOperator(node.name);
      if (op) {
        if (node.args.length > 2 && hasProperty(node, "associative", context)) {
          while (node.args.length > 2) {
            var last = node.args.pop();
            var seclast = node.args.pop();
            node.args.push(new OperatorNode(op, node.name, [last, seclast]));
          }
        }
        node = new OperatorNode(op, node.name, node.args);
      } else {
        return new FunctionNode(_simplifyCore(node.fn), node.args.map((n) => _simplifyCore(n, options)));
      }
    }
    if (isOperatorNode(node) && node.isUnary()) {
      var a0 = _simplifyCore(node.args[0], options);
      if (node.op === "~") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
          return a0.args[0];
        }
      }
      if (node.op === "not") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
          if (isAlwaysBoolean(a0.args[0])) {
            return a0.args[0];
          }
        }
      }
      var finish = true;
      if (node.op === "-") {
        if (isOperatorNode(a0)) {
          if (a0.isBinary() && a0.fn === "subtract") {
            node = new OperatorNode("-", "subtract", [a0.args[1], a0.args[0]]);
            finish = false;
          }
          if (a0.isUnary() && a0.op === "-") {
            return a0.args[0];
          }
        }
      }
      if (finish)
        return new OperatorNode(node.op, node.fn, [a0]);
    }
    if (isOperatorNode(node) && node.isBinary()) {
      var _a = _simplifyCore(node.args[0], options);
      var a1 = _simplifyCore(node.args[1], options);
      if (node.op === "+") {
        if (isConstantNode(_a) && isZero(_a.value)) {
          return a1;
        }
        if (isConstantNode(a1) && isZero(a1.value)) {
          return _a;
        }
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          a1 = a1.args[0];
          node = new OperatorNode("-", "subtract", [_a, a1]);
        }
      }
      if (node.op === "-") {
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          return _simplifyCore(new OperatorNode("+", "add", [_a, a1.args[0]]), options);
        }
        if (isConstantNode(_a) && isZero(_a.value)) {
          return _simplifyCore(new OperatorNode("-", "unaryMinus", [a1]));
        }
        if (isConstantNode(a1) && isZero(a1.value)) {
          return _a;
        }
        return new OperatorNode(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "*") {
        if (isConstantNode(_a)) {
          if (isZero(_a.value)) {
            return node0;
          } else if (equal(_a.value, 1)) {
            return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (isZero(a1.value)) {
            return node0;
          } else if (equal(a1.value, 1)) {
            return _a;
          }
          if (isCommutative(node, context)) {
            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit);
          }
        }
        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);
      }
      if (node.op === "/") {
        if (isConstantNode(_a) && isZero(_a.value)) {
          return node0;
        }
        if (isConstantNode(a1) && equal(a1.value, 1)) {
          return _a;
        }
        return new OperatorNode(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "^") {
        if (isConstantNode(a1)) {
          if (isZero(a1.value)) {
            return node1;
          } else if (equal(a1.value, 1)) {
            return _a;
          }
        }
      }
      if (node.op === "and") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            if (isAlwaysBoolean(a1))
              return a1;
          } else {
            return nodeF;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            if (isAlwaysBoolean(_a))
              return _a;
          } else {
            return nodeF;
          }
        }
      }
      if (node.op === "or") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(a1))
              return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(_a))
              return _a;
          }
        }
      }
      return new OperatorNode(node.op, node.fn, [_a, a1]);
    }
    if (isOperatorNode(node)) {
      return new OperatorNode(node.op, node.fn, node.args.map((a2) => _simplifyCore(a2, options)));
    }
    if (isArrayNode(node)) {
      return new ArrayNode(node.items.map((n) => _simplifyCore(n, options)));
    }
    if (isAccessorNode(node)) {
      return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
    }
    if (isIndexNode(node)) {
      return new IndexNode(node.dimensions.map((n) => _simplifyCore(n, options)));
    }
    if (isObjectNode(node)) {
      var newProps = {};
      for (var prop in node.properties) {
        newProps[prop] = _simplifyCore(node.properties[prop], options);
      }
      return new ObjectNode(newProps);
    }
    return node;
  }
  return typed3(name281, {
    Node: _simplifyCore,
    "Node,Object": _simplifyCore
  });
});

// node_modules/mathjs/lib/esm/function/algebra/resolve.js
var name282 = "resolve";
var dependencies282 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
var createResolve = /* @__PURE__ */ factory(name282, dependencies282, (_ref) => {
  var {
    typed: typed3,
    parse,
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode
  } = _ref;
  function _resolve(node, scope) {
    var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
    if (!scope) {
      return node;
    }
    if (isSymbolNode(node)) {
      if (within.has(node.name)) {
        var variables = Array.from(within).join(", ");
        throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
      }
      var value = scope.get(node.name);
      if (isNode(value)) {
        var nextWithin = new Set(within);
        nextWithin.add(node.name);
        return _resolve(value, scope, nextWithin);
      } else if (typeof value === "number") {
        return parse(String(value));
      } else if (value !== void 0) {
        return new ConstantNode(value);
      } else {
        return node;
      }
    } else if (isOperatorNode(node)) {
      var args = node.args.map(function(arg) {
        return _resolve(arg, scope, within);
      });
      return new OperatorNode(node.op, node.fn, args, node.implicit);
    } else if (isParenthesisNode(node)) {
      return new ParenthesisNode(_resolve(node.content, scope, within));
    } else if (isFunctionNode(node)) {
      var _args = node.args.map(function(arg) {
        return _resolve(arg, scope, within);
      });
      return new FunctionNode(node.name, _args);
    }
    return node.map((child) => _resolve(child, scope, within));
  }
  return typed3("resolve", {
    Node: _resolve,
    "Node, Map | null | undefined": _resolve,
    "Node, Object": (n, scope) => _resolve(n, createMap(scope)),
    // For arrays and matrices, we map `self` rather than `_resolve`
    // because resolve is fairly expensive anyway, and this way
    // we get nice error messages if one entry in the array has wrong type.
    "Array | Matrix": typed3.referToSelf((self2) => (A2) => A2.map((n) => self2(n))),
    "Array | Matrix, null | undefined": typed3.referToSelf((self2) => (A2) => A2.map((n) => self2(n))),
    "Array, Object": typed3.referTo("Array,Map", (selfAM) => (A2, scope) => selfAM(A2, createMap(scope))),
    "Matrix, Object": typed3.referTo("Matrix,Map", (selfMM) => (A2, scope) => selfMM(A2, createMap(scope))),
    "Array | Matrix, Map": typed3.referToSelf((self2) => (A2, scope) => A2.map((n) => self2(n, scope)))
  });
});

// node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
var name283 = "symbolicEqual";
var dependencies283 = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = /* @__PURE__ */ factory(name283, dependencies283, (_ref) => {
  var {
    parse,
    simplify,
    typed: typed3,
    OperatorNode
  } = _ref;
  function _symbolicEqual(e1, e22) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var diff = new OperatorNode("-", "subtract", [e1, e22]);
    var simplified = simplify(diff, {}, options);
    return isConstantNode(simplified) && !simplified.value;
  }
  return typed3(name283, {
    "Node, Node": _symbolicEqual,
    "Node, Node, Object": _symbolicEqual
  });
});

// node_modules/mathjs/lib/esm/function/algebra/derivative.js
var name284 = "derivative";
var dependencies284 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createDerivative = /* @__PURE__ */ factory(name284, dependencies284, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    parse,
    simplify,
    equal,
    isZero,
    numeric: numeric2,
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  } = _ref;
  function plainDerivative(expr, variable) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      simplify: true
    };
    var constNodes = {};
    constTag(constNodes, expr, variable.name);
    var res = _derivative(expr, constNodes);
    return options.simplify ? simplify(res) : res;
  }
  typed3.addConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse
  });
  var derivative = typed3(name284, {
    "Node, SymbolNode": plainDerivative,
    "Node, SymbolNode, Object": plainDerivative
    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
      let res = expr
      for (let i = 0; i < order; i++) {
        let constNodes = {}
        constTag(constNodes, expr, variable.name)
        res = _derivative(res, constNodes)
      }
      return res
    }
    */
  });
  typed3.removeConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse
  });
  derivative._simplify = true;
  derivative.toTex = function(deriv) {
    return _derivTex.apply(null, deriv.args);
  };
  var _derivTex = typed3("_derivTex", {
    "Node, SymbolNode": function NodeSymbolNode(expr, x2) {
      if (isConstantNode(expr) && typeOf(expr.value) === "string") {
        return _derivTex(parse(expr.value).toString(), x2.toString(), 1);
      } else {
        return _derivTex(expr.toTex(), x2.toString(), 1);
      }
    },
    "Node, ConstantNode": function NodeConstantNode(expr, x2) {
      if (typeOf(x2.value) === "string") {
        return _derivTex(expr, parse(x2.value));
      } else {
        throw new Error("The second parameter to 'derivative' is a non-string constant");
      }
    },
    "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x2, order) {
      return _derivTex(expr.toString(), x2.name, order.value);
    },
    "string, string, number": function stringStringNumber(expr, x2, order) {
      var d;
      if (order === 1) {
        d = "{d\\over d" + x2 + "}";
      } else {
        d = "{d^{" + order + "}\\over d" + x2 + "^{" + order + "}}";
      }
      return d + "\\left[".concat(expr, "\\right]");
    }
  });
  var constTag = typed3("constTag", {
    "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
      constNodes[node] = true;
      return true;
    },
    "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
      if (node.name !== varName) {
        constNodes[node] = true;
        return true;
      }
      return false;
    },
    "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
      return constTag(constNodes, node.content, varName);
    },
    "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
      if (node.params.indexOf(varName) === -1) {
        constNodes[node] = true;
        return true;
      }
      return constTag(constNodes, node.expr, varName);
    },
    "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
      if (node.args.length > 0) {
        var isConst = constTag(constNodes, node.args[0], varName);
        for (var i = 1; i < node.args.length; ++i) {
          isConst = constTag(constNodes, node.args[i], varName) && isConst;
        }
        if (isConst) {
          constNodes[node] = true;
          return true;
        }
      }
      return false;
    }
  });
  var _derivative = typed3("_derivative", {
    "ConstantNode, Object": function ConstantNodeObject(node) {
      return createConstantNode2(0);
    },
    "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      return createConstantNode2(1);
    },
    "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
      return new ParenthesisNode(_derivative(node.content, constNodes));
    },
    "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      return _derivative(node.expr, constNodes);
    },
    "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
      if (node.args.length !== 1) {
        funcArgsCheck(node);
      }
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      var arg0 = node.args[0];
      var arg1;
      var div2 = false;
      var negative = false;
      var funcDerivative;
      switch (node.name) {
        case "cbrt":
          div2 = true;
          funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(3), new OperatorNode("^", "pow", [arg0, new OperatorNode("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
          break;
        case "sqrt":
        case "nthRoot":
          if (node.args.length === 1) {
            div2 = true;
            funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(2), new FunctionNode("sqrt", [arg0])]);
          } else if (node.args.length === 2) {
            arg1 = new OperatorNode("/", "divide", [createConstantNode2(1), node.args[1]]);
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode("^", "pow", [arg0, arg1]), constNodes);
          }
          break;
        case "log10":
          arg1 = createConstantNode2(10);
        case "log":
          if (!arg1 && node.args.length === 1) {
            funcDerivative = arg0.clone();
            div2 = true;
          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
            funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("log", [arg1 || node.args[1]])]);
            div2 = true;
          } else if (node.args.length === 2) {
            return _derivative(new OperatorNode("/", "divide", [new FunctionNode("log", [arg0]), new FunctionNode("log", [node.args[1]])]), constNodes);
          }
          break;
        case "pow":
          constNodes[arg1] = constNodes[node.args[1]];
          return _derivative(new OperatorNode("^", "pow", [arg0, node.args[1]]), constNodes);
        case "exp":
          funcDerivative = new FunctionNode("exp", [arg0.clone()]);
          break;
        case "sin":
          funcDerivative = new FunctionNode("cos", [arg0.clone()]);
          break;
        case "cos":
          funcDerivative = new OperatorNode("-", "unaryMinus", [new FunctionNode("sin", [arg0.clone()])]);
          break;
        case "tan":
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sec", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sec":
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tan", [arg0.clone()])]);
          break;
        case "csc":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("cot", [arg0.clone()])]);
          break;
        case "cot":
          negative = true;
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csc", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asin":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "acos":
          div2 = true;
          negative = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "atan":
          div2 = true;
          funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "asec":
          div2 = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acsc":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acot":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "sinh":
          funcDerivative = new FunctionNode("cosh", [arg0.clone()]);
          break;
        case "cosh":
          funcDerivative = new FunctionNode("sinh", [arg0.clone()]);
          break;
        case "tanh":
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sech", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sech":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tanh", [arg0.clone()])]);
          break;
        case "csch":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("coth", [arg0.clone()])]);
          break;
        case "coth":
          negative = true;
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csch", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asinh":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "acosh":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "atanh":
          div2 = true;
          funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "asech":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
          break;
        case "acsch":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acoth":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "abs":
          funcDerivative = new OperatorNode("/", "divide", [new FunctionNode(new SymbolNode("abs"), [arg0.clone()]), arg0.clone()]);
          break;
        case "gamma":
        default:
          throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
      }
      var op, func;
      if (div2) {
        op = "/";
        func = "divide";
      } else {
        op = "*";
        func = "multiply";
      }
      var chainDerivative = _derivative(arg0, constNodes);
      if (negative) {
        chainDerivative = new OperatorNode("-", "unaryMinus", [chainDerivative]);
      }
      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
    },
    "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      if (node.op === "+") {
        return new OperatorNode(node.op, node.fn, node.args.map(function(arg) {
          return _derivative(arg, constNodes);
        }));
      }
      if (node.op === "-") {
        if (node.isUnary()) {
          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
        }
        if (node.isBinary()) {
          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
        }
      }
      if (node.op === "*") {
        var constantTerms = node.args.filter(function(arg) {
          return constNodes[arg] !== void 0;
        });
        if (constantTerms.length > 0) {
          var nonConstantTerms = node.args.filter(function(arg) {
            return constNodes[arg] === void 0;
          });
          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode("*", "multiply", nonConstantTerms);
          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
          return new OperatorNode("*", "multiply", newArgs);
        }
        return new OperatorNode("+", "add", node.args.map(function(argOuter) {
          return new OperatorNode("*", "multiply", node.args.map(function(argInner) {
            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
          }));
        }));
      }
      if (node.op === "/" && node.isBinary()) {
        var arg0 = node.args[0];
        var arg1 = node.args[1];
        if (constNodes[arg1] !== void 0) {
          return new OperatorNode("/", "divide", [_derivative(arg0, constNodes), arg1]);
        }
        if (constNodes[arg0] !== void 0) {
          return new OperatorNode("*", "multiply", [new OperatorNode("-", "unaryMinus", [arg0]), new OperatorNode("/", "divide", [_derivative(arg1, constNodes), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
        }
        return new OperatorNode("/", "divide", [new OperatorNode("-", "subtract", [new OperatorNode("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
      }
      if (node.op === "^" && node.isBinary()) {
        var _arg = node.args[0];
        var _arg2 = node.args[1];
        if (constNodes[_arg] !== void 0) {
          if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {
            return createConstantNode2(0);
          }
          return new OperatorNode("*", "multiply", [node, new OperatorNode("*", "multiply", [new FunctionNode("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
        }
        if (constNodes[_arg2] !== void 0) {
          if (isConstantNode(_arg2)) {
            if (isZero(_arg2.value)) {
              return createConstantNode2(0);
            }
            if (equal(_arg2.value, 1)) {
              return _derivative(_arg, constNodes);
            }
          }
          var powMinusOne = new OperatorNode("^", "pow", [_arg.clone(), new OperatorNode("-", "subtract", [_arg2, createConstantNode2(1)])]);
          return new OperatorNode("*", "multiply", [_arg2.clone(), new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
        }
        return new OperatorNode("*", "multiply", [new OperatorNode("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode("+", "add", [new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode("log", [_arg.clone()])])])]);
      }
      throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
    }
  });
  function funcArgsCheck(node) {
    if ((node.name === "log" || node.name === "nthRoot" || node.name === "pow") && node.args.length === 2) {
      return;
    }
    for (var i = 0; i < node.args.length; ++i) {
      node.args[i] = createConstantNode2(0);
    }
    node.compile().evaluate();
    throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
  }
  function createConstantNode2(value, valueType) {
    return new ConstantNode(numeric2(value, valueType || config4.number));
  }
  return derivative;
});

// node_modules/mathjs/lib/esm/function/algebra/rationalize.js
var name285 = "rationalize";
var dependencies285 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
var createRationalize = /* @__PURE__ */ factory(name285, dependencies285, (_ref) => {
  var {
    config: config4,
    typed: typed3,
    equal,
    isZero,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    pow: pow3,
    parse,
    simplifyConstant,
    simplifyCore,
    simplify,
    fraction,
    bignumber,
    mathWithTransform,
    matrix,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    SymbolNode,
    ParenthesisNode
  } = _ref;
  function _rationalize(expr) {
    var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var detailed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var setRules = rulesRationalize();
    var polyRet = polynomial(expr, scope, true, setRules.firstRules);
    var nVars = polyRet.variables.length;
    var noExactFractions = {
      exactFractions: false
    };
    var withExactFractions = {
      exactFractions: true
    };
    expr = polyRet.expression;
    if (nVars >= 1) {
      expr = expandPower(expr);
      var sBefore;
      var rules;
      var eDistrDiv = true;
      var redoInic = false;
      expr = simplify(expr, setRules.firstRules, {}, noExactFractions);
      var s2;
      while (true) {
        rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
        expr = simplify(expr, rules, {}, withExactFractions);
        eDistrDiv = !eDistrDiv;
        s2 = expr.toString();
        if (s2 === sBefore) {
          break;
        }
        redoInic = true;
        sBefore = s2;
      }
      if (redoInic) {
        expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);
      }
      expr = simplify(expr, setRules.finalRules, {}, noExactFractions);
    }
    var coefficients = [];
    var retRationalize = {};
    if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
      if (nVars === 1) {
        expr.args[0] = polyToCanonical(expr.args[0], coefficients);
        expr.args[1] = polyToCanonical(expr.args[1]);
      }
      if (detailed) {
        retRationalize.numerator = expr.args[0];
        retRationalize.denominator = expr.args[1];
      }
    } else {
      if (nVars === 1) {
        expr = polyToCanonical(expr, coefficients);
      }
      if (detailed) {
        retRationalize.numerator = expr;
        retRationalize.denominator = null;
      }
    }
    if (!detailed)
      return expr;
    retRationalize.coefficients = coefficients;
    retRationalize.variables = polyRet.variables;
    retRationalize.expression = expr;
    return retRationalize;
  }
  return typed3(name285, {
    Node: _rationalize,
    "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
    "Node, Object": _rationalize,
    "Node, Object, boolean": _rationalize
  });
  function polynomial(expr, scope, extended, rules) {
    var variables = [];
    var node = simplify(expr, rules, scope, {
      exactFractions: false
    });
    extended = !!extended;
    var oper = "+-*" + (extended ? "/" : "");
    recPoly(node);
    var retFunc = {};
    retFunc.expression = node;
    retFunc.variables = variables;
    return retFunc;
    function recPoly(node2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if (node2.op === "^") {
          if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
            throw new Error("There is a non-integer exponent");
          } else {
            recPoly(node2.args[0]);
          }
        } else {
          if (oper.indexOf(node2.op) === -1) {
            throw new Error("Operator " + node2.op + " invalid in polynomial expression");
          }
          for (var i = 0; i < node2.args.length; i++) {
            recPoly(node2.args[i]);
          }
        }
      } else if (tp === "SymbolNode") {
        var _name = node2.name;
        var pos = variables.indexOf(_name);
        if (pos === -1) {
          variables.push(_name);
        }
      } else if (tp === "ParenthesisNode") {
        recPoly(node2.content);
      } else if (tp !== "ConstantNode") {
        throw new Error("type " + tp + " is not allowed in polynomial expression");
      }
    }
  }
  function rulesRationalize() {
    var oldRules = [
      simplifyCore,
      // sCore
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      simplifyConstant,
      // sConstant
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "1*n",
        r: "n"
      }
    ];
    var rulesFirst = [
      {
        l: "(-n1)/(-n2)",
        r: "n1/n2"
      },
      // Unary division
      {
        l: "(-n1)*(-n2)",
        r: "n1*n2"
      },
      // Unary multiplication
      {
        l: "n1--n2",
        r: "n1+n2"
      },
      // '--' elimination
      {
        l: "n1-n2",
        r: "n1+(-n2)"
      },
      // Subtraction turn into add with un�ry minus
      {
        l: "(n1+n2)*n3",
        r: "(n1*n3 + n2*n3)"
      },
      // Distributive 1
      {
        l: "n1*(n2+n3)",
        r: "(n1*n2+n1*n3)"
      },
      // Distributive 2
      {
        l: "c1*n + c2*n",
        r: "(c1+c2)*n"
      },
      // Joining constants
      {
        l: "c1*n + n",
        r: "(c1+1)*n"
      },
      // Joining constants
      {
        l: "c1*n - c2*n",
        r: "(c1-c2)*n"
      },
      // Joining constants
      {
        l: "c1*n - n",
        r: "(c1-1)*n"
      },
      // Joining constants
      {
        l: "v/c",
        r: "(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "v/-c",
        r: "-(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "-v*-c",
        r: "c*v"
      },
      // Inversion constant and variable 1
      {
        l: "-v*c",
        r: "-c*v"
      },
      // Inversion constant and variable 2
      {
        l: "v*-c",
        r: "-c*v"
      },
      // Inversion constant and variable 3
      {
        l: "v*c",
        r: "c*v"
      },
      // Inversion constant and variable 4
      {
        l: "-(-n1*n2)",
        r: "(n1*n2)"
      },
      // Unary propagation
      {
        l: "-(n1*n2)",
        r: "(-n1*n2)"
      },
      // Unary propagation
      {
        l: "-(-n1+n2)",
        r: "(n1-n2)"
      },
      // Unary propagation
      {
        l: "-(n1+n2)",
        r: "(-n1-n2)"
      },
      // Unary propagation
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      },
      // Power to Power
      {
        l: "-(-n1/n2)",
        r: "(n1/n2)"
      },
      // Division and Unary
      {
        l: "-(n1/n2)",
        r: "(-n1/n2)"
      }
    ];
    var rulesDistrDiv = [
      {
        l: "(n1/n2 + n3/n4)",
        r: "((n1*n4 + n3*n2)/(n2*n4))"
      },
      // Sum of fractions
      {
        l: "(n1/n2 + n3)",
        r: "((n1 + n3*n2)/n2)"
      },
      // Sum fraction with number 1
      {
        l: "(n1 + n2/n3)",
        r: "((n1*n3 + n2)/n3)"
      }
    ];
    var rulesSucDiv = [
      {
        l: "(n1/(n2/n3))",
        r: "((n1*n3)/n2)"
      },
      // Division simplification
      {
        l: "(n1/n2/n3)",
        r: "(n1/(n2*n3))"
      }
    ];
    var setRules = {};
    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
    setRules.distrDivRules = rulesDistrDiv;
    setRules.sucDivRules = rulesSucDiv;
    setRules.firstRulesAgain = oldRules.concat(rulesFirst);
    setRules.finalRules = [
      simplifyCore,
      // simplify.rules[0]
      {
        l: "n*-n",
        r: "-n^2"
      },
      // Joining multiply with power 1
      {
        l: "n*n",
        r: "n^2"
      },
      // Joining multiply with power 2
      simplifyConstant,
      // simplify.rules[14] old 3rd index in oldRules
      {
        l: "n*-n^n1",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 3
      {
        l: "n*n^n1",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 4
      {
        l: "n^n1*-n^n2",
        r: "-n^(n1+n2)"
      },
      // Joining multiply with power 5
      {
        l: "n^n1*n^n2",
        r: "n^(n1+n2)"
      },
      // Joining multiply with power 6
      {
        l: "n^n1*-n",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 7
      {
        l: "n^n1*n",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/-n",
        r: "-n^(n1-1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/n",
        r: "n^(n1-1)"
      },
      // Joining division with power 1
      {
        l: "n/-n^n1",
        r: "-n^(1-n1)"
      },
      // Joining division with power 2
      {
        l: "n/n^n1",
        r: "n^(1-n1)"
      },
      // Joining division with power 3
      {
        l: "n^n1/-n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 4
      {
        l: "n^n1/n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 5
      {
        l: "n1+(-n2*n3)",
        r: "n1-n2*n3"
      },
      // Solving useless parenthesis 1
      {
        l: "v*(-c)",
        r: "-c*v"
      },
      // Solving useless unary 2
      {
        l: "n1+-n2",
        r: "n1-n2"
      },
      // Solving +- together (new!)
      {
        l: "v*c",
        r: "c*v"
      },
      // inversion constant with variable
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      }
      // Power to Power
    ];
    return setRules;
  }
  function expandPower(node, parent, indParent) {
    var tp = node.type;
    var internal = arguments.length > 1;
    if (tp === "OperatorNode" && node.isBinary()) {
      var does = false;
      var val;
      if (node.op === "^") {
        if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
          val = parseFloat(node.args[1].value);
          does = val >= 2 && isInteger(val);
        }
      }
      if (does) {
        if (val > 2) {
          var nEsqTopo = node.args[0];
          var nDirTopo = new OperatorNode("^", "pow", [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);
          node = new OperatorNode("*", "multiply", [nEsqTopo, nDirTopo]);
        } else {
          node = new OperatorNode("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
        }
        if (internal) {
          if (indParent === "content") {
            parent.content = node;
          } else {
            parent.args[indParent] = node;
          }
        }
      }
    }
    if (tp === "ParenthesisNode") {
      expandPower(node.content, node, "content");
    } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
      for (var i = 0; i < node.args.length; i++) {
        expandPower(node.args[i], node, i);
      }
    }
    if (!internal) {
      return node;
    }
  }
  function polyToCanonical(node, coefficients) {
    if (coefficients === void 0) {
      coefficients = [];
    }
    coefficients[0] = 0;
    var o = {};
    o.cte = 1;
    o.oper = "+";
    o.fire = "";
    var maxExpo = 0;
    var varname = "";
    recurPol(node, null, o);
    maxExpo = coefficients.length - 1;
    var first = true;
    var no;
    for (var i = maxExpo; i >= 0; i--) {
      if (coefficients[i] === 0)
        continue;
      var n16 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));
      var op = coefficients[i] < 0 ? "-" : "+";
      if (i > 0) {
        var n25 = new SymbolNode(varname);
        if (i > 1) {
          var n3 = new ConstantNode(i);
          n25 = new OperatorNode("^", "pow", [n25, n3]);
        }
        if (coefficients[i] === -1 && first) {
          n16 = new OperatorNode("-", "unaryMinus", [n25]);
        } else if (Math.abs(coefficients[i]) === 1) {
          n16 = n25;
        } else {
          n16 = new OperatorNode("*", "multiply", [n16, n25]);
        }
      }
      if (first) {
        no = n16;
      } else if (op === "+") {
        no = new OperatorNode("+", "add", [no, n16]);
      } else {
        no = new OperatorNode("-", "subtract", [no, n16]);
      }
      first = false;
    }
    if (first) {
      return new ConstantNode(0);
    } else {
      return no;
    }
    function recurPol(node2, noPai, o2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if ("+-*^".indexOf(node2.op) === -1)
          throw new Error("Operator " + node2.op + " invalid");
        if (noPai !== null) {
          if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
            throw new Error("Invalid " + node2.op + " placing");
          }
        }
        if (node2.op === "^" || node2.op === "*") {
          o2.fire = node2.op;
        }
        for (var _i = 0; _i < node2.args.length; _i++) {
          if (node2.fn === "unaryMinus")
            o2.oper = "-";
          if (node2.op === "+" || node2.fn === "subtract") {
            o2.fire = "";
            o2.cte = 1;
            o2.oper = _i === 0 ? "+" : node2.op;
          }
          o2.noFil = _i;
          recurPol(node2.args[_i], node2, o2);
        }
      } else if (tp === "SymbolNode") {
        if (node2.name !== varname && varname !== "") {
          throw new Error("There is more than one variable");
        }
        varname = node2.name;
        if (noPai === null) {
          coefficients[1] = 1;
          return;
        }
        if (noPai.op === "^" && o2.noFil !== 0) {
          throw new Error("In power the variable should be the first parameter");
        }
        if (noPai.op === "*" && o2.noFil !== 1) {
          throw new Error("In multiply the variable should be the second parameter");
        }
        if (o2.fire === "" || o2.fire === "*") {
          if (maxExpo < 1)
            coefficients[1] = 0;
          coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(1, maxExpo);
        }
      } else if (tp === "ConstantNode") {
        var valor = parseFloat(node2.value);
        if (noPai === null) {
          coefficients[0] = valor;
          return;
        }
        if (noPai.op === "^") {
          if (o2.noFil !== 1)
            throw new Error("Constant cannot be powered");
          if (!isInteger(valor) || valor <= 0) {
            throw new Error("Non-integer exponent is not allowed");
          }
          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++)
            coefficients[_i2] = 0;
          if (valor > maxExpo)
            coefficients[valor] = 0;
          coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(valor, maxExpo);
          return;
        }
        o2.cte = valor;
        if (o2.fire === "") {
          coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
        }
      } else {
        throw new Error("Type " + tp + " is not allowed");
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/signal/zpk2tf.js
var name286 = "zpk2tf";
var dependencies286 = ["typed", "add", "multiply", "Complex", "number"];
var createZpk2tf = /* @__PURE__ */ factory(name286, dependencies286, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    multiply,
    Complex: Complex3,
    number: number5
  } = _ref;
  return typed3(name286, {
    "Array,Array,number": function ArrayArrayNumber(z, p, k2) {
      return _zpk2tf(z, p, k2);
    },
    "Array,Array": function ArrayArray(z, p) {
      return _zpk2tf(z, p, 1);
    },
    "Matrix,Matrix,number": function MatrixMatrixNumber(z, p, k2) {
      return _zpk2tf(z.valueOf(), p.valueOf(), k2);
    },
    "Matrix,Matrix": function MatrixMatrix(z, p) {
      return _zpk2tf(z.valueOf(), p.valueOf(), 1);
    }
  });
  function _zpk2tf(z, p, k2) {
    if (z.some((el) => el.type === "BigNumber")) {
      z = z.map((el) => number5(el));
    }
    if (p.some((el) => el.type === "BigNumber")) {
      p = p.map((el) => number5(el));
    }
    var num = [Complex3(1, 0)];
    var den = [Complex3(1, 0)];
    for (var i = 0; i < z.length; i++) {
      var zero3 = z[i];
      if (typeof zero3 === "number")
        zero3 = Complex3(zero3, 0);
      num = _multiply(num, [Complex3(1, 0), Complex3(-zero3.re, -zero3.im)]);
    }
    for (var _i = 0; _i < p.length; _i++) {
      var pole = p[_i];
      if (typeof pole === "number")
        pole = Complex3(pole, 0);
      den = _multiply(den, [Complex3(1, 0), Complex3(-pole.re, -pole.im)]);
    }
    for (var _i2 = 0; _i2 < num.length; _i2++) {
      num[_i2] = multiply(num[_i2], k2);
    }
    return [num, den];
  }
  function _multiply(a2, b) {
    var c2 = [];
    for (var i = 0; i < a2.length + b.length - 1; i++) {
      c2[i] = Complex3(0, 0);
      for (var j = 0; j < a2.length; j++) {
        if (i - j >= 0 && i - j < b.length) {
          c2[i] = add2(c2[i], multiply(a2[j], b[i - j]));
        }
      }
    }
    return c2;
  }
});

// node_modules/mathjs/lib/esm/function/signal/freqz.js
var name287 = "freqz";
var dependencies287 = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
var createFreqz = /* @__PURE__ */ factory(name287, dependencies287, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    multiply,
    Complex: Complex3,
    divide: divide2,
    matrix
  } = _ref;
  return typed3(name287, {
    "Array, Array": function ArrayArray(b, a2) {
      var w = createBins(512);
      return _freqz(b, a2, w);
    },
    "Array, Array, Array": function ArrayArrayArray(b, a2, w) {
      return _freqz(b, a2, w);
    },
    "Array, Array, number": function ArrayArrayNumber(b, a2, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var w2 = createBins(w);
      return _freqz(b, a2, w2);
    },
    "Matrix, Matrix": function MatrixMatrix(b, a2) {
      var _w = createBins(512);
      var {
        w,
        h
      } = _freqz(b.valueOf(), a2.valueOf(), _w);
      return {
        w: matrix(w),
        h: matrix(h)
      };
    },
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(b, a2, w) {
      var {
        h
      } = _freqz(b.valueOf(), a2.valueOf(), w.valueOf());
      return {
        h: matrix(h),
        w: matrix(w)
      };
    },
    "Matrix, Matrix, number": function MatrixMatrixNumber(b, a2, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var _w = createBins(w);
      var {
        h
      } = _freqz(b.valueOf(), a2.valueOf(), _w);
      return {
        h: matrix(h),
        w: matrix(_w)
      };
    }
  });
  function _freqz(b, a2, w) {
    var num = [];
    var den = [];
    for (var i = 0; i < w.length; i++) {
      var sumNum = Complex3(0, 0);
      var sumDen = Complex3(0, 0);
      for (var j = 0; j < b.length; j++) {
        sumNum = add2(sumNum, multiply(b[j], Complex3(Math.cos(-j * w[i]), Math.sin(-j * w[i]))));
      }
      for (var _j = 0; _j < a2.length; _j++) {
        sumDen = add2(sumDen, multiply(a2[_j], Complex3(Math.cos(-_j * w[i]), Math.sin(-_j * w[i]))));
      }
      num.push(sumNum);
      den.push(sumDen);
    }
    var h = [];
    for (var _i = 0; _i < num.length; _i++) {
      h.push(divide2(num[_i], den[_i]));
    }
    return {
      h,
      w
    };
  }
  function createBins(n) {
    var bins = [];
    for (var i = 0; i < n; i++) {
      bins.push(i / n * Math.PI);
    }
    return bins;
  }
});

// node_modules/mathjs/lib/esm/json/reviver.js
var name288 = "reviver";
var dependencies288 = ["classes"];
var createReviver = /* @__PURE__ */ factory(name288, dependencies288, (_ref) => {
  var {
    classes
  } = _ref;
  return function reviver(key, value) {
    var constructor = classes[value && value.mathjs];
    if (constructor && typeof constructor.fromJSON === "function") {
      return constructor.fromJSON(value);
    }
    return value;
  };
});

// node_modules/mathjs/lib/esm/json/replacer.js
var name289 = "replacer";
var dependencies289 = [];
var createReplacer = /* @__PURE__ */ factory(name289, dependencies289, () => {
  return function replacer(key, value) {
    if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
      return {
        mathjs: "number",
        value: String(value)
      };
    }
    return value;
  };
});

// node_modules/mathjs/lib/esm/version.js
var version = "11.12.0";

// node_modules/mathjs/lib/esm/constants.js
var createTrue = /* @__PURE__ */ factory("true", [], () => true);
var createFalse = /* @__PURE__ */ factory("false", [], () => false);
var createNull = /* @__PURE__ */ factory("null", [], () => null);
var createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref;
  return config4.number === "BigNumber" ? new BigNumber2(Infinity) : Infinity;
});
var createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref2;
  return config4.number === "BigNumber" ? new BigNumber2(NaN) : NaN;
});
var createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref3;
  return config4.number === "BigNumber" ? createBigNumberPi(BigNumber2) : pi;
});
var createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref4;
  return config4.number === "BigNumber" ? createBigNumberTau(BigNumber2) : tau;
});
var createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref5;
  return config4.number === "BigNumber" ? createBigNumberE(BigNumber2) : e;
});
var createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref6;
  return config4.number === "BigNumber" ? createBigNumberPhi(BigNumber2) : phi;
});
var createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref7;
  return config4.number === "BigNumber" ? new BigNumber2(2).ln() : Math.LN2;
});
var createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref8;
  return config4.number === "BigNumber" ? new BigNumber2(10).ln() : Math.LN10;
});
var createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref9;
  return config4.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(2).ln()) : Math.LOG2E;
});
var createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref10;
  return config4.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(10).ln()) : Math.LOG10E;
});
var createSQRT1_2 = /* @__PURE__ */ recreateFactory(
  // eslint-disable-line camelcase
  "SQRT1_2",
  ["config", "?BigNumber"],
  (_ref11) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref11;
    return config4.number === "BigNumber" ? new BigNumber2("0.5").sqrt() : Math.SQRT1_2;
  }
);
var createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
  var {
    config: config4,
    BigNumber: BigNumber2
  } = _ref12;
  return config4.number === "BigNumber" ? new BigNumber2(2).sqrt() : Math.SQRT2;
});
var createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
  var {
    Complex: Complex3
  } = _ref13;
  return Complex3.I;
});
var createUppercasePi = /* @__PURE__ */ factory("PI", ["pi"], (_ref14) => {
  var {
    pi: pi4
  } = _ref14;
  return pi4;
});
var createUppercaseE = /* @__PURE__ */ factory("E", ["e"], (_ref15) => {
  var {
    e: e3
  } = _ref15;
  return e3;
});
var createVersion = /* @__PURE__ */ factory("version", [], () => version);
function recreateFactory(name310, dependencies310, create3) {
  return factory(name310, dependencies310, create3, {
    recreateOnConfigChange: true
  });
}

// node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
var createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
var createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
var createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
var createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
var createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
var createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
var createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
var createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
var createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
var createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
var createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
var createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
var createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
var createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
var createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
var createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
var createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
var createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
var createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
var createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
var createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
var createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
var createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
var createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
var createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
var createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
var createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
var createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
var createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
var createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
var createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
var createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
var createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
var createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
var createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
var createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
var createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
var createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
var createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
var createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
var createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
var createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
var createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
function unitFactory(name310, valueStr, unitStr) {
  var dependencies310 = ["config", "Unit", "BigNumber"];
  return factory(name310, dependencies310, (_ref) => {
    var {
      config: config4,
      Unit,
      BigNumber: BigNumber2
    } = _ref;
    var value = config4.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
    var unit2 = new Unit(value, unitStr);
    unit2.fixPrefix = true;
    return unit2;
  });
}
function numberFactory(name310, value) {
  var dependencies310 = ["config", "BigNumber"];
  return factory(name310, dependencies310, (_ref2) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref2;
    return config4.number === "BigNumber" ? new BigNumber2(value) : value;
  });
}

// node_modules/mathjs/lib/esm/expression/transform/apply.transform.js
var name290 = "apply";
var dependencies290 = ["typed", "isInteger"];
var createApplyTransform = /* @__PURE__ */ factory(name290, dependencies290, (_ref) => {
  var {
    typed: typed3,
    isInteger: isInteger2
  } = _ref;
  var apply = createApply({
    typed: typed3,
    isInteger: isInteger2
  });
  return typed3("apply", {
    "...any": function any(args) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
      try {
        return apply.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/column.transform.js
var name291 = "column";
var dependencies291 = ["typed", "Index", "matrix", "range"];
var createColumnTransform = /* @__PURE__ */ factory(name291, dependencies291, (_ref) => {
  var {
    typed: typed3,
    Index,
    matrix,
    range: range2
  } = _ref;
  var column = createColumn({
    typed: typed3,
    Index,
    matrix,
    range: range2
  });
  return typed3("column", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return column.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
function compileInlineExpression(expression, math, scope) {
  var symbol = expression.filter(function(node) {
    return isSymbolNode(node) && !(node.name in math) && !scope.has(node.name);
  })[0];
  if (!symbol) {
    throw new Error('No undefined variable found in inline expression "' + expression + '"');
  }
  var name310 = symbol.name;
  var subScope = createSubScope(scope);
  var eq = expression.compile();
  return function inlineExpression(x2) {
    subScope.set(name310, x2);
    return eq.evaluate(subScope);
  };
}

// node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
var name292 = "filter";
var dependencies292 = ["typed"];
var createFilterTransform = /* @__PURE__ */ factory(name292, dependencies292, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  function filterTransform(args, math, scope) {
    var x2, callback;
    if (args[0]) {
      x2 = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math, scope);
      }
    }
    return filter3(x2, callback);
  }
  filterTransform.rawArgs = true;
  var filter3 = typed3("filter", {
    "Array, function": _filter,
    "Matrix, function": function MatrixFunction(x2, test) {
      return x2.create(_filter(x2.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x2, test) {
      return x2.create(filterRegExp(x2.toArray(), test));
    }
  });
  return filterTransform;
}, {
  isTransformFunction: true
});
function _filter(x2, callback) {
  return filter(x2, function(value, index, array2) {
    return applyCallback(callback, value, [index + 1], array2, "filter");
  });
}

// node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
var name293 = "forEach";
var dependencies293 = ["typed"];
var createForEachTransform = /* @__PURE__ */ factory(name293, dependencies293, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  function forEachTransform(args, math, scope) {
    var x2, callback;
    if (args[0]) {
      x2 = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math, scope);
      }
    }
    return _forEach2(x2, callback);
  }
  forEachTransform.rawArgs = true;
  var _forEach2 = typed3("forEach", {
    "Array | Matrix, function": function ArrayMatrixFunction(array2, callback) {
      var recurse = function recurse2(value, index) {
        if (Array.isArray(value)) {
          forEach(value, function(child, i) {
            recurse2(child, index.concat(i + 1));
          });
        } else {
          return applyCallback(callback, value, index, array2, "forEach");
        }
      };
      recurse(array2.valueOf(), []);
    }
  });
  return forEachTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/index.transform.js
var name294 = "index";
var dependencies294 = ["Index", "getMatrixDataType"];
var createIndexTransform = /* @__PURE__ */ factory(name294, dependencies294, (_ref) => {
  var {
    Index,
    getMatrixDataType
  } = _ref;
  return function indexTransform() {
    var args = [];
    for (var i = 0, ii = arguments.length; i < ii; i++) {
      var arg = arguments[i];
      if (isRange(arg)) {
        arg.start--;
        arg.end -= arg.step > 0 ? 0 : 2;
      } else if (arg && arg.isSet === true) {
        arg = arg.map(function(v) {
          return v - 1;
        });
      } else if (isArray(arg) || isMatrix(arg)) {
        if (getMatrixDataType(arg) !== "boolean") {
          arg = arg.map(function(v) {
            return v - 1;
          });
        }
      } else if (isNumber(arg)) {
        arg--;
      } else if (isBigNumber(arg)) {
        arg = arg.toNumber() - 1;
      } else if (typeof arg === "string") {
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      args[i] = arg;
    }
    var res = new Index();
    Index.apply(res, args);
    return res;
  };
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/map.transform.js
var name295 = "map";
var dependencies295 = ["typed"];
var createMapTransform = /* @__PURE__ */ factory(name295, dependencies295, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  function mapTransform(args, math, scope) {
    var x2, callback;
    if (args[0]) {
      x2 = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math, scope);
      }
    }
    return map3(x2, callback);
  }
  mapTransform.rawArgs = true;
  var map3 = typed3("map", {
    "Array, function": function ArrayFunction(x2, callback) {
      return _map2(x2, callback, x2);
    },
    "Matrix, function": function MatrixFunction(x2, callback) {
      return x2.create(_map2(x2.valueOf(), callback, x2));
    }
  });
  return mapTransform;
}, {
  isTransformFunction: true
});
function _map2(array2, callback, orig) {
  function recurse(value, index) {
    if (Array.isArray(value)) {
      return map(value, function(child, i) {
        return recurse(child, index.concat(i + 1));
      });
    } else {
      return applyCallback(callback, value, index, orig, "map");
    }
  }
  return recurse(array2, []);
}

// node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
function lastDimToZeroBase(args) {
  if (args.length === 2 && isCollection(args[0])) {
    args = args.slice();
    var dim = args[1];
    if (isNumber(dim)) {
      args[1] = dim - 1;
    } else if (isBigNumber(dim)) {
      args[1] = dim.minus(1);
    }
  }
  return args;
}

// node_modules/mathjs/lib/esm/expression/transform/max.transform.js
var name296 = "max";
var dependencies296 = ["typed", "config", "numeric", "larger"];
var createMaxTransform = /* @__PURE__ */ factory(name296, dependencies296, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    numeric: numeric2,
    larger
  } = _ref;
  var max4 = createMax({
    typed: typed3,
    config: config4,
    numeric: numeric2,
    larger
  });
  return typed3("max", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return max4.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
var name297 = "mean";
var dependencies297 = ["typed", "add", "divide"];
var createMeanTransform = /* @__PURE__ */ factory(name297, dependencies297, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    divide: divide2
  } = _ref;
  var mean = createMean({
    typed: typed3,
    add: add2,
    divide: divide2
  });
  return typed3("mean", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return mean.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/min.transform.js
var name298 = "min";
var dependencies298 = ["typed", "config", "numeric", "smaller"];
var createMinTransform = /* @__PURE__ */ factory(name298, dependencies298, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    numeric: numeric2,
    smaller
  } = _ref;
  var min4 = createMin({
    typed: typed3,
    config: config4,
    numeric: numeric2,
    smaller
  });
  return typed3("min", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return min4.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/range.transform.js
var name299 = "range";
var dependencies299 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
var createRangeTransform = /* @__PURE__ */ factory(name299, dependencies299, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    matrix,
    bignumber,
    smaller,
    smallerEq,
    larger,
    largerEq,
    add: add2,
    isPositive
  } = _ref;
  var range2 = createRange({
    typed: typed3,
    config: config4,
    matrix,
    bignumber,
    smaller,
    smallerEq,
    larger,
    largerEq,
    add: add2,
    isPositive
  });
  return typed3("range", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last !== "boolean") {
        args.push(true);
      }
      return range2.apply(null, args);
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/row.transform.js
var name300 = "row";
var dependencies300 = ["typed", "Index", "matrix", "range"];
var createRowTransform = /* @__PURE__ */ factory(name300, dependencies300, (_ref) => {
  var {
    typed: typed3,
    Index,
    matrix,
    range: range2
  } = _ref;
  var row = createRow({
    typed: typed3,
    Index,
    matrix,
    range: range2
  });
  return typed3("row", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return row.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
var name301 = "subset";
var dependencies301 = ["typed", "matrix", "zeros", "add"];
var createSubsetTransform = /* @__PURE__ */ factory(name301, dependencies301, (_ref) => {
  var {
    typed: typed3,
    matrix,
    zeros: zeros2,
    add: add2
  } = _ref;
  var subset = createSubset({
    typed: typed3,
    matrix,
    zeros: zeros2,
    add: add2
  });
  return typed3("subset", {
    "...any": function any(args) {
      try {
        return subset.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
var name302 = "concat";
var dependencies302 = ["typed", "matrix", "isInteger"];
var createConcatTransform = /* @__PURE__ */ factory(name302, dependencies302, (_ref) => {
  var {
    typed: typed3,
    matrix,
    isInteger: isInteger2
  } = _ref;
  var concat2 = createConcat({
    typed: typed3,
    matrix,
    isInteger: isInteger2
  });
  return typed3("concat", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      } else if (isBigNumber(last)) {
        args[lastIndex] = last.minus(1);
      }
      try {
        return concat2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
var name303 = "diff";
var dependencies303 = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = /* @__PURE__ */ factory(name303, dependencies303, (_ref) => {
  var {
    typed: typed3,
    matrix,
    subtract,
    number: number5,
    bignumber
  } = _ref;
  var diff = createDiff({
    typed: typed3,
    matrix,
    subtract,
    number: number5,
    bignumber
  });
  return typed3(name303, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return diff.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/std.transform.js
var name304 = "std";
var dependencies304 = ["typed", "map", "sqrt", "variance"];
var createStdTransform = /* @__PURE__ */ factory(name304, dependencies304, (_ref) => {
  var {
    typed: typed3,
    map: map3,
    sqrt: sqrt5,
    variance
  } = _ref;
  var std = createStd({
    typed: typed3,
    map: map3,
    sqrt: sqrt5,
    variance
  });
  return typed3("std", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return std.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
var name305 = "sum";
var dependencies305 = ["typed", "config", "add", "numeric"];
var createSumTransform = /* @__PURE__ */ factory(name305, dependencies305, (_ref) => {
  var {
    typed: typed3,
    config: config4,
    add: add2,
    numeric: numeric2
  } = _ref;
  var sum3 = createSum({
    typed: typed3,
    config: config4,
    add: add2,
    numeric: numeric2
  });
  return typed3(name305, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return sum3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/quantileSeq.transform.js
var name306 = "quantileSeq";
var dependencies306 = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
var createQuantileSeqTransform = /* @__PURE__ */ factory(name306, dependencies306, (_ref) => {
  var {
    typed: typed3,
    bignumber,
    add: add2,
    subtract,
    divide: divide2,
    multiply,
    partitionSelect,
    compare,
    isInteger: isInteger2,
    smaller,
    smallerEq,
    larger
  } = _ref;
  var quantileSeq = createQuantileSeq({
    typed: typed3,
    bignumber,
    add: add2,
    subtract,
    divide: divide2,
    multiply,
    partitionSelect,
    compare,
    isInteger: isInteger2,
    smaller,
    smallerEq,
    larger
  });
  return typed3("quantileSeq", {
    "Array | Matrix, number | BigNumber": quantileSeq,
    "Array | Matrix, number | BigNumber, number": (arr, prob, dim) => quantileSeq(arr, prob, dimToZeroBase(dim)),
    "Array | Matrix, number | BigNumber, boolean": quantileSeq,
    "Array | Matrix, number | BigNumber, boolean, number": (arr, prob, sorted, dim) => quantileSeq(arr, prob, sorted, dimToZeroBase(dim)),
    "Array | Matrix, Array | Matrix": quantileSeq,
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => quantileSeq(data, prob, dimToZeroBase(dim)),
    "Array | Matrix, Array | Matrix, boolean": quantileSeq,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => quantileSeq(data, prob, sorted, dimToZeroBase(dim))
  });
  function dimToZeroBase(dim) {
    return lastDimToZeroBase([[], dim])[1];
  }
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js
var name307 = "cumsum";
var dependencies307 = ["typed", "add", "unaryPlus"];
var createCumSumTransform = /* @__PURE__ */ factory(name307, dependencies307, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    unaryPlus
  } = _ref;
  var cumsum = createCumSum({
    typed: typed3,
    add: add2,
    unaryPlus
  });
  return typed3(name307, {
    "...any": function any(args) {
      if (args.length === 2 && isCollection(args[0])) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
      }
      try {
        return cumsum.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
var name308 = "variance";
var dependencies308 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVarianceTransform = /* @__PURE__ */ factory(name308, dependencies308, (_ref) => {
  var {
    typed: typed3,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    apply,
    isNaN: isNaN2
  } = _ref;
  var variance = createVariance({
    typed: typed3,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    apply,
    isNaN: isNaN2
  });
  return typed3(name308, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return variance.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/print.transform.js
var name309 = "print";
var dependencies309 = ["typed", "matrix", "zeros", "add"];
var createPrintTransform = /* @__PURE__ */ factory(name309, dependencies309, (_ref) => {
  var {
    typed: typed3,
    matrix,
    zeros: zeros2,
    add: add2
  } = _ref;
  var print = createPrint({
    typed: typed3,
    matrix,
    zeros: zeros2,
    add: add2
  });
  return typed3(name309, {
    "string, Object | Array": function stringObjectArray(template, values2) {
      return print(_convertTemplateToZeroBasedIndex(template), values2);
    },
    "string, Object | Array, number | Object": function stringObjectArrayNumberObject(template, values2, options) {
      return print(_convertTemplateToZeroBasedIndex(template), values2, options);
    }
  });
  function _convertTemplateToZeroBasedIndex(template) {
    return template.replace(printTemplate, (x2) => {
      var parts = x2.slice(1).split(".");
      var result = parts.map(function(part) {
        if (!isNaN(part) && part.length > 0) {
          return parseInt(part) - 1;
        } else {
          return part;
        }
      });
      return "$" + result.join(".");
    });
  }
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
var BigNumber = /* @__PURE__ */ createBigNumberClass({
  config
});
var Complex2 = /* @__PURE__ */ createComplexClass({});
var Fraction2 = /* @__PURE__ */ createFractionClass({});
var Matrix = /* @__PURE__ */ createMatrixClass({});
var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
  Matrix
});
var typed2 = /* @__PURE__ */ createTyped({
  BigNumber,
  Complex: Complex2,
  DenseMatrix,
  Fraction: Fraction2
});
var format4 = /* @__PURE__ */ createFormat({
  typed: typed2
});

// node_modules/mathjs/lib/esm/entry/allFactoriesAny.js
var all = factoriesAny_exports;

// node_modules/mathjs/lib/esm/core/create.js
var import_typed_function3 = __toESM(require_typed_function(), 1);

// node_modules/mathjs/lib/esm/utils/emitter.js
var import_tiny_emitter = __toESM(require_tiny_emitter(), 1);
function mixin(obj) {
  var emitter = new import_tiny_emitter.default();
  obj.on = emitter.on.bind(emitter);
  obj.off = emitter.off.bind(emitter);
  obj.once = emitter.once.bind(emitter);
  obj.emit = emitter.emit.bind(emitter);
  return obj;
}

// node_modules/mathjs/lib/esm/core/function/import.js
function importFactory(typed3, load, math, importedFactories) {
  function mathImport(functions, options) {
    var num = arguments.length;
    if (num !== 1 && num !== 2) {
      throw new ArgumentsError("import", num, 1, 2);
    }
    if (!options) {
      options = {};
    }
    function flattenImports(flatValues2, value2, name311) {
      if (Array.isArray(value2)) {
        value2.forEach((item) => flattenImports(flatValues2, item));
      } else if (typeof value2 === "object") {
        for (var _name in value2) {
          if (hasOwnProperty(value2, _name)) {
            flattenImports(flatValues2, value2[_name], _name);
          }
        }
      } else if (isFactory(value2) || name311 !== void 0) {
        var flatName = isFactory(value2) ? isTransformFunctionFactory(value2) ? value2.fn + ".transform" : value2.fn : name311;
        if (hasOwnProperty(flatValues2, flatName) && flatValues2[flatName] !== value2 && !options.silent) {
          throw new Error('Cannot import "' + flatName + '" twice');
        }
        flatValues2[flatName] = value2;
      } else {
        if (!options.silent) {
          throw new TypeError("Factory, Object, or Array expected");
        }
      }
    }
    var flatValues = {};
    flattenImports(flatValues, functions);
    for (var name310 in flatValues) {
      if (hasOwnProperty(flatValues, name310)) {
        var value = flatValues[name310];
        if (isFactory(value)) {
          _importFactory(value, options);
        } else if (isSupportedType(value)) {
          _import(name310, value, options);
        } else {
          if (!options.silent) {
            throw new TypeError("Factory, Object, or Array expected");
          }
        }
      }
    }
  }
  function _import(name310, value, options) {
    if (options.wrap && typeof value === "function") {
      value = _wrap(value);
    }
    if (hasTypedFunctionSignature(value)) {
      value = typed3(name310, {
        [value.signature]: value
      });
    }
    if (typed3.isTypedFunction(math[name310]) && typed3.isTypedFunction(value)) {
      if (options.override) {
        value = typed3(name310, value.signatures);
      } else {
        value = typed3(math[name310], value);
      }
      math[name310] = value;
      delete importedFactories[name310];
      _importTransform(name310, value);
      math.emit("import", name310, function resolver() {
        return value;
      });
      return;
    }
    if (math[name310] === void 0 || options.override) {
      math[name310] = value;
      delete importedFactories[name310];
      _importTransform(name310, value);
      math.emit("import", name310, function resolver() {
        return value;
      });
      return;
    }
    if (!options.silent) {
      throw new Error('Cannot import "' + name310 + '": already exists');
    }
  }
  function _importTransform(name310, value) {
    if (value && typeof value.transform === "function") {
      math.expression.transform[name310] = value.transform;
      if (allowedInExpressions(name310)) {
        math.expression.mathWithTransform[name310] = value.transform;
      }
    } else {
      delete math.expression.transform[name310];
      if (allowedInExpressions(name310)) {
        math.expression.mathWithTransform[name310] = value;
      }
    }
  }
  function _deleteTransform(name310) {
    delete math.expression.transform[name310];
    if (allowedInExpressions(name310)) {
      math.expression.mathWithTransform[name310] = math[name310];
    } else {
      delete math.expression.mathWithTransform[name310];
    }
  }
  function _wrap(fn) {
    var wrapper = function wrapper2() {
      var args = [];
      for (var i = 0, len = arguments.length; i < len; i++) {
        var arg = arguments[i];
        args[i] = arg && arg.valueOf();
      }
      return fn.apply(math, args);
    };
    if (fn.transform) {
      wrapper.transform = fn.transform;
    }
    return wrapper;
  }
  function _importFactory(factory2, options) {
    var name310 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : factory2.fn;
    if (contains2(name310, ".")) {
      throw new Error("Factory name should not contain a nested path. Name: " + JSON.stringify(name310));
    }
    var namespace = isTransformFunctionFactory(factory2) ? math.expression.transform : math;
    var existingTransform = name310 in math.expression.transform;
    var existing = hasOwnProperty(namespace, name310) ? namespace[name310] : void 0;
    var resolver = function resolver2() {
      var dependencies310 = {};
      factory2.dependencies.map(stripOptionalNotation).forEach((dependency) => {
        if (contains2(dependency, ".")) {
          throw new Error("Factory dependency should not contain a nested path. Name: " + JSON.stringify(dependency));
        }
        if (dependency === "math") {
          dependencies310.math = math;
        } else if (dependency === "mathWithTransform") {
          dependencies310.mathWithTransform = math.expression.mathWithTransform;
        } else if (dependency === "classes") {
          dependencies310.classes = math;
        } else {
          dependencies310[dependency] = math[dependency];
        }
      });
      var instance = /* @__PURE__ */ factory2(dependencies310);
      if (instance && typeof instance.transform === "function") {
        throw new Error('Transforms cannot be attached to factory functions. Please create a separate function for it with exports.path="expression.transform"');
      }
      if (existing === void 0 || options.override) {
        return instance;
      }
      if (typed3.isTypedFunction(existing) && typed3.isTypedFunction(instance)) {
        return typed3(existing, instance);
      }
      if (options.silent) {
        return existing;
      } else {
        throw new Error('Cannot import "' + name310 + '": already exists');
      }
    };
    if (!factory2.meta || factory2.meta.lazy !== false) {
      lazy(namespace, name310, resolver);
      if (existing && existingTransform) {
        _deleteTransform(name310);
      } else {
        if (isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2)) {
          lazy(math.expression.mathWithTransform, name310, () => namespace[name310]);
        }
      }
    } else {
      namespace[name310] = resolver();
      if (existing && existingTransform) {
        _deleteTransform(name310);
      } else {
        if (isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2)) {
          lazy(math.expression.mathWithTransform, name310, () => namespace[name310]);
        }
      }
    }
    importedFactories[name310] = factory2;
    math.emit("import", name310, resolver);
  }
  function isSupportedType(object) {
    return typeof object === "function" || typeof object === "number" || typeof object === "string" || typeof object === "boolean" || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);
  }
  function hasTypedFunctionSignature(fn) {
    return typeof fn === "function" && typeof fn.signature === "string";
  }
  function allowedInExpressions(name310) {
    return !hasOwnProperty(unsafe, name310);
  }
  function factoryAllowedInExpressions(factory2) {
    return factory2.fn.indexOf(".") === -1 && // FIXME: make checking on path redundant, check on meta data instead
    !hasOwnProperty(unsafe, factory2.fn) && (!factory2.meta || !factory2.meta.isClass);
  }
  function isTransformFunctionFactory(factory2) {
    return factory2 !== void 0 && factory2.meta !== void 0 && factory2.meta.isTransformFunction === true || false;
  }
  var unsafe = {
    expression: true,
    type: true,
    docs: true,
    error: true,
    json: true,
    chain: true
    // chain method not supported. Note that there is a unit chain too.
  };
  return mathImport;
}

// node_modules/mathjs/lib/esm/core/create.js
function create(factories, config4) {
  var configInternal = _extends({}, DEFAULT_CONFIG, config4);
  if (typeof Object.create !== "function") {
    throw new Error("ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility.");
  }
  var math = mixin({
    // only here for backward compatibility for legacy factory functions
    isNumber,
    isComplex,
    isBigNumber,
    isFraction,
    isUnit,
    isString,
    isArray,
    isMatrix,
    isCollection,
    isDenseMatrix,
    isSparseMatrix,
    isRange,
    isIndex,
    isBoolean,
    isResultSet,
    isHelp,
    isFunction,
    isDate,
    isRegExp,
    isObject,
    isNull,
    isUndefined,
    isAccessorNode,
    isArrayNode,
    isAssignmentNode,
    isBlockNode,
    isConditionalNode,
    isConstantNode,
    isFunctionAssignmentNode,
    isFunctionNode,
    isIndexNode,
    isNode,
    isObjectNode,
    isOperatorNode,
    isParenthesisNode,
    isRangeNode,
    isRelationalNode,
    isSymbolNode,
    isChain
  });
  math.config = configFactory(configInternal, math.emit);
  math.expression = {
    transform: {},
    mathWithTransform: {
      config: math.config
    }
  };
  var legacyFactories = [];
  var legacyInstances = [];
  function load(factory2) {
    if (isFactory(factory2)) {
      return factory2(math);
    }
    var firstProperty = factory2[Object.keys(factory2)[0]];
    if (isFactory(firstProperty)) {
      return firstProperty(math);
    }
    if (!isLegacyFactory(factory2)) {
      console.warn("Factory object with properties `type`, `name`, and `factory` expected", factory2);
      throw new Error("Factory object with properties `type`, `name`, and `factory` expected");
    }
    var index = legacyFactories.indexOf(factory2);
    var instance;
    if (index === -1) {
      if (factory2.math === true) {
        instance = factory2.factory(math.type, configInternal, load, math.typed, math);
      } else {
        instance = factory2.factory(math.type, configInternal, load, math.typed);
      }
      legacyFactories.push(factory2);
      legacyInstances.push(instance);
    } else {
      instance = legacyInstances[index];
    }
    return instance;
  }
  var importedFactories = {};
  function lazyTyped() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return math.typed.apply(math.typed, args);
  }
  lazyTyped.isTypedFunction = import_typed_function3.default.isTypedFunction;
  var internalImport = importFactory(lazyTyped, load, math, importedFactories);
  math.import = internalImport;
  math.on("config", () => {
    values(importedFactories).forEach((factory2) => {
      if (factory2 && factory2.meta && factory2.meta.recreateOnConfigChange) {
        internalImport(factory2, {
          override: true
        });
      }
    });
  });
  math.create = create.bind(null, factories);
  math.factory = factory;
  math.import(values(deepFlatten(factories)));
  math.ArgumentsError = ArgumentsError;
  math.DimensionError = DimensionError;
  math.IndexError = IndexError;
  return math;
}

// main.ts
var import_function_plot = __toESM(require_dist2());
var EnhancedMathPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.variables = {};
    this.history = [];
  }
  async onload() {
    console.log("Loading Enhanced Math Plugin");
    this.mathInstance = create(all);
    this.mathInstance.import({
      hello: function(name310) {
        return `Hello, ${name310}!`;
      }
    }, { override: true });
    this.registerMarkdownCodeBlockProcessor("math", this.mathProcessor.bind(this));
    this.registerMarkdownCodeBlockProcessor("graph", this.graphProcessor.bind(this));
    this.registerMarkdownPostProcessor(this.inlineProcessor.bind(this));
    this.addRibbonIcon("calculator", "Math Plugin", (evt) => {
      this.showHistory();
    });
    this.addCommand({
      id: "insert-math-block",
      name: "Insert Math Block",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        editor.replaceRange("```math\n\n```", cursor);
        editor.setCursor({ line: cursor.line + 1, ch: 0 });
        new import_obsidian.Notice("Math block inserted");
      }
    });
    this.addCommand({
      id: "insert-graph-block",
      name: "Insert Graph Block",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        editor.replaceRange("```graph\nf(x) = x^2\nxRange: [-5, 5]\nyRange: [0, 25]\n```", cursor);
        editor.setCursor({ line: cursor.line + 1, ch: 0 });
        new import_obsidian.Notice("Graph block inserted");
      }
    });
    this.addCommand({
      id: "insert-equation-block",
      name: "Insert Equation Solving Block",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        editor.replaceRange("```math\nsolve(x + 5 = 10)\n```", cursor);
        editor.setCursor({ line: cursor.line + 1, ch: 0 });
        new import_obsidian.Notice("Equation solving block inserted");
      }
    });
    this.addCommand({
      id: "show-calculation-history",
      name: "Show Calculation History",
      callback: () => {
        this.showHistory();
        new import_obsidian.Notice("Showing calculation history");
      }
    });
    this.addCommand({
      id: "clear-variables",
      name: "Clear Stored Variables",
      callback: () => {
        this.variables = {};
        new import_obsidian.Notice("Cleared all stored variables");
      }
    });
    this.addCommand({
      id: "insert-inline-calculation",
      name: "Insert Inline Calculation",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        editor.replaceRange("((  ))", cursor);
        editor.setCursor({ line: cursor.line, ch: cursor.ch + 2 });
        new import_obsidian.Notice("Inline calculation inserted");
      }
    });
  }
  onunload() {
    console.log("Unloading Enhanced Math Plugin");
  }
  mathProcessor(source, el, ctx) {
    const mathExpressions = source.split("\n").filter((line) => line.trim() !== "");
    const resultElement = document.createElement("div");
    resultElement.classList.add("math-result");
    mathExpressions.forEach((expr, index) => {
      const lineElement = document.createElement("div");
      lineElement.classList.add("math-line");
      const exprElement = document.createElement("span");
      exprElement.textContent = expr;
      lineElement.appendChild(exprElement);
      if (expr.trim() !== "") {
        try {
          let result;
          if (expr.startsWith("solve(") && expr.endsWith(")")) {
            result = this.solveEquation(expr);
          } else {
            result = this.mathInstance.evaluate(expr, this.variables);
          }
          if (expr.includes("=") && !expr.startsWith("solve(")) {
            const [varName] = expr.split("=");
            this.variables[varName.trim()] = result;
          }
          const resultSpan = document.createElement("span");
          resultSpan.textContent = ` ${this.formatResult(result)}`;
          resultSpan.style.color = "green";
          lineElement.appendChild(resultSpan);
          this.history.push(`${expr} = ${this.formatResult(result)}`);
        } catch (error) {
          const errorSpan = document.createElement("span");
          errorSpan.textContent = ` Error: ${error instanceof Error ? error.message : "Unknown error"}`;
          errorSpan.style.color = "red";
          lineElement.appendChild(errorSpan);
        }
      }
      resultElement.appendChild(lineElement);
    });
    el.appendChild(resultElement);
  }
  graphProcessor(source, el, ctx) {
    const graphData = source.split("\n");
    const graphElement = document.createElement("div");
    graphElement.classList.add("math-graph");
    graphElement.style.width = "100%";
    graphElement.style.height = "400px";
    try {
      const funcLine = graphData.find((line) => line.startsWith("f(x)"));
      const xRangeLine = graphData.find((line) => line.startsWith("xRange"));
      const yRangeLine = graphData.find((line) => line.startsWith("yRange"));
      if (!funcLine || !xRangeLine || !yRangeLine) {
        throw new Error("Missing required graph parameters");
      }
      const func = funcLine.split("=")[1].trim();
      const xRange = JSON.parse(xRangeLine.split(":")[1].trim());
      const yRange = JSON.parse(yRangeLine.split(":")[1].trim());
      (0, import_function_plot.default)({
        target: graphElement,
        width: graphElement.clientWidth,
        height: graphElement.clientHeight,
        yAxis: { domain: yRange },
        xAxis: { domain: xRange },
        data: [{
          fn: func,
          graphType: "polyline"
        }]
      });
    } catch (error) {
      graphElement.textContent = `Error creating graph: ${error instanceof Error ? error.message : "Unknown error"}`;
      graphElement.style.color = "red";
    }
    el.appendChild(graphElement);
  }
  inlineProcessor(el, ctx) {
    const textNodes = this.getTextNodes(el);
    textNodes.forEach((node) => {
      const text = node.textContent;
      if (text) {
        const regex = /\(\((.*?)\)\)/g;
        let match;
        let lastIndex = 0;
        const fragments = [];
        while ((match = regex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragments.push(document.createTextNode(text.slice(lastIndex, match.index)));
          }
          const expression = match[1].trim();
          try {
            const result = this.mathInstance.evaluate(expression, this.variables);
            const resultNode = document.createElement("span");
            resultNode.addClass("math-inline-result");
            resultNode.textContent = `${expression} = ${this.formatResult(result)}`;
            fragments.push(resultNode);
            this.history.push(`${expression} = ${this.formatResult(result)}`);
          } catch (error) {
            const errorNode = document.createElement("span");
            errorNode.addClass("math-inline-error");
            errorNode.textContent = `Error in "${expression}": ${error instanceof Error ? error.message : "Unknown error"}`;
            fragments.push(errorNode);
          }
          lastIndex = regex.lastIndex;
        }
        if (lastIndex < text.length) {
          fragments.push(document.createTextNode(text.slice(lastIndex)));
        }
        if (fragments.length > 0) {
          const parent = node.parentNode;
          if (parent) {
            fragments.forEach((fragment) => parent.insertBefore(fragment, node));
            parent.removeChild(node);
          } else {
            console.error("Parent node is null, cannot replace inline calculation");
          }
        }
      }
    });
  }
  getTextNodes(node) {
    const textNodes = [];
    const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null);
    let currentNode;
    while (currentNode = walker.nextNode()) {
      textNodes.push(currentNode);
    }
    return textNodes;
  }
  solveEquation(expr) {
    const equation = expr.slice(6, -1);
    try {
      const [left2, right2] = equation.split("=").map((side) => side.trim());
      const rearrangedEquation = this.mathInstance.parse(`(${left2}) - (${right2})`);
      const simplifiedEquation = this.mathInstance.simplify(rearrangedEquation);
      const coefficients = this.extractCoefficients(simplifiedEquation);
      const solution = this.solveLinearEquation(coefficients.a, coefficients.b);
      if (Array.isArray(solution)) {
        return `x = ${solution.map((sol) => this.formatResult(sol)).join(" or ")}`;
      } else {
        return `x = ${this.formatResult(solution)}`;
      }
    } catch (error) {
      throw new Error(`Failed to solve equation: ${error.message}`);
    }
  }
  extractCoefficients(expr) {
    let a2 = 0;
    let b = 0;
    const extractFromNode = (node) => {
      if (isOperatorNode(node)) {
        if (node.fn === "add") {
          node.args.forEach(extractFromNode);
        } else if (node.fn === "multiply") {
          if (node.args.length === 2 && isSymbolNode(node.args[1]) && node.args[1].name === "x") {
            a2 += this.mathInstance.evaluate(node.args[0].toString());
          } else {
            b += this.mathInstance.evaluate(node.toString());
          }
        } else if (node.fn === "unaryMinus") {
          if (isSymbolNode(node.args[0]) && node.args[0].name === "x") {
            a2 -= 1;
          } else {
            b -= this.mathInstance.evaluate(node.args[0].toString());
          }
        } else {
          b += this.mathInstance.evaluate(node.toString());
        }
      } else if (isSymbolNode(node) && node.name === "x") {
        a2 += 1;
      } else if (isConstantNode(node)) {
        b += node.value;
      } else {
        b += this.mathInstance.evaluate(node.toString());
      }
    };
    extractFromNode(expr);
    return { a: a2, b: -b };
  }
  solveLinearEquation(a2, b) {
    if (a2 === 0) {
      if (b === 0) {
        return [];
      } else {
        throw new Error("No solution");
      }
    } else {
      return b / a2;
    }
  }
  formatResult(result) {
    if (typeof result === "number") {
      return result.toPrecision(6);
    } else if (isMatrix(result)) {
      return format4(result, { precision: 6 });
    } else if (isUnit(result)) {
      return result.format({ precision: 6 });
    } else {
      return this.mathInstance.format(result, { precision: 6 });
    }
  }
  showHistory() {
    const historyModal = new HistoryModal(this.app, this.history);
    historyModal.open();
  }
};
var HistoryModal = class extends import_obsidian.Modal {
  constructor(app, history) {
    super(app);
    this.history = history;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Calculation History" });
    const historyList = contentEl.createEl("ul");
    this.history.slice().reverse().forEach((item) => {
      historyList.createEl("li", { text: item });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
/*! Bundled license information:

complex.js/complex.js:
  (**
   * @license Complex.js v2.1.1 12/05/2020
   *
   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

fraction.js/fraction.js:
  (**
   * @license Fraction.js v4.3.0 20/08/2023
   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2023, Robert Eisele (robert@raw.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
